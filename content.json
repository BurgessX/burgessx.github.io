{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/02/26/1919.html"},{"title":"","text":"文献检索关键词 INS IMU(Inertial Measurement Units) Visual localization/Navigation/Positioning graph-based, image-based, vision-based, optical AUV localization/Navigation/Positioning multi-sensor fusion Underwater Vehicle SLAM Particle Filter monocular camera（单目摄像头） （Fast）Binocular Localization（双目定位） MAC Delay Subsea review AUV docking（悬停？） 先在endnote上检索，再去一些顶刊网站检索 Autonomous Robots（https://www.springer.com/journal/10514） Journal of Mechanisms and Robotics（https://www.journals.elsevier.com/robotics-and-autonomous-systems/） Robotics and Autonomous Systems（https://www.journals.elsevier.com/robotics-and-autonomous-systems/） Robotica（https://www.cambridge.org/core/journals/robotica） c425 c301 c203c","link":"/2021/01/12/1716.html"},{"title":"文献阅读笔记","text":"可见光通信Visible Light Communication, Networking, and Sensing A Survey, Potential and Challenges人眼对黄光和绿光最敏感，而白色LED（蓝色LED+黄色荧光粉涂层）的蓝光和黄光的辐射能量最大。 黄色荧光层的响应速率慢，蓝光快 设备移动对接收能量有影响 雪崩光电二极管能增大传输速率 实现调制和调光的方法： OOK：0和1传输，其中0可以不完全是0（改变了强度）。每个信号包括多个脉冲。 脉冲调制： 脉冲宽度调制（PWM），没有改变脉冲的强度 脉冲位置调制（PPM） 想法： 水下实时调整LED的荧光层的厚度，以使信号时刻处于最小衰减率。或者每隔一段时间调整一次。 还不如直接用蓝色LED 蓝色LED灯的波长能够实时调整吗？ 555nm（绿光）的发光效率最高，但是蓝光在水下的衰减率最小，因此最好选择一种处于绿光和蓝光之间的颜色的光，来权衡功耗和传输距离。当然最好能够根据传输距离实时改变波长。","link":"/2021/02/28/1533.html"},{"title":"百度高级搜索的方法","text":"方法一嫌麻烦或记不住的话可以采用这种方法。在百度首页直接点击右上角的 设置→高级搜索，在弹出的对话框中按提示填入搜索信息。 方法二采用高级语法进行搜索。 intitle：搜索范围限定在网页标题网页标题通常是对网页内容提纲挈领式的归纳。把查询内容范围限定在网页标题中，有时能获得良好的效果。 语法结构： 1内容 intitle:标题中要包含的内容 例如： 1web学习 intitle:安全 注意：intitle: 和后面的关键词之间不要有空格，下同。 site：搜索范围限定在特定站点中如果知道某个站点中有自己需要找的东西，就可以把搜索范围限定在这个站点中，提高查询效率。 语法结构： 1你要查找的信息 site:网站地址 例如： 1百度知道 site:www.y80s.com 注意： site: 后面跟的站点域名，不要带 http://。 site: 和站点名之间，不要带空格。 inurl：搜索范围限定在url链接中网页 URL 中的某些信息，常常有某种有价值的含义。您如果对搜索结果的 URL 做某种限定，可以获得良好的效果。 语法结构： 1你要查找的信息 inurl:相关信息（必须是字母） 例如： 1PS视频教程 inurl:video 注意： 查询词 PS视频教程 是可以出现在网页的任何位置，而 video 则必须出现在网页包含的url链接中。 双引号“”和书名号《》：精确匹配双引号查询词加上双引号“”则表示查询词不能被拆分，在搜索结果中必需完整出现，可以对查询词精确匹配。如果不加双引号“”经过百度分析后可能会拆分。 书名号书名号是百度独有的一个特殊查询语法。在其他搜索引擎中，书名号会被忽略，而在百度，中文书名号是可被查询的。 加上书名号的查询词，有两层特殊功能，一是书名号会出现在搜索结果中；二是被书名号扩起来的内容，不会被拆分。 书名号在某些情况下特别有效果，例如查名字很通俗和常用的那些电影或者小说。比如，查电影“手机”，如果不加书名号，很多情况下出来的是通讯工具——手机，而加上书名号后，《手机》结果就都是关于电影方面的了。 filetype：指定文件类型用这个语法来对搜索对象做限制，冒号后是文档格式，如PDF、DOC、XLS等。例： 1霍金 黑洞 filetype:pdf “-”：去除所有包含特定关键词的网页语法结构： 1要查找的信息 -你要去掉的信息 例： 1神雕侠侣 -电视剧 比如说查找神雕侠侣武侠小说方面的内容，却发现有很多关于电视剧的网页，可以使用这个语法去掉电视剧方面的信息。 注意： 前一个关键词，和减号之间必须有空格，否则，减号会被当成连字符处理，而失去减号语法功能。 减号和后一个关键词之间，有无空格均可。 intext：只在网页正文搜索语法结构： 1intext:关键词 也就是忽略了在标题、URL 等之中的文字。 注意： 只在网页正文搜索不等于标题和 URL 中一定不会出现你搜索的关键词，只不过搜索引擎不对标题和 URL 进行搜索而已。 folder：指定文件夹搜索好像是百度硬盘搜索1.1.1的 folder 语法。 语法结构： 1关键词 folder:文件所在路径 硬盘搜索就会自动搜索指定文件所在路径里面所有和关键词相关的搜索结果。 比如输入： 1九寨沟 folder:C:\\旅游照片 所有C盘“旅游照片”文件夹中的九寨沟图片都被显示出来。 “|”：扩大检索范围语法结构： 1文字 (正在连接 | 开始连接) 这里的符号“|”表示两者任意一个出现即可，是布尔语法中“逻辑或”的表现方式。 文字 (正在连接 | 开始连接) 的检索效果，相当于 文字 正在连接 加上 文字 开始连接。 如果你想用多种说法来搜索内容，可以使用“|”来扩大检索范围。 例： 12(速度与激情4 | 速度与激情IV)(速度与激情2 | 速度与激情II) 电影 还可以使用双引号，精确匹配： 1(&quot;速度与激情&quot; | &quot;速度与激情I&quot;) 电影 “+”：包含特定查询词用加号“+”语法可以帮您在搜索结果中必须包含特定的关键词所有网页。 例子： 1电影 +qvod 查询词“电影”的搜索结果中必须包含“qvod”。 邮件搜索语法：subject、to、from对于每天要处理很多邮件的用户，有了百度硬盘搜索1.1.1提供的邮件搜索语法：subject、to、from无异于如虎添翼。 只要输入“subject:文字”即可找到主题中含有“文字”的电子邮件，例如输入： 1subject:头 from:claire@email.com 就可以找到Claire发的、主题中含有“头”的email。 输入 1工作报告 to:peter@company.com 就可以找到发给Peter的所有工作报告邮件了。 参考链接 百度搜索语法大全 高级语法介绍 百度精确匹配——双引号和书名号","link":"/2021/01/30/1352.html"},{"title":"","text":"/*! normalize.css v2.1.3 | MIT License | git.io/normalize */ /* ========================================================================== HTML5 display definitions ========================================================================== */ /** * Correct `block` display not defined in IE 8/9. */ article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; } /** * Correct `inline-block` display not defined in IE 8/9. */ audio, canvas, video { display: inline-block; } /** * Prevent modern browsers from displaying `audio` without controls. * Remove excess height in iOS 5 devices. */ audio:not([controls]) { display: none; height: 0; } /** * Address `[hidden]` styling not present in IE 8/9. * Hide the `template` element in IE, Safari, and Firefox < 22. */ [hidden], template { display: none; } /* ========================================================================== Base ========================================================================== */ /** * 1. Set default font family to sans-serif. * 2. Prevent iOS text size adjust after orientation change, without disabling * user zoom. */ html { font-family: sans-serif; /* 1 */ -ms-text-size-adjust: 100%; /* 2 */ -webkit-text-size-adjust: 100%; /* 2 */ } /** * Remove default margin. */ body { margin: 0; } /* ========================================================================== Links ========================================================================== */ /** * Remove the gray background color from active links in IE 10. */ a { background: transparent; } /** * Address `outline` inconsistency between Chrome and other browsers. */ a:focus { outline: thin dotted; } /** * Improve readability when focused and also mouse hovered in all browsers. */ a:active, a:hover { outline: 0; } /* ========================================================================== Typography ========================================================================== */ /** * Address variable `h1` font-size and margin within `section` and `article` * contexts in Firefox 4+, Safari 5, and Chrome. */ h1 { font-size: 2em; margin: 0.67em 0; } /** * Address styling not present in IE 8/9, Safari 5, and Chrome. */ abbr[title] { border-bottom: 1px dotted; } /** * Address style set to `bolder` in Firefox 4+, Safari 5, and Chrome. */ b, strong { font-weight: bold; } /** * Address styling not present in Safari 5 and Chrome. */ dfn { font-style: italic; } /** * Address differences between Firefox and other browsers. */ hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; } /** * Address styling not present in IE 8/9. */ mark { background: #ff0; color: #000; } /** * Correct font family set oddly in Safari 5 and Chrome. */ code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; } /** * Improve readability of pre-formatted text in all browsers. */ pre { white-space: pre-wrap; } /** * Set consistent quote types. */ q { quotes: \"\\201C\" \"\\201D\" \"\\2018\" \"\\2019\"; } /** * Address inconsistent and variable font size in all browsers. */ small { font-size: 80%; } /** * Prevent `sub` and `sup` affecting `line-height` in all browsers. */ sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sup { top: -0.5em; } sub { bottom: -0.25em; } /* ========================================================================== Embedded content ========================================================================== */ /** * Remove border when inside `a` element in IE 8/9. */ img { border: 0; } /** * Correct overflow displayed oddly in IE 9. */ svg:not(:root) { overflow: hidden; } /* ========================================================================== Figures ========================================================================== */ /** * Address margin not present in IE 8/9 and Safari 5. */ figure { margin: 0; } /* ========================================================================== Forms ========================================================================== */ /** * Define consistent border, margin, and padding. */ fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; } /** * 1. Correct `color` not being inherited in IE 8/9. * 2. Remove padding so people aren't caught out if they zero out fieldsets. */ legend { border: 0; /* 1 */ padding: 0; /* 2 */ } /** * 1. Correct font family not being inherited in all browsers. * 2. Correct font size not being inherited in all browsers. * 3. Address margins set differently in Firefox 4+, Safari 5, and Chrome. */ button, input, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 2 */ margin: 0; /* 3 */ } /** * Address Firefox 4+ setting `line-height` on `input` using `!important` in * the UA stylesheet. */ button, input { line-height: normal; } /** * Address inconsistent `text-transform` inheritance for `button` and `select`. * All other form control elements do not inherit `text-transform` values. * Correct `button` style inheritance in Chrome, Safari 5+, and IE 8+. * Correct `select` style inheritance in Firefox 4+ and Opera. */ button, select { text-transform: none; } /** * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio` * and `video` controls. * 2. Correct inability to style clickable `input` types in iOS. * 3. Improve usability and consistency of cursor style between image-type * `input` and others. */ button, html input[type=\"button\"], /* 1 */ input[type=\"reset\"], input[type=\"submit\"] { -webkit-appearance: button; /* 2 */ cursor: pointer; /* 3 */ } /** * Re-set default cursor for disabled elements. */ button[disabled], html input[disabled] { cursor: default; } /** * 1. Address box sizing set to `content-box` in IE 8/9/10. * 2. Remove excess padding in IE 8/9/10. */ input[type=\"checkbox\"], input[type=\"radio\"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ } /** * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome. * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome * (include `-moz` to future-proof). */ input[type=\"search\"] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box; } /** * Remove inner padding and search cancel button in Safari 5 and Chrome * on OS X. */ input[type=\"search\"]::-webkit-search-cancel-button, input[type=\"search\"]::-webkit-search-decoration { -webkit-appearance: none; } /** * Remove inner padding and border in Firefox 4+. */ button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; } /** * 1. Remove default vertical scrollbar in IE 8/9. * 2. Improve readability and alignment in all browsers. */ textarea { overflow: auto; /* 1 */ vertical-align: top; /* 2 */ } /* ========================================================================== Tables ========================================================================== */ /** * Remove most spacing between table cells. */ table { border-collapse: collapse; border-spacing: 0; } .go-top { position: fixed; bottom: 2em; right: 2em; text-decoration: none; background-color: #E0E0E0; font-size: 12px; padding: 1em; display: inline; } /* Github css */ html,body{ margin: auto; padding-right: 1em; padding-left: 1em; max-width: 44em; color:black;}*:not('#mkdbuttons'){margin:0;padding:0}body{font:13.34px helvetica,arial,freesans,clean,sans-serif;-webkit-font-smoothing:subpixel-antialiased;line-height:1.4;padding:3px;background:#fff;border-radius:3px;-moz-border-radius:3px;-webkit-border-radius:3px}p{margin:1em 0}a{color:#4183c4;text-decoration:none}body{background-color:#fff;padding:30px;margin:15px;font-size:14px;line-height:1.6}body>*:first-child{margin-top:0!important}body>*:last-child{margin-bottom:0!important}@media screen{body{box-shadow:0 0 0 1px #cacaca,0 0 0 4px #eee}}h1,h2,h3,h4,h5,h6{margin:20px 0 10px;padding:0;font-weight:bold;-webkit-font-smoothing:subpixel-antialiased;cursor:text}h1{font-size:28px;color:#000}h2{font-size:24px;border-bottom:1px solid #ccc;color:#000}h3{font-size:18px;color:#333}h4{font-size:16px;color:#333}h5{font-size:14px;color:#333}h6{color:#777;font-size:14px}p,blockquote,table,pre{margin:15px 0}ul{padding-left:30px}ol{padding-left:30px}ol li ul:first-of-type{margin-top:0}hr{background:transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;border:0 none;color:#ccc;height:4px;padding:0}body>h2:first-child{margin-top:0;padding-top:0}body>h1:first-child{margin-top:0;padding-top:0}body>h1:first-child+h2{margin-top:0;padding-top:0}body>h3:first-child,body>h4:first-child,body>h5:first-child,body>h6:first-child{margin-top:0;padding-top:0}a:first-child h1,a:first-child h2,a:first-child h3,a:first-child h4,a:first-child h5,a:first-child h6{margin-top:0;padding-top:0}h1+p,h2+p,h3+p,h4+p,h5+p,h6+p,ul li>:first-child,ol li>:first-child{margin-top:0}dl{padding:0}dl dt{font-size:14px;font-weight:bold;font-style:italic;padding:0;margin:15px 0 5px}dl dt:first-child{padding:0}dl dt>:first-child{margin-top:0}dl dt>:last-child{margin-bottom:0}dl dd{margin:0 0 15px;padding:0 15px}dl dd>:first-child{margin-top:0}dl dd>:last-child{margin-bottom:0}blockquote{border-left:4px solid #DDD;padding:0 15px;color:#777}blockquote>:first-child{margin-top:0}blockquote>:last-child{margin-bottom:0}table{border-collapse:collapse;border-spacing:0;font-size:100%;font:inherit}table th{font-weight:bold;border:1px solid #ccc;padding:6px 13px}table td{border:1px solid #ccc;padding:6px 13px}table tr{border-top:1px solid #ccc;background-color:#fff}table tr:nth-child(2n){background-color:#f8f8f8}img{max-width:100%}code,tt{margin:0 2px;padding:0 5px;white-space:nowrap;border:1px solid #eaeaea;background-color:#f8f8f8;border-radius:3px;font-family:Consolas,'Liberation Mono',Courier,monospace;font-size:12px;color:#333}pre>code{margin:0;padding:0;white-space:pre;border:0;background:transparent}.highlight pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre{background-color:#f8f8f8;border:1px solid #ccc;font-size:13px;line-height:19px;overflow:auto;padding:6px 10px;border-radius:3px}pre code,pre tt{background-color:transparent;border:0}.poetry pre{font-family:Georgia,Garamond,serif!important;font-style:italic;font-size:110%!important;line-height:1.6em;display:block;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif!important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;vertical-align:super;position:relative}sub{vertical-align:sub;top:-1px}@media print{body{background:#fff}img,pre,blockquote,table,figure{page-break-inside:avoid}body{background:#fff;border:0}code{background-color:#fff;color:#333!important;padding:0 .2em;border:1px solid #dedede}pre{background:#fff}pre code{background-color:white!important;overflow:visible}}@media screen{body.inverted{color:#eee!important;border-color:#555;box-shadow:none}.inverted body,.inverted hr .inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dd,.inverted dt,.inverted blockquote{color:#eee!important;border-color:#555;box-shadow:none}.inverted td,.inverted th{background:#333}.inverted h2{border-color:#555}.inverted hr{border-color:#777;border-width:1px!important}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eee}code span::selection{background-color:rgba(0,0,0,0.7)!important;color:#eee!important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}.inverted{background:#0b2531;background:#252a2a}.inverted body{background:#252a2a}.inverted a{color:#acd1d5}}.highlight .c{color:#998;font-style:italic}.highlight .err{color:#a61717;background-color:#e3d2d2}.highlight .k,.highlight .o{font-weight:bold}.highlight .cm{color:#998;font-style:italic}.highlight .cp{color:#999;font-weight:bold}.highlight .c1{color:#998;font-style:italic}.highlight .cs{color:#999;font-weight:bold;font-style:italic}.highlight .gd{color:#000;background-color:#fdd}.highlight .gd .x{color:#000;background-color:#faa}.highlight .ge{font-style:italic}.highlight .gr{color:#a00}.highlight .gh{color:#999}.highlight .gi{color:#000;background-color:#dfd}.highlight .gi .x{color:#000;background-color:#afa}.highlight .go{color:#888}.highlight .gp{color:#555}.highlight .gs{font-weight:bold}.highlight .gu{color:#800080;font-weight:bold}.highlight .gt{color:#a00}.highlight .kc,.highlight .kd,.highlight .kn,.highlight .kp,.highlight .kr{font-weight:bold}.highlight .kt{color:#458;font-weight:bold}.highlight .m{color:#099}.highlight .s{color:#d14}.highlight .na{color:#008080}.highlight .nb{color:#0086b3}.highlight .nc{color:#458;font-weight:bold}.highlight .no{color:#008080}.highlight .ni{color:#800080}.highlight .ne,.highlight .nf{color:#900;font-weight:bold}.highlight .nn{color:#555}.highlight .nt{color:#000080}.highlight .nv{color:#008080}.highlight .ow{font-weight:bold}.highlight .w{color:#bbb}.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:#099}.highlight .sb,.highlight .sc,.highlight .sd,.highlight .s2,.highlight .se,.highlight .sh,.highlight .si,.highlight .sx{color:#d14}.highlight .sr{color:#009926}.highlight .s1{color:#d14}.highlight .ss{color:#990073}.highlight .bp{color:#999}.highlight .vc,.highlight .vg,.highlight .vi{color:#008080}.highlight .il{color:#099}.highlight .gc{color:#999;background-color:#eaf2f5}.type-csharp .highlight .k,.type-csharp .highlight .kt{color:#00F}.type-csharp .highlight .nf{color:#000;font-weight:normal}.type-csharp .highlight .nc{color:#2b91af}.type-csharp .highlight .nn{color:#000}.type-csharp .highlight .s,.type-csharp .highlight .sc{color:#a31515}","link":"/2021/01/22/1953.html"},{"title":"","text":"深度学习-学习笔记高斯白噪声分布：如果一个噪声，它的幅度分布服从高斯分布，而它的功率谱密度又是均匀分布的，则称它为高斯白噪声。","link":"/2020/06/06/2211.html"},{"title":"Github Pages 创建","text":"代码高亮工具 Jekyll自带的 Pygments Rouge（Jekyll默认） Highlight JS 兼容 Rouge 与 Pygments。 SyntaxHighlighter Prismjs Jekyll 并不能直接支持他，需要下载 prism.rb 插件来使用。下载后拷贝到项目“_plugins“ 文件夹中。","link":"/2021/02/05/2136.html"},{"title":"智能家居项目 WIFI 配置","text":"缩写 缩写 全称 翻译 AP Access Point 接入点 如路由器 STA Station 站 如手机 DHCP Dynamic Host Configuration Protocol 动态主机配置协议 AT Attention 应用于终端设备与PC应用之间的连接与通信的指令 透传 透明传输 发送什么就传输什么 九种模式（TCP 服务器、TCP 客户端，UDP）||（TCP 服务器、TCP 客户端，UDP） TCP或UDP 服务器或客户端或双向 项目 小车——TCP客户端 电脑——TCP服务器 连接：电脑—路由器——小车 过程： 电脑的TCP服务器开启 小车的TCP客户端开启 小车通过搜索路由器的wifi，连接上电脑 小车与电脑通讯 开发板直连电脑方法 首先禁止wifi 如果不禁用wifi，则不知道路由器配置的网段是多少 电脑网络设置 IP地址：192.168.1.22 子网掩码：255.255.255.0 默认网关：192.168.1.1 首选DNS服务器：192.168.1.1（可以不设置） Ubuntu设置 IP地址：192.168.1.23 子网掩码：255.255.255.0 默认网关：192.168.1.1 首选DNS服务器：192.168.1.1（可以不设置） 设置完后重启网卡 方法1：右上角打开再关闭 方法2：中断输入命令：ifconfig 测试 Ubuntu中：ping 192.168.1.22 Windows中：ping 192.168.1.23 开发板设置用U-Boot设置环境变量 IP地址：192.168.1.24 MAC地址：00:04:9f:04:d2:35 子网掩码：255.255.255.0 默认网关：192.168.1.1 首选DNS服务器：192.168.1.1（可以不设置） 环境变量设置命令如下 123456setenv ipaddr 192.168.1.24setenv ethaddr 00:04:9f:04:d2:35setenv gatewayip 192.168.1.1setenv netmask 255.255.255.0setenv serverip 192.168.1.1saveenv 下载Linux镜像？ 1tftp 80800000 zImage 测试 ping Windows：ping 192.168.1.22 ping Ubuntu：ping 192.168.1.23 注意：不能用Windows和Ubuntu Ping U-Boot","link":"/2020/02/19/1447.html"},{"title":"基于 RPMsg 的 RPC 协议层","text":"参考：RPMsg：协议简介 缩写 英文全称 中文全称 SCR Serial Control Register 串行控制寄存器 PRUSS Programmable Real Time Unit Subsystem 可编程实时单元子系统 RPC Remote Procedure Call 远程过程调用 RMI Remote Method Invocation 远程方法调用 RPMsg Remote Processor Messaging 远程处理器消息 IPC Inter Processor Communication 跨处理器通信 AMP Asymmetric Multi-Processing 异构多核处理系统 SMP Symmetric Multiprocessing 同构多核处理系统 RTOS Real Time Operating System 实时操作系统 RPC/RMIRPC就是实现本地程序调用位于另一个地址空间的例程（routine）的一种技术手段。 RPC实现方法：gRPC、Dubbo、Thrift和FastRPC等 RPC数据的序列化和反序列化方法：JSON、XML以及谷歌推出的Protocol Buffer、Flat Buffer等格式 RPC数据传递方法：HTTP、TCP等网络协议栈、RPMsg等 RPC基本架构 RPMsg协议RPMsg，全称Remote Processor Messaging，它定义了异构多核处理系统（AMP，Asymmetric Multiprocessing）中核与核之间进行通信时所使用的标准二进制接口。 基于RPMsg的RPC协议层 传输层：RPMsg MAC层（数据链路层的下层）：VirtIO/Virtqueue 物理层：共享内存跨核中断 RPMsg消息格式","link":"/2021/01/18/1040.html"},{"title":"无线通信技术","text":"无线通信技术的演变2G2G的演变 2nd Generation 技术 传输速率 2G GSM技术 10kbps 2G CDMA 10kbps 2.5G GPRS ~50kbps 2.5G EDGE ~200kbps 2G相关技术 缩写 英文全称 中文 GSM Global System for Mobile communications 全球移动通信系统 CDMA Code Division For Multiple Access 码分多址 GPRS General Packet Radio Service 通用无线分组业务 EDGE Enhanced Data Rate for GSM Evolution 增强型数据速率GSM演进技术 3G3G的演变 3rd Generation 技术 传输速率 3G WCDMA/UMTS ~384kbps 3G CDMA 2000 ~384kbps 3.5G HSDPA 5~30Mbps 3.5G 1 EVDO Rev A,B,C 5~30Mbps 3G相关技术 缩写 英文全称 中文 WCDMA Wideband Code Division For Multiple Access 宽带码分多址 UMTS Universal Mobile Telecommunication Standard/System 通用移动通信标准 HSDPA High Speed Downlink Packet Access 高速下行链路分组接入 EVDO Evolution Data Optimized 4G4G的演变 4rd Generation 技术 传输速率 4G LTE 100~200Mbps 4G WiMAX ~100Mbps 4G相关技术 缩写 英文全称 中文 LTE Long Term Evolution 长期演进 WiMAX World Interoperability for Microwave Access 全球微波接入互操作性","link":"/2021/01/19/1642.html"},{"title":"抽象代数基本知识","text":"恒等元、单位元与逆元恒等元对于某非空集合，若在运算*下，存在元素$e$，使得对于任意元素$a$，都存在元素$a^{-1}$，满足$aa^{-1}=a^{-1}a=e$，则称$e$为集合的恒等元，$a^{-1}$称为元素$a$的逆元素**。 单位元Identity Element，也叫幺元，通常使用$e$来表示单位元。单位元和其他元素结合时，并不会改变那些元素。 对于二元运算*，若$ae=a$，$e$称为右单位元；若$ea=a$，$e$称为左单位元，若$ae=ea=a$，则$e$称为单位元。 恒等元就是单位元 逆元设$e$为单位元，对于二元运算*，若$ab=e$，则$a$称为$b$的左逆元素，b称为a的右逆元素；若$ab=b*a=e$，则称$a$为$b$的逆元，$b$为$a$的逆元。 群对某种运算满足封闭性、结合律，且含有恒等元 $e$。 例：全体整数对于普通加法是群，0是恒等元，每个元素的相反数为其逆元素。 阿贝尔群某运算下满足交换律的群叫该运算下的阿贝尔群。 群按元素的数量可分为有限群和无限群。 环若非空集合$R$满足： $R$是加法运算下的阿贝尔群 对乘法满足封闭性、结合律（可以不含恒等元，可以不满足交换律） 满足加法和乘法的分配律 则称$R$为环。 域若非空集合$F$满足： 是加法运算下的阿贝尔群 $F$中非0元素在乘法下构成群 满足加法和乘法的分配律 则称$F$为域。 注：域是有单位元素，非零元素有逆元素的环。","link":"/2021/01/17/1508.html"},{"title":"调制技术","text":"参考：B站视频 为什么要调制天线的长度和发送信号的频率呈反比，因此传送低频信号所需天线会很长，调制能够把低频信号用高频电磁波来传送，因此能够缩短天线的长度 调制的分类模拟调制 数字调制基本的数字调制 移幅键控 移频键控 移相键控 这里是BPSK MPSK（多进制数字相位调制）QPSK（正交相移键控） Quadrature Phase Shift Keying，QPSK，正交相移键控，一种四相位调制方法 一次发送2bit的信息，需要4种不同的相位 8PSK（8进制相位键控） 一次发送3bit的信息，需要8种不同的相位 一次发送n bit的信息，需要2^n种不同的相位 MQAM（多进制正交幅度调制）有16QAM，64QAM等 星座图3G：16QAM，4bit 4G：64QAM，6bit 5G：256QAM，8bit","link":"/2021/01/19/1458.html"},{"title":"Win10 使用技巧","text":"快捷键123win + v # 打开剪切板win + shift + s # 截屏win + d # 回到桌面","link":"/2021/03/02/1448.html"},{"title":"U盘启动模式","text":"转载的 在制作U盘启动盘时，很多用户发现U盘写入模式有USB-HDD、USB-HDD+、USB-ZIP、USB-ZIP+、USB-CDROM和USB-FDD等等，不知道要选择哪一个，那么这些U盘启动模式有什么区别呢？接下来就跟大家介绍各种USB启动模式的区别。 一、USB-HDD USB-HDD是 USB Hard Drives 的缩写，表示硬盘仿真模式，启动后U盘的盘符为C，该模式需注意区分U盘和本地硬盘，USB-HDD模式兼容性很高，但对于一些只支持USB-ZIP模式的电脑则无法启动。 二、USB-ZIP USB-ZIP表示大容量软盘仿真模式，在一些主板较老的主板上USB-ZIP是唯一的启动模式，启动后U盘盘符为A，USB-ZIP对于新主板电脑来说兼容性并不好，也不兼容2GB以上的U盘。 三、USB-FDD USB-FDD是Floppy Disk Drive的缩写，表示软驱磁盘驱动器，目前已经被淘汰，只存在于早期的电脑中。FDD模式把U盘模拟成软驱模式，启动后U盘被认作软盘，盘符显示为A。需要注意的是，支持USB-FDD的机器也会找不到该模式的U盘。 四、USB-CDROM USB-CDROM表示光盘仿真模式，DOS启动后不占用盘符，大多数主板都支持这个模式，该模式的U盘可以和光盘一样使用来安装系统，制作时需根据U盘型号进行量产。 五、USB-HDD+ USB-HDD+是USB-HDD的增强模式，兼容性高于USB-HDD模式，但对仅支持USB-ZIP的电脑仍然无法启动，在DOS下启动后U盘盘符也显示为C盘。 六、USB-ZIP+ USB-ZIP+是USB-ZIP的增强模式，在DOS启动后盘符显示A，也有些显示C:盘(根据电脑的BIOS支持情况不同)，支持USB-ZIP/USB-HDD双模式启动，从而达到很高的兼容性。有些支持USB-HDD的电脑会将此模式的U盘认为是USB-ZIP来启动，从而导致大容量U盘的性能有所降低。 以上就是各种U盘启动模式的概念以及区别，通常在实际的操作过程中，多数选择USB-HDD或USB-HDD+，一些只支持USB-ZIP的主板才选择USB-ZIP或USB-ZIP+模式。","link":"/2019/09/29/1139.html"},{"title":"主分区、扩展分区和逻辑分区","text":"大体的意思就如上图所示 主分区：也叫引导分区，最多可能创建4个，当创建四个主分区时候，就无法再创建扩展分区了，当然也就没有逻辑分区了。主分区是独立的，对应磁盘上的第一个分区，“一般”就是C盘。在Windows系统把所有的主分区和逻辑分区都叫做“盘”或者“驱动器”，并且把所有的可存储介质都显示为操作系统的“盘”。因此，从“盘”的概念上无法区分主分区和逻辑分区。并且盘符可以在操作系统中修改，这就是要加上“一般”二字的原因。 扩展分区：除了主分区外，剩余的磁盘空间就是扩展分区了，扩展分区是一个概念，实际上是看不到的。当整个硬盘分为一个主分区的时候，就没有了扩展分区。 逻辑分区：在扩展分区上面，可以创建多个逻辑分区。逻辑分区相当于一块存储截止，和操作系统还有别的逻辑分区、主分区没有什么关系，是“独立的”。 活动分区：就是当前活动的、操作系统可以启动的分区。","link":"/2019/10/01/2250.html"},{"title":"MBR+Legacy &amp; GPT+UEFI","text":"MBR+Legacy &amp; GPT+UEFI 硬盘分区表格式 MBR（”主引导记录“，Master Boot Record） GPT（“全局唯一标识磁盘分区表“，GUID Partition Table） 可扩展固件接口EFI（Extensible Firmware Interface）标准的一部分 BIOS启动模式： Legacy BIOS UEFI BIOS（“统一的可扩展固件接口” ，Unified Extensible Firmware Interface） 启动电脑时 若系统盘是MBR分区，则必须以Legacy模式启动 若系统盘是GPT分区，则必须以UEFI模式启动 安装系统时 Legacy：安装后只能以Legacy模式启动 UEFI：安装后只能以UEFI模式启动 Legacy + UEFI：安装后能以Legacy模式或UEFI模式启动 UEFI是由EFI1.10为基础发展起来的，它的所有者已不再是Intel，而是一个称作Unified EFI Form的国际组织，贡献者有Intel，Microsoft，AMI，等几个大厂，属于open source，目前版本为2.1。 原文：新型UEFI，全称“统一的可扩展固件接口”(Unified Extensible Firmware Interface)， 是一种详细描述类型接口的标准。这种接口用于操作系统自动从预启动的操作环境，加载到一种操作系统上。 因为硬件发展迅速，传统式（Legacy）BIOS 成为进步的包袱，现在已发展出最新的UEFI（Unified Extensible Firmware Interface）可扩展固件接口，相比传统 BIOS 的来说，未来将是一个“没有特定 BIOS”的电脑时代。 简单的讲Legacy就是以传统BIOS启动，可以进行MBR分区的系统安装，但是GPT分区必须UEFI启动。所以一般出厂带win8的机器一般是UEFI启动的硬盘分区格式也是GPT的，如果需要安装XP之类的非UEFI启动的系统必须选Legacy。64位的win7是可以UEFI安装的所以不必选Legacy。 UEFI引导系统,现在的电脑大多数使用了UEFI引导系统(原来都是使用BIOS),从而加快启动速度。UEFI启动是一种新的主板引导项，正被看做是有近20多年历史的BIOS的继任者。顾名思义，快速启动是可以提高开机后操作系统的启动速度。由于开机过程中UEFI的介入，使得Windows8的开机进入系统的方式将不同于传统的开机流程。在SSD颠覆了电脑开机慢的问题之后，UEFI+Win8很有可能再一次颠覆我们对于开机速度的概念。 扩展资料 1.Legacy+UEFI启动模式是基于某些电脑硬件设备和操作系统（如WinXP/7）还不支持基于UEFI BIOS的情况，考虑从传统BIOS引导模式启动。 2.传统BIOS引导模式允许Hba，模块设备使用Rom选项。 3.UEFI启动模式用于操作系统自动从预启动的操作环境，加载到一种操作系统上，从而使开机程序化繁为简，节省时间。 4.支持2T以上硬盘，加强对硬件的支持。 5.UEFI与Legacy+UEFI启动模式的区别： 6.很多重装电脑操作系统的用户如果使用的是光盘启动，都要跟BIOS打交道。 7.当进入Bios设置启动模式时，会发现有两种模式，即Legacy+UEFI和UEFI。 启动模式： 1.Legacy+UEFI启动模式和UEFI启动模式，其中Legacy+UEFI启动模指的是UEFI和传统BIOS共存模式，可以兼容传统BIOS引导模式启动操作系统。 2.UEFI启动模式只是在UEFI引导模式启动操作系统。 注意事项： 1.选定启动模式并安装操作系统，安装后只能使用设定的模式，用于启动操作系统。 2.操作系统安装时使用Legacy+UEFI模式，兼容在传统BIOS引导模式启动操作系统。 3.操作系统安装时使用UEFI引导模式，只能在UEFI引导模式启动操作系统。","link":"/2019/09/27/2218.html"},{"title":"在移动固态硬盘上装 ubuntu 的分区方法","text":"创建分区：左下角“+”依次为ubuntu创建分区（本例中全部设置为主分区） 大小：500MB； 新分区类型：主分区 新分区位置：空间起始位置 用于：EFI 大小：500MB； 新分区类型：主分区 新分区位置：空间起始位置 用于：Ext4 挂载点：/Boot 以上为两种引导方式对应的分区 大小：18000MB； 新分区类型：主分区 新分区位置：空间起始位置 用于：交换空间（swap area）（=物理内存*2,8GB也够用） 大小：100000MB； 新分区类型：主分区 新分区位置：空间起始位置 用于：Ext4（安装软件用的） 挂载点：/ home分区 EFI 分区的作用和boot引导分区一样，但是boot引导是默认grub引导的，而EFI显然是UEFI引导的。 然后又是最关键的一个地方，最下面的“安装启动引导器的设备”，这里应该把它改成你刚刚分配EFI系统引导分区的那个分区。","link":"/2019/09/29/1309.html"},{"title":"SLAM 学习笔记","text":"参考：高翔的视觉SLAM十四讲 引言困难之处 三维空间的运动 受到噪声影响 数据来源只有图像 人类看到的是图像，计算机看到的是数值矩阵 从学习角度来看 牵涉到的理论太广 从理论到实现困难 资料缺乏 需要的知识 机器人学 计算机视觉 状态估计（有噪声） 计算机科学（写代码来实现） 预备知识 数学：高等数学、线性代数（矩阵论）、概率论 编程：C++、Linux，了解语法和基本命令即可 不提供windows环境下的方案 推荐书籍 The Bible: Multiple View Geometry in Computer Vision State Estimation for Robotics: A Matric-Lie-Group Approach Probabilistic Robotics 第二讲 初识SLAM两类传感器 二维码marker GPS 导轨、磁条 携带于机器人本体上的 IMU 激光 相机 SLAM强调未知环境，更重视携带式传感器 相机分类 单目：Monocular，通过移动相机估计深度（Moving View Stereo） 双目：Stereo，通过视差计算深度 深度：RGBD，通过物理方法（TOF、结构光）直接测量深度 其他：鱼眼、全景、Event Camera，etc. 单目估计深度的方法：运动起来后，近处的物体运动快，远处的物体运动慢 双目相机：通过左右眼的微小差异判断远近，远处的物体变化小，近处的物体变化大 深度相机特点：深度值较准确；量程小；易受干扰 视觉SLAM框架 前端：VO 后端：Optimization 回环检测：Loop Closing 建图：Mapping 视觉里程计 相邻图像估计相机运动 基本形式：通过两张图像计算运动和结构 不可避免地有漂移 方法 特征点法 直接法 后端优化 从带有噪声的数据中优化轨迹和地图（状态估计问题） 最大后验概率估计（MAP） 方法：前期以EKF为代表，现在以图优化为代表 回环检测 检测机器人是否回到早先位置 识别到达过的场景 计算图像间的相似性 方法：词袋模型 建图 用于导航、规划、通讯、可视化、交互等 度量地图 vs 拓扑地图 稀疏地图 vs 稠密地图 数学描述 离散时间 位置x 路标y 噪声v 观测z 用g++或gcc编译： 1g++ main.cpp -o helloSLAM 运行 1./helloSLAM 用g++来编译很麻烦，所以一般新建CMakeLists.txt文件，采用cmake生成一个工程，产生MakeFile等文件，再用make命令来编译。 创建CMakeLists.txt 12cmake .make 因为编译会生成许多中间文件，我们不想要，所以可以新建一个build文件夹，进入此文件夹，然后 12cmake ..make 这样cmake生成的临时文件和make生成的可执行文件都会放到build文件夹下。 IDE: KDevelopKDevelop可以很方便地编译cmake工程，因此这里假设我们的C++工程中已经创建好了CMakeLists.txt文件。 打开工程点击Project-&gt;Open/Import Project，然后选择CMakeLists.txt文件即可自动创建工程。 创建工程后会自动将工程添加到Project视图的Build Sequence下。 编译编译有多种方法： 点击Build会按顺序执行Build Sequence下的项目，该队列可以自行增删和调序。 选中项目，点击Build Selection图标（在Projects Tool Bar中，空白处右键可调出）理论上即可编译选中的项目。 但实测发现在Build Sequence中有项目时，Build Selection按钮和Build按钮一样会把Build Sequence下的项目全部编译。 选中项目，右键点击Build即可编译指定项目。 启动配置Run-&gt;Configure Launches-&gt;Add New，即可对项目新建自定义的启动配置，包括选择可执行文件、行为和依赖。 这一步可不配置按默认。如果有多个可执行文件的话可以配置一下要执行的可执行文件。 执行两种方法： Run-&gt;Current Launch Configuration，选中要执行的项目，然后点Execute执行。 在Project视图中选中要执行的项目，右键Execute As-&gt;Compiled Binary。 总结全部用右键的方法最直接了。 三维空间刚体运动旋转矩阵、变换矩阵、四元数、欧拉角 Eigen库 旋转矩阵旋转矩阵R 正交 行列式为1 特殊正交群 变换矩阵变换矩阵T、齐次坐标 特殊欧式群 EIGEN的矩阵运算库EIGEN：C++的矩阵运算库 1sudo apt-get install libeigen3-dev /usr/include/eigen3 没有库，只是头文件(所以不用链接到库文件（函数的实现）！) 1include_directories( &quot;/usr/include/eigen3&quot; ) 123Eigen::Matrix&lt;double, 3, 3&gt; R1_33Eigen::Matrix3f R2_33 // float型3×3矩阵Eigen::Vector3d v1 // 3×1向量 注意：矩阵的变量类型要一样才能乘，比如double不能乘float QR分解求矩阵的逆。比直接求逆快一些。 角轴或轴角或旋转向量罗德里格斯公式：RF公式 Rn=n： n绕自己转还是自己。 看成特征方程，特征值为1 欧拉角分类 定轴、动轴 顺序：X-Y-Z等 问题：万向锁（Gimbal Lock） 第二次旋转如果是正负90度，则第三次旋转和第一次旋转实际上是绕同一个轴，使得系统丢失了一个自由度，这说明欧拉角会存在奇异性问题 四元数四元数是复数的一种扩展，有三个虚部，可以表达三维空间中的旋转 四元数可以转换成角轴、旋转矩阵、欧拉角 四元数旋转一个空间点：p=[0,x,y,z]，经过变换q，成了p’ $p’=qpq^{-1}$ EIGEN的几何模块乘法可以不同维度。 四元数三个虚部在前。 可以用pangolin可视化 需要GLEW依赖： 1sudo apt install libglew-dev 李群与李代数直接优化旋转矩阵很困难，参数耦合，李代数为无约束的优化。 群群是一种集合加上一种运算的代数结构（抽象代数知识） 性质（充要条件） 封闭性 结合律 幺元 逆 “凤姐咬你” 可以验证 旋转矩阵集合和矩阵乘法构成群 变换矩阵集合和矩阵乘法构成群 SO(3)和SE(3)都是群 李群 具有连续（光滑）性质的群 既是群也是流形 SO(3)和SE(3)都是李群 但是SO(3)和SE(3)只有定义良好的乘法，没有加法，所以难以进行取极限、求导等连续操作 李代数李群和李代数是一一对应的关系 性质 封闭性 双线性 自反性 雅可比等价 三维空间向量+叉积运算 构成李代数 所以so(3)也是李代数 李括号运算 se(3)也满足李代数性质 李代数可以理解成向量或矩阵形式 指数映射和对数映射指数映射：罗德里格斯公式 对数映射 se(3)到SE(3)的指数映射 李代数求导与扰动模型 扰动模型更简洁、实用 推导用到了：泰勒展开、叉乘和反对称矩阵的关系 SOPHUS库不需要make install 最好make install sophus库分为无模板和模板两种版本。 ch4/useSophus/CMakeList.txt文件修改如下： 123456789cmake_minimum_required( VERSION 2.8 )project( useSophus )include_directories( &quot;/usr/include/eigen3/&quot; )include_directories( &quot;/usr/local/include/sophus/&quot; ) # 这里是头文件add_executable( useSophus useSophus.cpp )target_link_libraries( useSophus &quot;/usr/local/lib/libSophus.so&quot; )# 这里是链接到函数的实现 在Sophus中，se(3)的平移在前，旋转在后. 相机与图像相机模型齐次坐标：与距离无关 单目：小孔成像 畸变 径向畸变 切向畸变 双目：通过视距可测距离 RGB-D 原理： ToF：面光、红外光；玻璃测不到 结构光： OpenCV图像处理库可参考：https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html 1sudo apt-get install libopencv-dev # 二进制安装 3.1.0 /usr/local/ 点云工具libpcl-dev：pcl库 pcl-tools：包含pcl可视化 非线性优化状态估计问题 线性系统，高斯噪声 非线性系统，非高斯噪声 历史上用滤波器 近年用非线性优化 最大后验估计 最大似然估计 最速下降法（一阶）、牛顿法（二阶） 高斯牛顿法：JT J近似H LM方法： CERESgoogle的库 网站：ceres sover 12345mkdir buildcd buildcmake ..makesudo make install G2O","link":"/2021/01/31/1937.html"},{"title":"Linux 常用命令及相关问题","text":"Linux 常用命令最常用的命令12345678910111213141516171819202122232425262728293031323334353637383940cd .. # 返回上一级目录cd # 返回根目录cd directory_name # 进入文件夹cd - # 返回上一次目录cd ~ # 普通用户进入 /home/&lt;user&gt; 文件夹，root 进入 /root 文件夹pwd # 显示当前目录ls # 显示当前文件夹下的文件和文件夹ls -a # 显示当前文件夹下的文件和文件夹，包括隐藏文件ls -l # 显示长信息，包括文件权限，修改时间等ls -i # 显示inode（物理索引）信息ls abc* # 列出以abc开头为文件名的所有文件rm # 删除mv # 移动cp # 拷贝mkdir directory_name # 创建文件夹mkdir -p dir1/dir2 # 递归创建文件夹touch filename # 创建文件./filename # 运行当前文件夹下的filename文件。如果不加“./”，则系统会到PATH宏下找文件？reboot # 重启su # 进入root模式（密码：root，也有可能初始没设置）exit # 如果是在root模式下，则会退出root；如果是普通用户模式下，则会退出系统sudo command_name #以root权限执行命令clear # 清屏reset # 应该是重启终端# 或者 ctrl+l 也可以清屏# ctrl+u 清除当前光标位置前面的输入apt installapt remove # 注意：慎用 apt-get autoremoveexport [-fnp][变量名称]=[变量设置值] # export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。env # 查看当前shell的所有环境变量whereis &lt;pkg_name&gt;which &lt;pkg_name&gt; grep 相关12345grep -i 'hello world' menu.h main.c # 查找，忽略大小写grep '^leo' /etc/passwd # 搜索/etc/passwd文件中开头是 leo 的行grep 'bash$' /etc/passwd # 搜索 /etc/passwd 文件中行尾是 bash 的行grep -E '^root|bash$' passwd # 多条件查找 123456789-w 全字匹配-v 反向搜索-l 只列出含有关键词的文件名-L 只列出不含有关键词的文件名-n 显示行数-c 统计多少行-A 列出后面的邻行-B 列出前面的邻行-C 列出前后的邻行 Shawdowsocks 相关123sslocal -c /home/burgess/shadowsocks.conf -d start # 开启梯子sslocal -c /home/burgess/shadowsocks.conf -d stop # 关闭梯子sslocal -s server.com -p 8388 -k password # 添加或修改参数 注意中间替换成配置文件的路径（burgess是用户名） Vim相关 vim是vi的升级版 命令行输入 vimtutor 就可以看到教程 基本操作 vim的三种模式 命令模式 其他模式下按Esc键可进入命令模式 输入模式 命令模式下按i或a或o可进入 “i”命令可以在当前光标之前插入文本。“a”命令可以在当前光标之后插入文本。（实测也是光标之前）“o”命令可以在当前行的下面另起一行，并使当前模式转为Insert模式。“O”命令(注意是大写的字母O)将在当前行的上面另起一行。 输入模式下，按Insert键可以选择插入模式（INSERT）还是替换模式（REPLACE） 底线命令模式 命令模式下输入:可进入，按回车结束运行 命令模式命令选择与跳转 命令 作用 gg 跳到文首 V 选择（Visual Line模式） G 跳到文尾（Ground） ggVG 全选 Visual Line下选择文本后，可执行以下命令： 命令 作用 d 删除 y 复制到&quot;剪切板 p 粘贴&quot;剪切板中的内容 “+y 复制到系统剪贴板(也就是vim的+寄存器） “+p 从系统剪贴板粘贴 删除 命令 作用 x 删除一个字符 dd 删除光标当前行 撤销与重做 命令 作用 u 撤销上一步操作 U 一次撤消对最后一次编辑的一行的全部操作。第二次使用该命令则会撤消前一个”U”的操作。 ctrl+r 重做（撤销撤销操作） 底线命令模式命令常用12345:wq! # 强制保存并退出:/keyword # 从上往下查找，按“n”跳到下一个，“*”和“.”可以模糊匹配:?keyword # 从下往上查找，按“n”跳到下一个:set nu # 显示行数（nu=number）:23 # 跳到第23行 编码与格式1234:set ff # 查看文件格式（fileformat）:set ff=unix # 设置文件格式为unix。解决文件无法执行问题。:set fileencoding # 查看文件编码:set fileencoding=utf-8 # 设置文件编码为utf-8。解决文件乱码问题。 输入模式命令暂无。 网络命令123456789101112writewallpingifconfigmaillast # 查看用户登录信息lastlogtraceroutenetstat # 显示网络相关信息netstat -rn # 查看路由列表，可以看到网关service network restart # 重启网络mount # 挂载（一般挂载在/mnt的某个子目录下） 相关文件12345678/etc/resolv.conf # 临时修改DNS/etc/systemd/resolved.conf # 一般是一个指向上面的软连接。永久修改DNS/etc/hosts # hosts 列表/etc/netplan/*.yaml # ubuntu用netplan配置网络# netplan try # 应用前先验证# netplan apply # 应用配置 测试123ping &lt;$IP|$DOMAIN&gt; # 注意ping使用的协议是ICMP，不是TCP或UDPftp &lt;$IP|$DOMAIN&gt;wget &lt;$IP|$DOMAIN&gt; 重启1234service network-manager restart # Ubuntuservice networking restart # Debiansystemctl restart systemd-resolved.servicesystemctl restart NetworkManager.service 查看状态12systemd-resolve --status # 会报错systemctl status systemd-resolved.service 其他1ps -ef | grep process_name # 列出系统中当前运行的名字包含process_name的进程 1uname -a # 查看linux内核版本 1chmod -R 777 file_foder_name # 修改文件或文件夹的权限 1man command_name # 查看命令的帮助文件 1echo $PATH # 查看环境变量 跨服务器传文件12scp -r E:\\file_foder_name debian@192.168.137.2:/home/AA/BB # 跨服务器加密复制文件夹scp E:\\AA\\BB\\filename debian@192.168.137.2:/home/AA/BB # 跨服务器加密复制文件 ln命令12ln filename filename_lnk # 建立硬链接（Hard Link）ln -s filename filename_lnk # 建立软连接（Symbolic Link，符号链接） 软硬链接的区别：https://blog.csdn.net/yagamil/article/details/40076509 find命令1find &lt;路径&gt; -name &quot;filename*&quot; 看手册 tar命令tar.gz压缩： 1tar -zcvf 压缩文件名.tar.gz 被压缩文件名 解压缩： 1tar -zxvf 压缩文件名.tar.gz -C 解压路径（不含文件名） 各参数含义： -z：有gzip属性的 -x：解压 -v：显示所有过程 -f：使用档案名字（放最后） 参考：https://www.cnblogs.com/manong--/p/8012324.html tar解压： 1tar -xvf file.tar 常用软件包及命令1tree # 显示目录树 一次性配置命令1sudo cp .bashrc /root/.bashrc # 在普通用户模式下使用。会使root模式下也有配色。 1sudo passwd # 修改root密码，要先输入当前用户登录密码 Linux 相关问题git clone 下载的文件夹无法移动git clone之前忘记cd到合适的位置了，于是clone完之后想通过mv命令将文件夹移到它的上一级目录，但提示Permission denied，于是root模式下加了777权限，也不行，不知道为什么，最后删了重新下载。 更换软件源12sudo cp /etc/apt/sources.list /etc/apt/sources.list.backupvim /etc/apt/sources.list 然后将原有内容注释掉或删掉，再粘贴新的源即可。 手机 USB 共享网络手机网络设置通过USB共享网络。 12ifconfig # 或 ip a 查看手机usb网卡名称，假设为usb0sudo dhclient usb0 git clone 速度太慢方法有以下几种： 若是 https，则在 github.com 后面加 .cnpmjs.org。 把 https 换成 git 永久配置 DNS永久停止Ubuntu默认dns本地服务 12sudo systemctl disable --now systemd-resolvedvim /etc/NetworkManager/NetworkManager.conf 修改NetworkManager：在[main]节点下增加如下配置： 1dns=none # none 不会生成dns配置到/etc/resolve.conf，default 则会生成 设置default，否则每次重启会被系统自动重置/etc/resolve.conf为nameserver 127.0.0.53 重启NetworkManager： 1sudo systemctl restart NetworkManager 如果不行，删除 /etc/resolv.conf 文件（红色，符号链接到的源文件不存在），然后再重启网络，resolv.conf 文件会自动生成","link":"/2021/02/27/2346.html"},{"title":"Linux 网络编程","text":"B/S和C/S模型 B/S：浏览器/服务器模型 C/S：客户端/服务器模型 OSI七层模型 应用层：用户定义。FTP协议 传输层：端口号（区分不同应用）。TCP协议 网络层：IP，存放源IP（数据是谁发的）和目的IP（最终发送给谁）。IP协议 网络接口层（链路层）：通过ARP数据报寻路（同时会读取网络层的目的IP）。以太网协议 NAT映射表：用于局域网IP与公网IP的转换。 解决IP冲突：由于源IP可能是某局域网中的一个IP，可能会与目的IP（也在某一局域网中）重复，因此连接局域网的路由器有一个NAT映射表，将局域网中的每一个IP映射成路由器的“IP+不同端口”。 解决IP数不足：局域网只需要少量的ip地址（甚至一个）就可以满足专用地址网中所有计算机与internet的通信需求。 Socket（套接字）编程定义 IP：在网络环境中唯一地标识一台主机 Port（端口号）：在主机中唯一地标识一个进程 Socket=IP+Port：在网络环境中唯一地标识一个进程 成对出现 原理 管道通信：半双工通信 套接字通信：全双工通信（一个文件描述符指向两个缓冲区：一个读一个写） 预备知识 大端存储：低位存于高位，高位存于低位（网络字节序） 小端存储：低位存于低位，高位存于高位（主机字节序） 函数： htons/ntohs：host to net, short。本地字节序（小端存储）转网络字节序（大端存储） htonl/ntohl：net to host, long。网络字节序（大端存储）转本地字节序（小端存储） inet_pton：点分十进制字符串转网络字节序 inet_ntop：网络字节序转点分十进制字符串 sockaddr数据结构 使用$man 7 ip指令查看 struct sockaddr：早期使用 struct sockaddr_in：后来使用 16位地址类型（sa_family_t sin_family) AF_INET（IPV4） AF_INET6（IPV6） AF_UNIX（本地协议） 16为位端口号(in_port_t sin_port) 32位IP地址(struct in_addr sin_addr) 8字节填充 函数 头文件 #include &lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; int socket(int domain, int type, int protocol); 123456789101112131415 * domain * AF_INET（IPV4） * AF_INET6（IPV6） * AF_UNIX（本地协议） * type * SOCK_STREAM：流式协议，默认使用TCP * SOCK_DGRAM：默认使用UDP * protocol：传0表示使用默认协议 * return * 成功：返回指向新创建的socket的文件描述符 * 失败：返回-1，设置errno * ```c int bind(int sockfd, const struct sockaddr *addr, socketlen_t addrlen); * 作用：绑定IP和Port，如果没有调用，系统自动分配IP和Port，故服务器需要调用，而客户端不需要调用 * sockfd：socket文件描述符 * addr：构造出的IP地址+端口号 * addrlen：sizeof(addr) * return - 成功：返回0 - 失败：返回-1，设置errno int listen(int sockfd, int backlog); 12345678910 * 作用：设置最多同时可以有多少个客户端与之建立连接（不是保持连接。建立连接需要一定时间） * sockfd：socket文件描述符 * backlog：指定最多同时可以有多少个客户端与之建立连接 * return * 成功：返回0 * 失败：返回-1 * ```c int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); * 作用：阻塞，直到有客户端连接 * sockfd：服务器的socket文件描述符 * addr：**传出参数**，返回链接客户端地址信息（IP+Port） * addrlen：**传入传出参数**，传入sizeof(addr)，传出客户端的addr长度 * return * 成功：返回一个**新的**socket文件描述符，用于和客户端通信 * 失败：返回-1，设置errno int connect(int sockfd, struct sockaddr *addr, socklen_t addrlen); 12345678 * sockfd：socket文件描述符 * addr：传入参数，指定服务器地址信息（IP+Port） * addrlen：传入传出参数，传入sizeof(addr) * return：成功返回0，失败返回-1，设置errno * ```c read * return： * 大于0：实际读到的字节数 * 等于0：数据读完 * -1：异常 * errno == EINTR：被信号中断 * errno == EAGAIN（EWOULDBLOCK）：以非阻塞方式读，并且没有数据 * errno == 其他：出现错误 ssize_t Readn(int fd, void *vptr, size_t n); // 非标准库函数，自己写 { size_t nleft; // 剩余的未读取的字节数 ssize_t nread; // 实际读到的字节数 char *ptr; ptr = vptr; nleft = n; // 一开始一共n个字节未读 while(nleft &gt; 0) { nread = read(fd, ptr, nleft); if(nread &lt; 0) { if(errno == EINTR) nread = 0; else return -1; } else if(nread == 0) // 读完了 { break; } else { nleft -= nread; ptr += nread; } } return n - nleft; // 返回读取到的字节数，一般为n } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 ## 流程![img](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1576816388100&amp;di=ff7c777d013db380942e96d988f3bc34&amp;imgtype=0&amp;src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fjasonwang%2F201104%2F201104180939247446.png)* server.c 1. socket()：建立套接字，得到文件描述符 2. struct sockaddr_in addr初始化 2. bind()：传入构造的addr，将sockfd与IP+Port绑定 3. listen()：设置最大同时发起连接的数量 4. accept()：阻塞等待客户端发起连接 5. read()：读取客户端数据 6. 数据处理 7. write()：给客户端写数据 8. close()* client.c 1. socket() 2. bind()：可以不调用，系统则自动绑定随机IP和端口号 3. connect()：发起连接 4. write()：向服务器写数据 5. read()：读取服务器发来的数据 6. close()## 服务器程序* server.c```c/* *发送一个小写字母，返回一个大写字母 */#include &lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/socket.h&gt;#include&lt;stdlib.h&gt;#include&lt;arpa/inet.h&gt; //sockaddr_in的头文件#include&lt;ctype.h&gt; //toupper的头文件#include&lt;strings.h&gt; //bzero的头文件#define SERV_IP &quot;127.0.0.1&quot; //Linux预定义的本机IP，存放在etc/hosts文件中#define SERV_PORT 6666 //端口号，可随便定义，但注意1000以下给系统使用，最大65535int main(void){ int lfd, cfd; struct sockaddr_in serv_addr, clie_addr; socklen_t clie_addr_len = sizeof(clie_addr); char buf[BUFSIZ], clie_IP[BUFSIZ]; //BUFSIZ是一个宏 int n, i; //n为接收到的字符数 int ret; bzero(&amp;serv_addr, sizeof(serv_addr)); // 将serv_addr结构体内存空间清零 lfd = socket(AF_INET, SOCK_STREAM, 0); // 创建套接字，用来建立连接的 if(lfd == -1) { perror(&quot;socket error&quot;); exit(1); } serv_addr.sin_family = AF_INET; //IPV4 serv_addr.sin_port = htons(SERV_PORT);//本地字节序转化为网络字节序 serv_addr.sin_addr.s_addr = htonl(INADDR_ANY)；//INADDR_ANY是一个宏会自动获取当前网卡对应的有效IP，或用inet_pton(SERV_IP)，即字符串转网络字节序 ret = bind(lfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); // 将IP和Port绑定起来 if(ret == -1) { perror(&quot;bind error&quot;); exit(1); } ret = listen(lfd, 128); //默认128 if(ret == -1) { perror(&quot;listen error&quot;); exit(1); } cfd = accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len); if(cfd == -1) { perror(&quot;accept error&quot;); exit(1); } printf(&quot;client IP:%s, client port:%d\\n&quot;, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP)), ntohs(clie_addr.sin_port)); //打印连接客户端的IP地址和端口号 while(1) { n = read(cfd, buf, sizeof(buf)); //小写转大写int toupper(int c); //大写转小写int tolower(int c); for(i = 0; i &lt; n; i++) { buf[i] = toupper(buf[i]); } write(cfd, buf, n); } close(lfd); close(cfd); return 0;} 单独进行服务器测试 123$ gcc server.c -0 server //编译$ ./server //运行服务器程序$ nc 127.0.0.1 6666 //连接到本机 查看端口号是否被占用 12$ sudo su //获取root权限$ netstat -apn | grep 6666 查看IP信息 1$ ip -a 注意：要先ctrl+c关闭客户端，再关闭服务器。若先关闭服务器，则服务器套接字不会马上清除，而会进入TIME_WAIT状态，这时若再重启服务器，server程序执行到bind函数处会报错（Address already in use），即地址已被使用。此时是无法强制回收该套接字的，需要等待一段时间，直到套接字被自动回收。 客户端程序 client.c 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;sys/socket.h&gt;#include&lt;arpa/inet.h&gt;#define SERV_IP &quot;127.0.0.1&quot;#define SERV_PORT 6666 //注意与服务器程序对应int main(void){ int cfd; struct sockaddr_in serv_addr; //服务器的IP+Port socklen_t serv_addr_len = sizeof(serv_addr); char buf[BUFSIZ]; int n; cfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 memset(&amp;serv_addr, 0, sizeof(serv_addr)); //将serv_addr结构体内存空间初始化为0 serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(SERV_PORT); inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr); connect(cfd, (struct sockaddr *)&amp;serv_addr, serv_addr_len); while(1) { fgets(buf, sizeof(buf), stdin); //读一行，以\\n作为结束标志，加上\\0 write(cfd, buf, strlen(buf)); //写到套接字中写缓冲区 n = read(cfd, buf, sizeof(buf));//读取套接字的读缓冲区 write(STDOUT_FILENO, buf, n); //写到屏幕 } close(cfd); return 0;} 错误处理 wrap.c 例：将socket函数封装成Socket函数 123456789int Socket(int family, int type, int protocol){ int n; if((n = socket(family, type, protocol)) &lt; 0) { perr_exit(&quot;socket error&quot;); } return n;} 只将首字母大写，方便在vi中用K命令直接查看帮助文档，否则用下面的命令 1$ :!man 2 socket TCP协议TCP通信时序（建立连接的三次握手和关闭连接的四次握手） 由于网络层与硬件联系紧密，因此不太稳定。因此传输层有如下解决方式： UDP：完全不弥补，无连接不可靠报文传输 TCP：完全弥补，面向连接的可靠数据包传递 TCP通信时序图如下","link":"/2019/12/19/0946.html"},{"title":"systemd 网络配置命令","text":"参考：https://blog.csdn.net/boyemachao/article/details/87366505 sytemd-network.service 的配置文件可以位于 /usr/lib/systemd/network/ 或者 /etc/systemd/network/ 目录下，后者具有最高优先级。配置文件有三种类型： .network 文件，设置网卡的 IP 等各项属性 .netdev 文件，新建一个虚拟网卡 .link 文件，每当一个网卡出现时，udev 都会查找与它同名的 .link 文件 这几类文件都遵循下面的规则： 各选项的值都支持星号 * 通配符 当 [Match] 段内的条件都匹配时，后面的配置项才会被激活 如果 [Match] 段为空，表示后面的配置项在任何情况下都可用 无论配置文件在哪个目录，都会统一按照字典顺序进行加载 同名文件可以相互替换 如果要给 enp0s20f6 配置一个静态 IP ，可以在 /etc/systemd/network/ 目录下新建一个 eth0.network 文件，内容如下： 1234567[Match]Name=enp0s20f6 # 匹配名为 enp0s20f6 的网卡[Network]DHCP=none # 关闭 DHCP 客户端Address=192.168.5.242/24 # 设置 IP 和子网掩码（24位）Gateway=192.168.5.50 # 设置网关，这项设置会将该网卡添加到缺省路由DNS=8.8.8.8 # 设置 DNS 如果要使用 DHCP 自动获取 IP ，也将 DHCP 设为如下值： v4 ，只接受 ipv4 的 IP v6 ，只接受 ipv6 的 IP both ，同时接受 ipv4 和 ipv6 格式的 IP 启动 DHCP 客户端后，Gateway 和 DNS 也会自动获取，有时我们不希望这样，可以在配置文件中添加一个 [DHCP] 段，做如下设置： 123[DHCP]UseDNS=false # 不使用 DHCP 分配的 DNS ，默认值是 trueUseRoutes=false # 不会将本网卡设为缺省路由，默认值是 true 在这里会出现一个 Bug ，就是 UseRoutes 设置无效，高版本中已经解决，解决方案在 https://github.com/systemd/systemd/pull/3075 。 配置完之后重启网络： 1systemctl restart systemd-networkd","link":"/2021/01/28/1739.html"},{"title":"iperf 帮助文档","text":"Usage: iperf [-s|-c host] [options] iperf [-h|–help] [-v|–version] Client/Server: -b, –bandwidth #[KMG | pps] bandwidth to send at in bits/sec or packets per second -e, –enhancedreports use enhanced reporting giving more tcp/udp and traffic information -f, –format [kmKM] format to report: Kbits, Mbits, KBytes, MBytes -i, –interval # seconds between periodic bandwidth reports -l, –len #[KM] length of buffer to read or write (default 8 KB) -m, –print_mss print TCP maximum segment size (MTU - TCP/IP header) -o, –output output the report or error message to this specified file -p, –port # server port to listen on/connect to -u, –udp use UDP rather than TCP -w, –window #[KM] TCP window size (socket buffer size) -z, –realtime request realtime scheduler -B, –bind bind to , an interface or multicast address -C, –compatibility for use with older versions does not sent extra msgs -M, –mss # set TCP maximum segment size (MTU - 40 bytes) -N, –nodelay set TCP no delay, disabling Nagle’s Algorithm -V, –ipv6_domain Set the domain to IPv6 Server specific: -s, –server run in server mode -U, –single_udp run in single threaded UDP mode -D, –daemon run the server as a daemon Client specific: -c, –client run in client mode, connecting to -d, –dualtest Do a bidirectional test simultaneously -n, –num #[KM] number of bytes to transmit (instead of -t) -r, –tradeoff Do a bidirectional test individually -t, –time # time in seconds to transmit for (default 10 secs) -B, –bind [ | ip:port] bind src addr(s) from which to originate traffic -F, –fileinput input the data to be transmitted from a file -I, –stdin input the data to be transmitted from stdin -L, –listenport # port to receive bidirectional tests back on -P, –parallel # number of parallel client threads to run -T, –ttl # time-to-live, for multicast (default 1) -Z, –linux-congestion set TCP congestion control algorithm (Linux only) Miscellaneous: -x, –reportexclude [CDMSV] exclude C(connection) D(data) M(multicast) S(settings) V(server) reports -y, –reportstyle C report as a Comma-Separated Values -h, –help print this message and quit -v, –version print version information and quit [KM] Indicates options that support a K or M suffix for kilo- or mega- The TCP window size option can be set by the environment variableTCP_WINDOW_SIZE. Most other options can be set by an environment variableIPERF_, such as IPERF_BANDWIDTH. Source at http://sourceforge.net/projects/iperf2/Report bugs to iperf-users@lists.sourceforge.net","link":"/2021/01/29/1521.html"},{"title":"Git Book 学习","text":"起步关于版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 我们对保存着软件源代码的文件作版本控制，但实际上，你可以对任何类型的文件进行版本控制。 本地版本控制系统许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。 其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中化的版本控制系统接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。 分布式版本控制系统于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 Git 简史Git 是什么三种状态现在请注意，如果你希望后面的学习更顺利，请记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全地保存在本地数据库中。 这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 .git 目录（即 Git 仓库）。 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。 基本的 Git 工作流程如下： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 命令行安装 Git初次运行 GIt 前的配置Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 --system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。） ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 --global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。 当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 --local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。） 每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 在 Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\\Users\\$USER ）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 如果你在 Windows 上使用 Git 2.x 以后的版本，那么还有一个系统级的配置文件，Windows XP 上在 C:\\Documents and Settings\\All Users\\Application Data\\Git\\config ，Windows Vista 及更新的版本在 C:\\ProgramData\\Git\\config 。此文件只能以管理员权限通过 git config -f &lt;file&gt; 来修改。 你可以通过以下命令查看所有的配置以及它们所在的文件： 1$ git config --list --show-origin 用户信息安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： 12$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com 再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。 检查配置信息1$ git config --list # 检查 Git 的所有配置 1git config &lt;key&gt; # 检查 Git 的某一项配置 由于 Git 会从多个文件中读取同一配置变量的不同值，因此你可能会在其中看到意料之外的值而不知道为什么。 此时，你可以查询 Git 中该变量的 原始 值，它会告诉你哪一个配置文件最后设置了该值： 12$ git config --show-origin rerere.autoUpdatefile:/home/johndoe/.gitconfig false 文本编辑器如果你想使用不同的文本编辑器，例如 Emacs，可以这样做： 1$ git config --global core.editor emacs 在 Windows 系统上，如果你想要使用别的文本编辑器，那么必须指定可执行文件的完整路径。 它可能随你的编辑器的打包方式而不同。 获取帮助若你使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）： 123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 例如，要想获得 git config 命令的手册，执行 1$ git help config 此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 -h 选项获得更简明的 “help” 输出： 1$ git &lt;verb&gt; -h Git 基础 获取 Git 仓库通常有两种获取 Git 项目仓库的方式： 将尚未进行版本控制的本地目录转换为 Git 仓库； 从其它服务器 克隆 一个已存在的 Git 仓库。 在已存在目录中初始化仓库1$ git init 123$ git add *.c$ git add LICENSE$ git commit -m 'initial project version' 克隆现有的仓库12$ git clone https://github.com/libgit2/libgit2$ git clone https://github.com/libgit2/libgit2 mylibgit # 克隆并重命名 记录每次更新到仓库Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。 请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。 工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。 用 git add 可以追踪新建文件，用 git rm 命令可以取消追踪文件。 追踪机制的好处是让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 检查当前文件状态123$ git status$ git status -s$ git status --short 123456$ git status -s M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。 例如，上面的状态报告显示： README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile 文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。 跟踪新文件1$ git add &lt;files | directory&gt; git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 git add 是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来。 忽略文件一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 1234567891011121314151617# 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf 查看已暂存和未暂存的修改可以用 git diff 命令来回答两个问题： 当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 虽然 git status 已经通过在相应栏下列出文件名的方式回答了这个问题，但 git diff 能通过文件补丁的格式更加具体地显示哪些行发生了改变。 命令 git diff 比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容： 1$ git diff 命令 git diff --staged 将比对已暂存文件与最后一次提交的文件差异： 12$ git diff --staged$ git diff --cached # --staged 和 --cached 是同义词 请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 git diff 后却什么也没有，就是这个原因。 提交更新123$ git commit$ git commit -v # 显示详细的内容修改提示$ git commit -m &quot;Commit message.&quot; 这样会启动你选择的文本编辑器来输入提交说明。 启动的编辑器是通过 Shell 的环境变量 EDITOR 指定的，一般为 vim 或 emacs。 当然也可以使用 git config --global core.editor 命令设置你喜欢的编辑器。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项（all，即commit包括工作区和暂存区），Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： -a 选项使提交包含所有修改过的文件。 这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。 移除文件如果文件处于未修改和暂存区无记录的状态，则可以删除文件： 1$ git rm &lt;files&gt; 这个命令会将文件从工作目录中删除，并将更改记录（“删除”这个操作记录，即取消跟踪）添加到暂存区。 也可以手动删除（rm &lt;files&gt;），然后再 git rm 或 git add 添加删除的记录到暂存区。 1$ git rm --cached README # 仅删除暂存区的记录，且取消追踪文件，但文件在文件目录中还在 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f（译注：即 force 的首字母）。 移动文件1git mv &lt;file&gt; &lt;file | directory&gt; 查看提交历史1git log --pretty=oneline 撤销操作在 Git 中任何 已提交 的东西几乎总是可以恢复的。 修改提交信息1$ git commit --amend # 提交暂存区，同时可以修改上一次提交的信息 取消暂存的文件1$ git reset HEAD &lt;file&gt; 撤消对文件的修改撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）: 1$ git checkout -- &lt;file&gt; 请务必记得 git checkout -- &lt;file&gt; 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。 远程仓库的使用查看远程仓库12$ git remote # 列出你指定的每一个远程服务器的简写$ git remote -v # 会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL origin ——这是 Git 给你克隆的仓库服务器的默认名字。 添加远程仓库1$ git remote add &lt;shortname&gt; &lt;url&gt; # 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写 从远程仓库中抓取（fetch）与拉取（pull）1$ git fetch &lt;remote&gt; # 会抓取克隆（或上一次抓取）后新推送的所有工作 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你的当前分支设置了跟踪远程分支（阅读下一节和 Git 分支 了解更多信息）， 那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库1$ git push &lt;remote&gt; &lt;branch&gt; 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取（fetch）他们的工作并将其合并进你的工作后才能推送。 查看某个远程仓库1$ git remote show &lt;remote&gt; 远程仓库的重命名与移除1$ git remote rename &lt;remote&gt; &lt;remote-new-name&gt; # 重命名 值得注意的是这同样也会修改所有远程跟踪 &lt;remote&gt; 仓库的分支的名字。 那些过去引用 &lt;remote&gt;/master 的现在会引用 &lt;remote-new-name&gt;/master。 12$ git remote rm &lt;remote&gt;$ git remote remove &lt;remote&gt; # 移除 一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。 打标签标签分类 轻量（lightweight）标签：可以有多个，一般填写版本号，如“v1.0”。 附注（annotated）标签：可以有多个，一般填写属性式标签，如修改日期、作者等。 123456789101112131415161718192021222324# 显示标签git tag # 显示所有标签git tag -l &quot;v1.8.*&quot; # 按特定模式查找标签git show &lt;tagname&gt; # 显示指定标签# 添加标签git log --pretty=oneline # 显示提交历史git tag v2.0 # 给当前版本打标签？git tag -a v1.4 4fdagga # 给4fdagga添加轻量标签git tag -a v1.4 -m &quot;Author:Burgess&quot; # 给v1.4添加附注标签# 推送标签（注意：直接git push不会推送标签）git push &lt;remote&gt; v1.4 # 将v1.4的标签推送到远程（比如origin）git push &lt;remote&gt; --tags # 推送所有不在远程仓库的标签# 删除本地标签git tag -d &lt;tagname&gt;# 删除远程标签git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; # 方法一。注意`:`前面有个空格git push &lt;remote&gt; --delete &lt;tagname&gt; # 方法二# checkout标签（用于修改旧版本的错误等）git checkout v2.0 # 最好不要这么用，会使你的仓库处于“分离头指针（detached HEAD）”的状态git checkout -b &lt;new-branch&gt; v2.0 # 将v2.0拉到新分支 特点： 本地标签和远程标签是分开管理的，直接 git push 不会推送标签。 Git 别名例如： 1234$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status 再例如： 1$ git config --global alias.unstage 'reset HEAD --' 这会使下面的两个命令等价： 12$ git unstage fileA # 取消暂存$ git reset HEAD -- fileA 总结Git 分支分支简介","link":"/2021/02/06/2333.html"},{"title":"Shell 脚本命令学习","text":"参考：菜鸟教程 Shell 简介Shell 类型 Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） Korn Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） Linux操作系统缺省的shell是Bourne Again shell，它是Bourne shell的扩展，简称Bash，与Bourne shell完全向后兼容，并且在Bourne shell的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多C shell和Korn shell中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。 查看当前的shell： 1echo $SHELL 第一个 shell 脚本用vim打开新建文档test.sh： 1vim test.sh 输入以下内容： 12#! /bin/bash # “#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。sh和bash都可以。echo &quot;Hello World!&quot; # 向窗口输出文本 进入命令模式，:wq保存退出后，执行（以sh解释器为例，bash解释器同理） 1sh ./test.sh 或 1sh test.sh 或直接指定解释器运行 1/bin/sh test.sh 用这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。 sh 和 bash 命令的区别 引用链接：Linux中的Shell bash和sh区别 sh跟bash的区别是：sh开启了POSIX模式，而bash没有。sh 遵循POSIX规范：“当某行代码出错时，不继续往下解释”。bash 就算出错，也会继续向下执行。 POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）。POSIX标准意在期望获得源代码级别的软件可移植性。换句话说，为一个POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统上编译执行。 简单说，sh是bash的一种特殊的模式，sh就是开启了POSIX标准的bash，/bin/sh相当于/bin/bash --posix。 在Linux系统上/bin/sh往往是指向/bin/bash的符号链接，即 1ln -s /bin/bash /bin/sh Shell 注释单行注释以#开头的行就是注释，会被解释器忽略。 多行注释12345:&lt;&lt;Symbol注释内容...注释内容...注释内容...Symbol 其中Symbol可以替换成任意字符或字符串。 Shell 命令help 命令1help [-dms] [pattern ...] 选项 作用 -d output short description for each topic -m display usage in pseudo-manpage format -s output only a short usage synopsis for each topic matching PATTERN Shell 命令一览 引用链接：详解shell中source、sh、bash、./执行脚本的区别 Shell命令 作用 : 空，永远返回为true . 从当前shell中执行操作 break 退出for、while、until或case语句 cd 改变到当前目录 continue 执行循环的下一步 echo 反馈信息到标准输出 eval 读取参数，执行结果命令 exec 执行命令，但不在当前shell exit 退出当前shell export 导出变量，使当前shell可利用它（导出成全局变量） pwd 显示当前目录 read 从标准输入读取一行文本 readonly 使变量只读 return 退出函数并带有返回值 set 控制各种参数到标准输出的显示 shift 命令行参数向左偏移一个 test 评估条件表达式 times 显示shell运行过程的用户和系统时间 trap 当捕获信号时运行指定命令 ulimit 显示或设置shell资源 umask 显示或设置缺省文件创建模式 unset 从shell内存中删除变量或函数 wait 等待直到子进程运行完毕 echo 命令选项 可选项 作用 -n 不加换行符 -e 使能对反斜杠转义符的解释 -E 禁止对反斜杠转义符的解释 字符转义执行命令 1help echo 即可看到所有能转义的字符 能转义的字符 转义后的作用 \\a alert (bell) \\b suppress further output \\e escape character \\E escape character \\f form feed \\n new line \\r carriage return \\t horizontal tab \\v vertical tab \\\\ backslash \\0nnn the character whose ASCII code is NNN (octal). NNN can be 0 to 3 octal digits. \\xHH the eight-bit character whose value is HH (hexadecimal). HH can be one or two hex digits. \\uHHHH the Unicode character whose value is the hexadecimal value HHHH. HHHH can be one to four hex digits. \\UHHHHHHHH the Unicode character whose value is the hexadecimal value HHHHHHHH. HHHHHHHH can be one to eight hex digits. 显示结果定向至文件1echo &quot;It is a test&quot; &gt; myfile 显示命令执行结果1echo `date` 输出结果（当前时间）： 1Mon 25 Jan 2021 05:22:36 PM CST printf 命令printf 命令模仿 C 程序库（library）里的 printf() 程序。 printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。 printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \\n。 printf 命令的语法： 1printf format-string [arguments...] 参数说明： format-string: 为格式控制字符串 arguments: 为参数列表 例子： 12345#!/bin/bashprintf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kg printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876 1234567891011121314151617181920#!/bin/bash# format-string为双引号printf &quot;%d %s\\n&quot; 1 &quot;abc&quot;# 单引号与双引号效果一样printf '%d %s\\n' 1 &quot;abc&quot;# 没有引号也可以输出printf %s abcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用printf %s abc defprintf &quot;%s\\n&quot; abc defprintf &quot;%s %s %s\\n&quot; a b c d e f g h i j# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替printf &quot;%s and %d \\n&quot; test 命令数值测试12345678num1=100num2=100if test $num1 -eq $num2then echo '两个数相等！'else echo '两个数不相等！'fi 字符串测试12345678num1=&quot;ru1noob&quot;num2=&quot;runoob&quot;if test $num1 = $num2then echo '两个字符串相等!'else echo '两个字符串不相等!'fi 文件测试1234567cd /binif test -e ./bashthen echo '文件已存在!'else echo '文件不存在!'fi Shell 变量变量命名规则 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 变量定义显式定义1your_name=&quot;runoob.com&quot; 注意：等号左右都不能有空格！ 隐式定义1for file in `ls /etc` 或者 1for file in $(ls /etc) 以上语句将 /etc 下目录的文件名循环出来。 变量使用123your_name=&quot;wbx&quot;echo $your_nameecho ${your_name} 变量可以重新定义 1234your_name=&quot;tom&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name 变量类型 按作用域可分为 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 按能否重新定义，可分为 可变变量 一般定义的为可变变量 只读变量 用readonly命令可将变量定义为只读变量。如下shell脚本执行会报错。 1234#!/bin/shmyUrl=&quot;https://www.google.com&quot;readonly myUrlmyUrl=&quot;https://www.baidu.com&quot; 变量删除1unset variable_name 注意：unset 命令不能删除只读变量。 Shell 数据类型字符串字符串定义可以用单引号，也可以用双引号，也可以不用引号。 字符串变量定义单引号法最简单的例子： 1str='this is a string' 下面在例子中观察单引号的用法： 123456789101112#!/bin/shstr='string'str1='This is a $str.'str2='This is a '$str'.'# str3='This is a \\'$str\\'.' # 这句会报错str4='This is a &quot;$str&quot;.'str5='This is a \\&quot;$str\\&quot;.'echo &quot;1: $str1&quot;echo &quot;2: $str2&quot;# echo &quot;3: $str3&quot;echo &quot;4: $str4&quot;echo &quot;5: $str5&quot; 输出 12341: This is a $str.2: This is a string.4: This is a &quot;$str&quot;.5: This is a \\&quot;$str\\&quot;. 下面会报错 1234#!/bin/shstr='string'str3='This is a \\'$str\\''echo $str3 单引号的一些特点： 单引号中要输出变量的话，不能直接放变量（$name），要用单引号括起来，否则会被当成字符输出 单引号中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。即单引号中不能输出单引号！ 单引号中的双引号就是一个普通的字符，不需要转义直接输出 双引号法123456789101112#!/bin/shstr='string'str1=&quot;This is a $str.&quot;str2=&quot;This is a &quot;$str&quot;.&quot;str3=&quot;This is a \\&quot;$str\\&quot;.&quot;str4=&quot;This is a '$str'.&quot;str5=&quot;This is a \\'$str\\'.&quot;echo &quot;1: $str1&quot;echo &quot;2: $str2&quot;echo &quot;3: $str3&quot;echo &quot;4: $str4&quot;echo &quot;5: $str5&quot; 输出 123451: This is a string.2: This is a string.3: This is a &quot;string&quot;.4: This is a 'string'.5: This is a \\'string\\''. 双引号的一些特点 双引号里面可以放变量，变量可加双引号，也可不加双引号，效果都一样 双引号中输出双引号需要用转义符 双引号中的单引号只是个普通的字符，不需要转义直接输出 总结 字符串定义时，不管是单引号还是双引号，在有变量时，可一律加引号（单引号里面就加单引号，双引号里面就加双引号） 单引号里面不能输出单独的一个单引号，双引号里面输出双引号时要用转义符 单引号里面的双引号以及双引号里面的单引号都视为普通字符 平时用双引号即可，功能比单引号多 字符串拼接见字符串变量定义一节。 字符串长度获取12string=&quot;abcd&quot;echo ${#string} # 输出为4 子字符串获取创建文件test.sh： 123#! /bin/bashstring=&quot;abcdefg&quot;echo ${string:1:4} # 输出bcde 注意：解释器的选择要正确，否则会出现Bad substitution的错误。 这里用发现bash test.sh或/bin/bash test.sh能成功运行，sh test.sh或/bin/sh test.sh都会报错。另外，bash --posix test.sh 或/bin/bash --posix test.sh却能成功运行。 因此我推测：直接用命令和指定解释器路径来执行脚本是等价的，但sh与bash --posix不等价。 查找字符串12string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 注意： 以上脚本中 ` 是反引号，而不是单引号 **’**，不要看错了哦。 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。 数组变量定义在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。例： 1array_name=(value0 value1 value2 value3) 或单独定义数组的各个分量： 123array_name[0]=value0array_name[1]=value1array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。 数组读取1valuen=${array_name[n]} 使用 @ 符号可以获取数组中的所有元素，例如： 1echo ${array_name[@]} 数组长度获取获取数组长度的方法与获取字符串长度的方法相同，例如： 1234# 取得数组元素的个数length=${#array_name[@]}# 或者length=${#array_name[*]} 12# 取得数组单个元素的长度lengthn=${#array_name[n]} Shell 参数传递我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。 n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……0默认为执行的脚本文件名（包含文件路径）。 例：新建文件test.sh： 12345#!/bin/bashecho &quot;执行的文件名：$0&quot;echo &quot;第一个参数为：$1&quot;echo &quot;第二个参数为：$2&quot;echo &quot;第三个参数为：$3&quot; 1sh test.sh abc 123 5f5 输出： 1234执行的文件名：test.sh第一个参数为：abc第二个参数为：123第三个参数为：5f5 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本的参数个数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $* 以一个单字符串的形式显示所有向脚本传递的参数。 如果是$*用&quot;括起来的情况，则会以$1 $2 … $n的形式输出所有参数。 $@ 以一个字符串组的形式显示所有向脚本传递的参数。不加引号则与$*相同。 如果是$@用&quot;括起来的情况、则会以$1 $2 … $n的形式输出所有参数。用for循环可以看出二者的区别。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 演示$*与$@的区别： 12345678910#!/bin/bashecho &quot;-- \\$* 演示 ---&quot;for i in &quot;$*&quot;; do echo $idoneecho &quot;-- \\$@ 演示 ---&quot;for i in &quot;$@&quot;; do echo $idone 1sh test.sh 1 2 3 输出结果： 123456-- $* 演示 ---1 2 3-- $@ 演示 ---123 Shell 运算符算数运算符例： 123#!/bin/bashval=`expr 2 + 2`echo &quot;两数之和为：$val&quot; 注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算数运算符 说明 举例 + 加法 expr $a + $b - 减法 expr $a - $b \\* 乘法 expr $a \\* $b / 除法 expr $b / $a % 取余 expr $b % $a = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 注意： 条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 乘号*前边必须加反斜杠\\才能实现乘法运算。 关系运算符 运算符 助记 说明 举例 -eq equal 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] -ne unequal 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] -gt greater 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] -lt less 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] -ge greater equal 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] -le less equal 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 布尔运算符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 逻辑运算符 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false || 逻辑的 OR `[[ $a -lt 100 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] -n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n &quot;$a&quot; ] $ 检测字符串是否为空，不为空返回 true。 [ $a ] 文件测试运算符 操作符 助记 说明 举例 -b block 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] -c char 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] -d directory 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] -g SGID 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] -k Sticky 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] -p pipe 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] -u SUID 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] -r read 检测文件是否可读，如果是，则返回 true。 [ -r $file ] -w write 检测文件是否可写，如果是，则返回 true。 [ -w $file ] -x execute 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] -s (sky) 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] -e exist 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 操作符 说明 举例 -S 判断某文件是否 socket。 [ -S $file ] -L 检测文件是否存在并且是一个符号链接。 [ -L $file] Shell 流程控制条件判断if 条件判断格式： 123456789if condition1then command1 elif condition2then command2else command3 # 注意若写了else，则这里不能为空fi # fi就是if反过来写，也可以理解为finish 或写成一行： 1if condition; then command; fi 例子： 123456789101112131415a=10b=20if [ $a == $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then echo &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi 注意：这里用bash，用sh会报错。 case 条件判断语法： 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac # 就是case反过来写 例： 123456789101112131415echo '输入 1 到 4 之间的数字:'echo '你输入的数字为:'read aNumcase $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;;esac 循环for 循环1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 或写成一行： 1for var in item1 item2 ... itemN; do command1; command...; done; 例： 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done 1234for str in 'This is a string'do echo $strdone while 循环格式： 1234while conditiondo commanddone 例： 1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 无限循环有三种写法： 1234while :do commanddone 1234while truedo commanddone 1for (( ; ; )) until 循环语法： 1234until conditiondo commanddone 例： 123456789#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done break 命令例子： 12345678910111213#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone continue 命令例子： 1234567891011121314#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot; continue echo &quot;游戏结束&quot; # 该语句永远不会被执行 ;; esacdone 123456789101112#!/bin/shsite=&quot;runoob&quot;case &quot;$site&quot; in &quot;runoob&quot;) echo &quot;菜鸟教程&quot; ;; &quot;google&quot;) echo &quot;Google 搜索&quot; ;; &quot;taobao&quot;) echo &quot;淘宝网&quot; ;;esac Shell 函数语法： 1234567[ function ] funname [()] # []表示可写可不写，但这里不能二者都不写{ action; [ return int ]} 说明： 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 return语句如果不加，将以最后一条命令的运行结果，作为返回值。 return后跟数值n（0~255）。 例： 12345678#!/bin/bashdemoFun(){ echo &quot;这是我的第一个 shell 函数!&quot;}echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 12345678910111213#!/bin/bashfunWithReturn(){ echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))}funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 带参数的函数示例： 1234567891011121314#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithParam(){ echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 ${10} !&quot; echo &quot;第十一个参数为 ${11} !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;}funWithParam 1 2 3 4 5 6 7 8 9 34 73 注意：$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 Shell 输入/输出重定向大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。 如果希望 stderr 重定向到 file，可以这样写： 1$ command 2&gt;file 如果希望 stderr 追加到 file 文件末尾，可以这样写： 1$ command 2&gt;&gt;file 重定向命令列表如下： 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 例： 123# 统计 file 文件的行数wc -l file # 输出 2 filewc -l &lt; file # 输出 2 下面这个例子，执行command1，从文件infile读取内容，然后将输出写入到outfile中：（说明执行顺序是从左到右的） 1command1 &lt; infile &gt; outfile Here DocumentHere Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 它的基本的形式如下： 123command &lt;&lt; delimiter documentdelimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。delimiter可以替换成其他字符。 注意： 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。 例： 123456# 计算行数wc -l &lt;&lt; EOF 欢迎来到 菜鸟教程 www.runoob.comEOF 1234567#!/bin/bash# 打印内容cat &lt;&lt; EOF欢迎来到菜鸟教程www.runoob.comEOF /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。 如果希望屏蔽 stdout 和 stderr，可以这样写： 1command &gt; /dev/null 2&gt;&amp;1 注意： 0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。 这里的 2 和 &gt; 之间不可以有空格，2&gt; 是一体的时候才表示错误输出。 Shell 文件包含和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。 Shell 文件包含的语法格式如下： 123. filename # 注意点号(.)和文件名中间有一空格# 或source filename 例子： 创建两个 shell 脚本文件。 test1.sh 代码如下： 123#!/bin/bashurl=&quot;http://www.runoob.com&quot; test2.sh 代码如下： 123456789#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho &quot;菜鸟教程官网地址：$url&quot; 接下来，我们为 test2.sh 添加可执行权限并执行： 12chmod +x test2.sh ./test2.sh 注：被包含的文件 test1.sh 不需要可执行权限。 其他问题source(.)、sh和./的区别 参考：https://blog.csdn.net/wangyangkobe/article/details/6595143 https://www.cnblogs.com/pcat/p/5467188.html source命令：source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。用法：source filename 或 . filenamesource命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。 source filename 与 sh filename 及./filename执行脚本的区别在那里呢？1.当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。./filename是因为当前目录没有在PATH中，所有”.”是用来表示当前目录的。2.sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。3.source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。 1、source 1source a.sh 在当前shell内去读取、执行a.sh，而a.sh不需要有”执行权限“ source命令可以简写为”.” 1. a.sh 注意：中间是有空格的。 2、sh/bash 12sh a.shbash a.sh 都是打开一个subshell去读取、执行a.sh，而a.sh不需要有”执行权限“ 通常在subshell里运行的脚本里设置变量，不会影响到父shell的。 3、./ 1234./a.sh#bash: ./a.sh: 权限不够chmod +x a.sh./a.sh 打开一个subshell去读取、执行a.sh，但a.sh需要有”执行权限“ 可以用chmod +x添加执行权限 另外，使用./来执行的文件里有alias语句的话，shell并不会把alias别名扩展成对应的命令，要解决的话，得使用shopt命令来开启alias扩展选项 1shopt -s expand_aliases","link":"/2021/01/24/1620.html"},{"title":"Git 学习笔记","text":"参考：廖雪峰的官方网站 Git简介Git的特点 Git是一种分布式版本控制系统（区别于集中式）。 在Git的版本管理中，文件的创建、修改、删除都被Git处理为“修改”。Git管理的是修改，而非文件。 Git上手安装 Git首先从Git官网下载安装包，安装完成后，打开Git Bash，输入 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 创建版本库 首先创建并进入文件夹 12mkdir learngitcd learngit 通过git init命令把这个目录变成Git可以管理的仓库 1git init 添加文件 将文件（假如叫*.txt）放到文件夹下，然后在该文件夹下执行 1git add *.txt 也可以同时添加多个文件或分多次添加多个文件。 提交文件，并添加更新内容的说明 1git commit -m &quot;I wrote a file named *.txt&quot; 时光机穿梭更新文档修改完文档后，重复“添加文件”小节中的步骤即可更新修改内容到版本库。 另外，使用命令git status可以查看版本库的暂存区的当前状态，命令git diff可以查看修改的内容。 版本找回每次执行git commit都会提交一个新的版本，使用git log可以查看最近的三个版本记录，git log --pretty=oneline可以简化输出。 回退到上一个版本： 1git reset --hard HEAD^ 回退到上上个版本： 1git reset --hard HEAD^^ 回退100个版本： 1git reset --hard HEAD~100 上面的例子说明HEAD（其实是一个指针）就是当前版本。 也可直接跳到指定版本： 1git reset --hard id 其中id可以使用命令git reflog查看（id没必要写全，写前几位就行）。该命令记录了每一次版本更换命令。 工作区、暂存区和主存区如图，git add命令会将工作区（Working Directory）的文件添加到版本库的暂存区（stage）处，而git commit命令会将暂存区的文件添加到主存区（master）处（姑且这么叫吧）。 另外可以发现，在一般情况下，工作区和主存区的文件树都是相对完整的，而暂存区只有部分文件。 版本丢弃 丢弃工作区的改动当执行 git checkout .或者git checkout -- &lt;file&gt;命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 丢弃暂存区的改动命令git reset HEAD &lt;file&gt;可以把暂存区的指定文件&lt;file&gt;的修改撤销，重新放回工作区（unstage），这时候工作区的&lt;file&gt;的内容也会被修改，我们再使用git checkout -- &lt;file&gt;命令即可把工作区&lt;file&gt;的修改给丢弃掉，恢复工作区的状态。这样两步实现了暂存区指定文件&lt;file&gt;的丢弃。 也可以用git rm --cached &lt;file&gt;命令一步就把文件的修改信息从暂存区删除而不改变工作区。 如果暂存库的修改内容已经用git commit命令提交到本地版本库了，可以参考版本找回一节回退版本；若推送到了远程库则无法回退。 丢弃工作区和暂存区的改动当执行git checkout HEAD .或者git checkout HEAD &lt;file&gt;命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 文件删除问题Git 速度慢方法一 123456git clone https://github.com/cpselvis/geektime-webpack-course.git# 改为git clone https://github.com.cnpmjs.org/cpselvis/geektime-webpack-course.git# cnpmjs：company npm/js 方法二 https 改成 git","link":"/2021/01/27/1754.html"},{"title":"ROS 学习笔记","text":"常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182roscore # 启动rosps -ef | grep -i rosmaster # 查看roscore有没有在运行roswtf # 检查错误 rospack find [package_name] # 返回软件包的所在路径roscd [package] &amp;&amp; rosdep install [package] # 下载并安装ROS packages所需要的系统依赖项roscd [locationname[/subdir]] # 切换目录（cd）到某个软件包或者软件包集当中# 注意：roscd只能切换到那些路径已经包含在ROS_PACKAGE_PATH环境变量中的软件包echo $ROS_PACKAGE_PATH # 查看 ROS_PACKAGE_PATH 中包含的路径。# 输出结果：每个路径之间用冒号（:）分隔开来roscd log # 进入日志目录rosls [locationname[/subdir]] # 直接按软件包的名称执行 ls 命令（而不必输入绝对路径）# 脚本执行命令source &lt;dir&gt;/setup.*sh # 读取脚本中的命令，并在当前shell中执行（无需执行权限）. &lt;dir&gt;/setup.*sh # 同上sh &lt;dir&gt;/setup.*sh # 打开一个subshell，读取并执行脚本中的命令（无需执行权限）./&lt;dir&gt;/setup.*sh # 打开一个subshell，并执行脚本中的命令（需要有执行权限）catkin_makecatkin_make install # （可选）catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3] # 创建包# 节点rosnode list # 列出当前运行的节点rosnode info /node_name # 显示节点/node_name的信息rosnode ping /node_namerosnode kill /node_name # 杀死进程rosnode cleanup # 清除无效进程？rosrun [package_name] [node_name]# 例如 rosrun turtlesim turtlesim_noderosrun [package_name] [node_name] ————name:=&lt;customized_name&gt; # 运行并自定义节点名字rosrun rqt_graph rqt_graph # 用图形显示当前运行的节点和话题rosrun rqt_console rqt_console # 连接到了ROS的日志框架，以显示节点的输出信息rosrun rqt_logger_level rqt_logger_level # 允许我们在节点运行时改变输出信息的详细级别# 话题rostopic bw # display bandwidth used by topicrostopic delay # display delay of topic from timestamp in headerrostopic echo /topic_name # print messages to screenrostopic find # find topics by typerostopic hz # display publishing rate of topic rostopic info # print information about active topicrostopic list [-v] # list active topicsrostopic pub [topic] [msg_type] [args] # publish data to topic# 例：rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- # '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'rostopic type # print topic or field type# 话题类型（消息）rosmsg show [pkg/msg] # 查看消息的详细信息（数据结构）。可以不含包前缀来查找# 服务rosservice list # 输出活跃服务的信息rosservice call [service] [args] # 用给定的参数调用服务rosservice type [service] # 输出服务的类型rosservice find # 按服务的类型查找服务rosservice uri # 输出服务的ROSRPC uri# 服务类型rossrv show [pkg/srv] # 输出服务的详细信息（数据结构）。可以不含包前缀来查找# 参数服务器rosparam set [param_name] [value] # 设置参数rosparam get [param_name] # 获取参数rosparam get / # 获取参数服务器上所有参数的值rosparam load [file_name] [namespace] # 从文件中加载参数rosparam dump [file_name] [namespace] # 向文件中转储参数rosparam delete [param_name] # 删除参数rosparam list # 列出参数名roslaunch [package] [filename.launch] # roslaunch命令会自动查找经过的包并检测可用的启动文件rosed [package_name] [filename] # 直接通过软件包名编辑包中的文件（rosed默认的编辑器是vim）rosbag record -a # 记录所有话题消息（在当前目录）在一个bag文件中rosbag info &lt;your bagfile&gt; # 查看bag文件信息rosbag play &lt;your bagfile&gt; # 回放bag文件以再现系统运行过程rosbag record -O subset /turtle1/cmd_vel /turtle1/pose # 订阅两个话题，记录到subset.bag文件time rosbag play --immediate demo.bag --topics /topic1 /topic2 /topic3 /topicN 计算图计算图（Computation Graph）是一个由ROS进程组成的点对点网络，它们能够共同处理数据。ROS的基本计算图概念有节点（Nodes）、主节点（Master）、参数服务器（Parameter Server）、消息（Messages）、服务（Services）、话题（Topics）和袋（Bags），它们都以不同的方式向图（Graph）提供数据。 节点（Nodes）：节点是一个可执行文件，它可以通过ROS来与其他节点进行通信。 消息（Messages）：订阅或发布话题时所使用的ROS数据类型。 话题（Topics）：节点可以将消息发布到话题，或通过订阅话题来接收消息。 主节点（Master）：ROS的命名服务，例如帮助节点发现彼此。 rosout：在ROS中相当于stdout/stderr（标准输出/标准错误）。 roscore：主节点 + rosout + [参数服务器](http://wiki.ros.org/Parameter Server)（会在以后介绍）。 msg和srv msg（消息）：msg文件就是文本文件，用于描述ROS消息的字段。它们用于为不同编程语言编写的消息生成源代码。 srv（服务）：一个srv文件描述一个服务。它由两部分组成：请求（request）和响应（response）。 msg文件存放在软件包的msg目录下，srv文件则存放在srv目录下。 msg文件就是简单的文本文件，每行都有一个字段类型和字段名称。srv文件和msg文件一样，只是它们包含两个部分：请求和响应。这两部分用一条---线隔开。 msg和srv的一般步骤如果没做过上面的教程，请先修改下CMakeLists.txt： 1234# generate_messages(# DEPENDENCIES# # std_msgs # Or other packages containing msgs# ) 取消注释，然后添加任意你的消息用到的包含.msg文件的软件包（本例中为std_msgs），如下所示： 1234generate_messages( DEPENDENCIES std_msgs) 现在我们已经创建了一些新消息，所以需要重新make一下软件包： 12345# In your catkin workspace$ roscd beginner_tutorials$ cd ../..$ catkin_make$ cd - msg目录中的任何.msg文件都将生成所有支持语言的代码。C++消息的头文件将生成在~/catkin_ws/devel/include/beginner_tutorials/。Python脚本将创建在~/catkin_ws/devel/lib/python2.7/dist-packages/beginner_tutorials/msg。而Lisp文件则出现在~/catkin_ws/devel/share/common-lisp/ros/beginner_tutorials/msg/。 类似地，srv目录中的任何.srv文件都将生成支持语言的代码。对于C++，头文件将生成在消息的头文件的同一目录中。对于Python和Lisp，会在msg目录旁边的srv目录中。 编写简单的发布者和订阅者talker.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;sstream&gt;/** * This tutorial demonstrates simple sending of messages over the ROS system. */int main(int argc, char **argv){ /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, &quot;talker&quot;); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The advertise() function is how you tell ROS that you want to * publish on a given topic name. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. After this advertise() call is made, the master * node will notify anyone who is trying to subscribe to this topic name, * and they will in turn negotiate a peer-to-peer connection with this * node. advertise() returns a Publisher object which allows you to * publish messages on that topic through a call to publish(). Once * all copies of the returned Publisher object are destroyed, the topic * will be automatically unadvertised. * * The second parameter to advertise() is the size of the message queue * used for publishing messages. If messages are published more quickly * than we can send them, the number here specifies how many messages to * buffer up before throwing some away. */ ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000); ros::Rate loop_rate(10); /** * A count of how many messages we have sent. This is used to create * a unique string for each message. */ int count = 0; while (ros::ok()) { /** * This is a message object. You stuff it with data, and then publish it. */ std_msgs::String msg; std::stringstream ss; ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count; msg.data = ss.str(); ROS_INFO(&quot;%s&quot;, msg.data.c_str()); /** * The publish() function is how you send messages. The parameter * is the message object. The type of this object must agree with the type * given as a template parameter to the advertise&lt;&gt;() call, as was done * in the constructor above. */ chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); ++count; } return 0;} 过程 初始化ROS系统 向主节点宣告我们将要在chatter话题上发布std_msgs/String类型的消息 以每秒10次的速率向chatter循环发布消息 listener.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;/** * This tutorial demonstrates simple receipt of messages over the ROS system. */void chatterCallback(const std_msgs::String::ConstPtr&amp; msg){ ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str());}int main(int argc, char **argv){ /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, &quot;listener&quot;); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The subscribe() call is how you tell ROS that you want to receive messages * on a given topic. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. Messages are passed to a callback function, here * called chatterCallback. subscribe() returns a Subscriber object that you * must hold on to until you want to unsubscribe. When all copies of the Subscriber * object go out of scope, this callback will automatically be unsubscribed from * this topic. * * The second parameter to the subscribe() function is the size of the message * queue. If messages are arriving faster than they are being processed, this * is the number of messages that will be buffered up before beginning to throw * away the oldest ones. */ ros::Subscriber sub = n.subscribe(&quot;chatter&quot;, 1000, chatterCallback); /** * ros::spin() will enter a loop, pumping callbacks. With this version, all * callbacks will be called from within this thread (the main one). ros::spin() * will exit when Ctrl-C is pressed, or the node is shutdown by the master. */ ros::spin(); return 0;} 过程 初始化ROS系统 订阅chatter话题 开始spin自循环，等待消息的到达 当消息到达后，调用chatterCallback()函数 CMakeLists.txt1234567891011121314151617181920212223242526cmake_minimum_required(VERSION 2.8.3)project(beginner_tutorials)## Find catkin and any catkin packagesfind_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs genmsg)## Declare ROS messages and servicesadd_message_files(FILES Num.msg)add_service_files(FILES AddTwoInts.srv)## Generate added messages and servicesgenerate_messages(DEPENDENCIES std_msgs)## Declare a catkin packagecatkin_package()## Build talker and listenerinclude_directories(include ${catkin_INCLUDE_DIRS})add_executable(talker src/talker.cpp)target_link_libraries(talker ${catkin_LIBRARIES})add_dependencies(talker beginner_tutorials_generate_messages_cpp)add_executable(listener src/listener.cpp)target_link_libraries(listener ${catkin_LIBRARIES})add_dependencies(listener beginner_tutorials_generate_messages_cpp) 编写简单的服务和客户端add_two_ints_server.cpp1234567891011121314151617181920212223#include &quot;ros/ros.h&quot;#include &quot;beginner_tutorials/AddTwoInts.h&quot;bool add(beginner_tutorials::AddTwoInts::Request &amp;req, beginner_tutorials::AddTwoInts::Response &amp;res){ res.sum = req.a + req.b; ROS_INFO(&quot;request: x=%ld, y=%ld&quot;, (long int)req.a, (long int)req.b); ROS_INFO(&quot;sending back response: [%ld]&quot;, (long int)res.sum); return true;}int main(int argc, char **argv){ ros::init(argc, argv, &quot;add_two_ints_server&quot;); ros::NodeHandle n; ros::ServiceServer service = n.advertiseService(&quot;add_two_ints&quot;, add); ROS_INFO(&quot;Ready to add two ints.&quot;); ros::spin(); return 0;} add_two_ints_client.cpp123456789101112131415161718192021222324252627282930#include &quot;ros/ros.h&quot;#include &quot;beginner_tutorials/AddTwoInts.h&quot;#include &lt;cstdlib&gt;int main(int argc, char **argv){ ros::init(argc, argv, &quot;add_two_ints_client&quot;); if (argc != 3) { ROS_INFO(&quot;usage: add_two_ints_client X Y&quot;); return 1; } ros::NodeHandle n; ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(&quot;add_two_ints&quot;); beginner_tutorials::AddTwoInts srv; srv.request.a = atoll(argv[1]); srv.request.b = atoll(argv[2]); if (client.call(srv)) // 如果没有服务器，不会阻塞，因此服务器要先开 { ROS_INFO(&quot;Sum: %ld&quot;, (long int)srv.response.sum); } else { ROS_ERROR(&quot;Failed to call service add_two_ints&quot;); return 1; } return 0;} CMakeLists.txt1234567add_executable(add_two_ints_server src/add_two_ints_server.cpp)target_link_libraries(add_two_ints_server ${catkin_LIBRARIES})add_dependencies(add_two_ints_server beginner_tutorials_gencpp)add_executable(add_two_ints_client src/add_two_ints_client.cpp)target_link_libraries(add_two_ints_client ${catkin_LIBRARIES})add_dependencies(add_two_ints_client beginner_tutorials_gencpp) 问题rosdeprosdep 安装运行rospack depends1 beginner_tutorials 后报错：[rospack] Error: no such package beginner_tutorials。原因是没有安装rosdep。这个包好像是可以方便解决软件包依赖问题的，我在安装后再apt install ros-noetic-desktop-full后提示会移除rosdep，再查官方文档，知道这是个额外的包。 解决：ubuntu应该安装python3-rosdep而不是python3-rosdep2 sudo rosdep init 报错与解决12345678910111213141516171819202122232425262728293031wbx@ubuntu:~$ rosdep initERROR: default sources list file already exists: /etc/ros/rosdep/sources.list.d/20-default.listPlease delete if you wish to re-initializewbx@ubuntu:~$ sudo rm /etc/ros/rosdep/sources.list.d/20-default.listwbx@ubuntu:~$ rosdep initERROR: cannot create /etc/ros/rosdep/sources.list.d/20-default.list: [Errno 13] Permission denied: '/etc/ros/rosdep/sources.list.d/20-default.list'wbx@ubuntu:~$ sudo rosdep initERROR: cannot download default sources list from:https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.listWebsite may be down.wbx@ubuntu:~$ sudo vim /etc/hostswbx@ubuntu:~$ cat /etc/hosts127.0.0.1 localhost127.0.1.1 ubuntu185.199.110.133 raw.githubusercontent.com # 去ipaddress.com上查询# The following lines are desirable for IPv6 capable hosts::1 ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouterswbx@ubuntu:~$ rosdep initERROR: cannot create /etc/ros/rosdep/sources.list.d/20-default.list: [Errno 13] Permission denied: '/etc/ros/rosdep/sources.list.d/20-default.list'wbx@ubuntu:~$ sudo rosdep initWrote /etc/ros/rosdep/sources.list.d/20-default.listRecommended: please run rosdep update 到这里rosdep init就成功了 如果出现 website may be down 的错误（python2.7可能有这个问题），可能是证书出现问题。有以下方法： sudo apt-get install ca-certificates # 安装 ca-certificates 软件 12342. ```shell sudo c_rehash /etc/ssl/certs sudo -E rosdep init rosdep updaterosdep update 报的错误有以下几个： ERROR: unable to process source 123- ``` urlopen error _ssl.c:1106: The handshake operation timed out - 解释：握手操作超时 - 解决：配置 VPN - ``` urlopen error [Errno -3] Temporary failure in name resolution 123456 - 解释：域名解析出现暂时错误 - 解决：编辑 /etc/resolv.conf 文件，加入谷歌的 DNS 服务器；编辑 /etc/hosts 文件，删除 raw.githubusercontent.com 的相关配置 - ``` urlopen error [Errno 104] Connection reset by peer - 解释：连接被监督（peer）重置（防爬虫？） - 解决：编辑 /etc/resolv.conf 文件，加入谷歌的 DNS 服务器；编辑 /etc/hosts 文件，删除 raw.githubusercontent.com 的相关配置 - ``` urlopen error [Errno 111] Connection refused 123456 - 解释：连接被拒绝 - 解决：编辑 /etc/resolv.conf 文件，加入谷歌的 DNS 服务器 - ``` ERROR: error loading sources list - ``` The read operation timed out 1234567 - 解释：读取操作超时 - 解决：~~换成手机热点？~~将 `sources_list.py`、`gbpdistro_support.py`、`rep3.py` 三个文件的 DOWNLOAD_TIMEOUT 设置长一些，其值要大于预估的执行 `rosdep update` 命令的总时长。 - 建议：配置 VPN 来解决 - ``` urlopen error &lt;urlopen error timed out&gt; 总结： 编辑 /etc/resolv.conf 文件，加入谷歌的 DNS 服务器； 编辑 /etc/hosts 文件，删除 raw.githubusercontent.com 的相关配置； 配置 VPN。可以用 Lantern VPN。下载时用火狐浏览器插件 iGuge（搜索 igg）更快。 gazebo 打开模型时卡死不要打开在线模型！！！ 参考http://wiki.ros.org/cn/ROS/Tutorials/","link":"/2021/03/02/1222.html"},{"title":"Win10 频繁开启代理导致断网问题","text":"新文章：https://blog.csdn.net/weixin_44091885/article/details/106594289 重置IE浏览器设置没用 关闭微软账户同步设置没用 卸载前几天安装的银联、农行安全控件没用 用火绒监控ProxyEnable注册表有用，多次检测到微软的smartscreen程序试图开启代理，经过百度后知道这是ie的一个子程序，用来监测上网的。虽然可以设置监测到就自动禁止，但我想从根本上解决问题： 禁用方法： IE-&gt;internet选项-&gt;安全-&gt;自定义级别-&gt;使用Windows Defender SmartScreen-&gt;禁用 最后有时候还是会断网，但恢复得很快。然后我还不满意就试了一下下面的方法 贴吧大神的方法结果电脑就崩了。能开机，但是系统设置出现了一些空白，等等一堆bug。 1，进入安全模式(必须，否则会失败)2， 打开注册表(win+R， 运行regedit)3，注册表左侧栏点击第一个计算机，再点击顶部菜单栏“编辑”-“查找”，输入127.0.0.1，点击“查找下一个”，耐心等候4，查找完毕，观察右侧栏，是否有焦点自动选中的项目，直接删掉，删完按F3(表示继续查找下一个)，一直重复直到把找出来的相关项目都删了为止5，最后按F5保存。重启电脑。完美解决。不放心可以1-5步骤重复一遍，确保与127.0.0.1相关的注册表项目删除干净Tips：1，请务必进入安全模式，否则无效2，查找注册表时，一定是右侧栏焦点选中的项目才可以删除，否则不要随便删除 最后在msdn上下了最新版的win10重装了系统。软件基本不用重装，就是一开始在桌面右键点某个应用的时候卡住了。重启了也不行。最后用腾讯电脑管家的右键管理一看，一大堆软件都放右键了。。全部取消就恢复正常了。 重装电脑后网络当然就没问题了。","link":"/2020/02/22/1418.html"},{"title":"在 BIOS 中将 SATA 改为 AHCI 后重启蓝屏","text":"如果是UEFI+GPT分区表模式，那么给ubuntu分区的时候不用设置/boot分区，而要设置efi系统分区；如果是legacy+MBR分区表那么就要设置/boot分区。 格式化是针对主分区和逻辑分区的。要格式化是因为这和操作系统管理文件系统有关系。没有格式化的分区就像一张白纸，要写入数据，必须对白纸打上“格子”，每个格子里面写一块。而操作系统只认这些格子。所以要先用windows格式化，让windows认得移动硬盘，再用ubuntu格式化？","link":"/2019/09/29/1207.html"},{"title":"计算机网络","text":"参考：https://www.bilibili.com/video/BV124411k7uV?from=search&amp;seid=8102981964172889001 网络设备需要解决的问题网络设备需要实现两个重要的功能： 转发 标识 网络设备的演变HUB HUB：集线器，构建星型网络 通过广播的形式，把数据包发给所有设备，让设备自己识别数据包是不是自己的 CSMA/CD协议：HUB模式是半双工的，这个协议为了防止冲突 SWSW：交换机 有了MAC地址，且是全双工的 不同交换机之间可以进行桥接 MAC地址表有限 路由器路由器（也叫网关） 有了IP地址：标识网络和设备 实现了不同网络之间的通信 路由器分WAN口和LAN口，LAN连接本地网络（内网），WAN连接外部网络（公网） 路由器有一个WAN固定IP，有一个LAN网段，网口可以分配不同的IP 跨网络传输过程例如要从192.168.0.12传给192.168.1.254，具体过程如下： 0.12→0.1（路由器的IP） 查0.1的MAC地址（通过ARP广播） MAC层传输 0.1→1.52（路由器内部两个端口之间的传输） 1.52→1.254 查1.254的MAC地址（通过ARP广播） MAC层传输 一些网络协议DHCP协议：自动分配IP NAT：网络地址转换协议","link":"/2021/01/29/1022.html"},{"title":"HTML 学习笔记","text":"HTML模板1234567891011121314151617&lt;!DOCTYPE html&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2021/01/20/1952.html"},{"title":"","text":"我的第一个网页！！！ 这里是顶部~ Hello HTML~ 开始学习HTML。 不知道这东东有什么用。不知道能不能学到能自己做网页的程度。 有什么用自己百度一下？ href应该是超链接（Hyper Reference）的缩写，好记！但a怎么记？一个超链接？好吧可以。 这玩意怎么换行呀？不会只能用p标签吧？？？ 接下来加载一张图片试试？ 用什么图片好呢？emmm。头像？ src是source的缩写啦。btw，突然发现可以用两个p标签来换行 真正的换行方法！ 好吧，用br标签才是真正的换行方法。换行~再换行~OK~换行标签br只有开始标签，没有结束标签耶。 换行标签其实也要关闭，在br后面加上一斜杠（表示关闭）才是标准的写法。 HTML属性的用法 开头的百度一下链接就用到了一种属性（href）。双引号是最常用的，不过使用单引号也没有问题。 提示: 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name='John \"ShotGun\" Nelson'。 参考链接：菜鸟教程 字号大小怎么调整呢？答案：也是用属性。 六号最大，一号最小。 好吧我发现其实更大也可以。 HTML水平线 用hr标签就可以啦~（horizon的缩写？）试试看！ 啦啦啦这里是一段 emmm不是说好了标签都要关闭吗。。怎么hr不用。。有斜杠反而不显示。 HTML注释 好吧这个我在最前面已经试过了。 HTML段落注意事项 标签内的回车会被视为一个空格。连续的回车或空行会被视为一个。所以要在段内换行还是得用br标签。 HTML文本格式化 这是粗体 这是斜体 这是code标签，应该是显示代码的吧。试试，function a_func(int a, int num); 这是下标，这是上标。好吧，我想试试水：H2O。 除了用b和i，加粗和斜体也可以用strong标签和em（emphasize？）标签。 其他标签，例如： 1.用于字体放大的big标签； 2.用于presentation？？的pre标签。 可能是为了方便排版吧。 用了这个标签后，字体会变成和code标签内的字体一样，回车=换行，空格 有多少 就 显示多少。 3.address标签 这个好鸡肋啊 深圳南山 by Wu 4.abbr标签（abbreviation） 这个挺有用的哟。 5.dir标签，用于更改文字方向。这个真的没卵用。 6.q标签，引用（quote）标签。鲁迅说：这个也没啥用。显示上没啥区别呀。就多了个引号。 7.ins（insert）：插入标签。 好像就是有个下划线的效果？ 8.del（delete）：删除标签。 删除线效果。 9.还有好多标签啊。。。全部列在这里吧。 dfn（definition）：定义标签，某个词首次出现的时候可以用一下。 samp（sample）：样本标签。这个不知道有什么用。。 kbd（keyboard）：键盘输入标签。 var（variable）：变量标签。 HTML链接（续） 上面简单介绍了链接的使用方法，其实链接不仅可以是一个网址，也可以是一张图片，一个位置等。 一个网址的高阶用法： 要链接到哪里好呢？算了还是百度吧。。访问百度网站 这样写可以在新标签中打开网站。其他target属性试试： 用parent模式访问百度 用self模式访问百度 用top模式访问百度 链接的id属性： 这个就挺有用的，可以返回到特定位置，如返回顶部 图片链接：点击能跳转到百度 >","link":"/2021/01/20/1957.html"},{"title":"OpenVLC 文件树","text":"文件树Driver decode_rs.c：解码 encode_rs.c：计算数据的校验位，进行编码 openvlc.c：vlc相关，mac层 openvlc.h reed_solomon.c：rs初始化，计算数据的校验位（encode_rs.c） rs.c：RS算法，包括初始化查询表 rslib.h：rs结构体、编码/解码器库 vlc.mod.c PRU RX deploy.sh main_pru0.c main_pru1.c resource_table_pru0.h resource_table_pru1.h TX deploy.sh main_pru1.c resource_table_pru0.h resource_table_pru1.h 网络等配置TX： usb0网卡IP：192.168.7.2 vlc0网卡IP：192.168.0.1 RX： usb0网卡IP：192.168.7.2 vlc0网卡IP：192.168.0.2","link":"/2021/01/17/2031.html"},{"title":"大学物理笔记","text":"力学机械运动 质点 运动的绝对性 运动的相对性 时刻 时间 位置矢量 运动函数：r(t)=x(t)i+y(t)j 轨迹方程：y=f(x) 瞬时速度、瞬时速率 绝对速度、相对速度、牵连速度：v=vr+v0 加速度 圆周运动加速度 牛顿运动定律牛顿第一定律（惯性定律） 质量 牛顿第二定律：F=ma 运动学正问题 运动学反问题 牛顿第三定律（反作用力） 作用力和反作用力的特点： 同时存在、同时消失 作用在不同物体上 属于同一性质的力 万有引力 惯性参考系 力学中常见的力弹性力：F=-kx 摩擦力 静摩擦力 动摩擦力 粘滞阻力 大小主要取决于固体或流体的速度 大小也和固体的形状、流体的性质有关 非惯性参考系、系统的动能定理 、机械能守恒定律、能量守恒定律第一宇宙速度：$mg=m \\dfrac{v^{2}}{r_{e}}$，7.9km/s 第二宇宙速度：$\\dfrac{1}{2} mv^{2} - G \\dfrac{mM}{r_{e}} = 0$，11.2km/s（机械能=0） 第三宇宙速度：16.7km/s 功 内力、外力 保守力：力所做的功只与与始末位置有关，而与路径无关 系统的动能定理：一切外力对系统所做的功与系统内各物体间一切内力所做的功之代数和等于该系统的动能之增量。 系统的机械能守恒定律：如果一个系统的所有外力和非保守性内力都不做功，则系统的机械能总是保持一恒量。 冲量与动量、质点的动量定理、系统的角动量守恒定律动量（momentum）：$\\vec{p}=m\\vec{v}$ 冲量（impulse）：$\\vec{I}=\\int_{t_1}^{t_2} \\vec{F}dt$ 系统的动量定理：$\\sum \\vec{F_外} =\\dfrac{d}{dt} \\sum \\vec{p}$ 系统动量守恒定律 记忆： 因为 冲量=动量 所以 $d \\vec{I}=d \\vec{p}$ 又因为 $d \\vec{I}=\\vec{F}dt$ 所以 $\\vec{F}dt=d \\vec{p}=m\\vec{v}$ 所以 $\\vec{F}=\\dfrac{d\\vec{p}}{dt}=m\\dfrac{d\\vec{v}}{dt}=m\\vec{a}$ 质心 质心运动定理：$\\sum \\vec{F_{外}}=M \\vec{a_{c}}$ 碰撞的前后，可认为系统总动量保持不变 但动能可能有损失： 弹性碰撞：动能完全没有损失 非弹性碰撞 完全非弹性碰撞 角动量：$\\vec{L}=\\vec{r} \\times m\\vec{v}$ 力矩：$\\vec{M}=\\vec{r}\\times \\vec{F}$ 冲量矩：$\\int_{t_1}^{t_2} \\vec{M} dt$ 系统的角动量定理（动量矩定理）：$\\sum \\vec{M}=\\dfrac{d}{dt} \\sum \\vec{L}$。（对某一点而言） 系统的角动量守恒定律（对某一点而言） 刚体刚体：形状和大小不变 平动 转动 刚体的转动惯量：$J=\\iiint_{V} \\vec{r}^{2}dm$ 刚体绕定轴转动的动能：$E_{\\rm k}=\\dfrac{1}{2} J\\omega^{2}$ 力臂 力矩的功：$dA=Md\\theta$ 功率：$P=M\\omega$ 刚体定轴转动的动能定理：$A=\\dfrac{1}{2} J\\omega_{2}^{2}-\\dfrac{1}{2} J\\omega_{1}^{2}$。（对比动能定理） 刚体的定轴转动定理：$\\vec{M} =J\\vec{\\alpha}$。（对比牛顿第二定律） 冲量矩：$\\vec{M}dt$ 刚体对转轴的角动量：$J\\omega$ 刚体定轴转动的角动量定理：$\\int_{t_1}^{t_2}Mdt=J\\omega_2-J\\omega_1$ 刚体定轴转动的角动量守恒定律 常见物体对不同转轴的转动惯量 相对论狭义相对论基本原理： 相对性原理：在所有惯性系中，物理定律都具有同样的表达形式 光速不变原理：在所有惯性系中，测得真空中的光速都等于 $c$ 伽利略变换设 K 系和 K’ 系都为惯性参考系，K’ 相对 K 在 x 轴方向有速度 $u$，则基于绝对时空观的伽利略变换如下 $$\\left.\\begin{array}{lc}x^{\\prime}=x-u t \\y^{\\prime}=y \\z^{\\prime}=z \\t^{\\prime}=t\\end{array}\\right} \\quad \\text { 或 } \\left.\\quad \\begin{array}{rl}&amp; x=x^{\\prime}+u t \\&amp; y=y^{\\prime} \\&amp; z=z^{\\prime} \\&amp; t=t^{\\prime}\\end{array}\\right}$$ 洛伦兹变换分子类似伽利略变换，洛伦兹变换如下 $x=\\dfrac{x’+ut’}{\\sqrt{1-(u/c)^2}}$ $t=\\dfrac{t’+(u/c^2)x’}{\\sqrt{1-(u/c)^2}}$ 或$$\\left.\\begin{array}{l}x^{\\prime}=\\dfrac{x-u t}{\\sqrt{1-(u / c)^{2}}} \\y^{\\prime}=y \\z^{\\prime}=z \\t^{\\prime}=\\dfrac{t-ux / c^{2} }{\\sqrt{1-(u / c)^{2}}}\\end{array}\\right}$$ 记忆： x的分子和伽利略变换公式一样 所有的分母很有规律，而分子和x和t都有关 分子是加法还是减法取决于轴的方向，可以根据伽利略变换公式来推导 洛伦兹速度变换公式$$\\left.\\left.\\begin{array}{l}v_{x}^{\\prime}=\\frac{v_{x}-u}{1-\\left(u / c^{2}\\right) v_{x}} \\v_{y}^{\\prime}=\\frac{\\sqrt{1-(u / c)^{2}} v_{y}}{1-\\left(u / c^{2}\\right) v_{x}} \\v_{z}^{\\prime}=\\frac{\\sqrt{1-(u / c)^{2} v_{z}}}{1-\\left(u / c^{2}\\right) v_{x}}\\end{array}\\right}{\\quad 或 \\quad}\\begin{array}{r}v_{x}=\\frac{v_{x}^{\\prime}+u}{1+\\left(u / c^{2}\\right) v_{x}^{\\prime}} \\\\text v_{y}=\\frac{\\sqrt{1-(u / c)^{2}} v_{y}^{\\prime}}{1+\\left(u / c^{2}\\right) v_{x}^{\\prime}} \\v_{z}=\\frac{\\sqrt{1-(u / c)^{2} v_{z}^{\\prime}}}{1+\\left(u / c^{2}\\right) v_{x}^{\\prime}}\\end{array}\\right}$$ 相对论的时空观同时的相对性：$\\Delta t=t_2-t_1=\\dfrac{(x_2’-x_1’)u/c^2}{\\sqrt{1-(u/c)^2}}$，（$t_1’=t_2’$ 时） 尺缩效应：$L=L_0’\\sqrt{1-\\dfrac{u^2}{c^2}}$，（$t_1=t_2$，即同时测量两端） 动钟变慢：$\\Delta t’=\\dfrac{\\Delta t}{\\sqrt{1-(u/c)^2}}$ 以上三个式子很容易通过洛伦兹变换推导得到 记忆：根据效应的名称来判断 $\\sqrt{1-(u/c)^2}$ 应该放分子还是分母，然后再根据量纲添加 $u/c^2$ 等。事件发生的先后顺序根据光速不变原理判断。 狭义相对论的动力学基础运动物体的 质量：$m=\\dfrac{m_0}{\\sqrt{1-(u/c)^2}}$ 动量：$\\vec{p}=m\\vec{v}=\\dfrac{m_0}{\\sqrt{1-(u/c)^2}}\\vec{v}$ 运动方程：$\\vec{F}=\\dfrac{d\\vec{p}}{dt}=\\dfrac{d}{dt}(\\dfrac{m_0}{\\sqrt{1-(u/c)^2}}\\vec{v})$ 动能：$E_{\\rm k}=\\frac{1}{2} m_{0} v^{2}$ 静能：$E_0=m_0c^2$ 总能量：$E=mc^2$（质能方程） 三者的关系：$E=E_{0}+E_{\\mathrm{k}}$ 能量与动量的关系：$v^2=\\dfrac{p^2c^4}{E^2}$，或 $E^2=E_0^2 + (pc)^2$ 光子：以光速运动的粒子 光子能量与动量的关系：$E=pc$（光子没有静能） 电磁学电荷 库伦定律正电荷：丝绸摩擦过的玻璃棒 负电荷 电荷守恒定律：一个孤立系统的总电荷（即系统中所有正、负电荷之代数和）在任何物理过程中始终保持不变。 电荷不变性原理：在不同的惯性系中观测物体所带电荷的多少是相同的。 不变量：在特定坐标变化下不改变的量 守恒量：不随时间变化的量 点电荷：带电体之间的距离远大于它们自身的几何线度时，带电体之间的相互作用力受带电体大小、形状、电荷分布的影响可以忽略不计，这时可以把带电体视为点电荷。 电荷元可以看成点电荷 真空中的库伦定律：$\\vec{F}=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{q_0q}{r^2}\\vec{e}_{r}$（注意只在点电荷条件成立时才成立）。 其中 $\\varepsilon_0$：真空电容率（真空介电常数） 记忆：epsilon-&gt;electricity，跟磁导率mu区分 静电力叠加原理 电场 电场强度静电场：静止电荷所激发出的电场 电场强度 $\\vec{E}$：电场中任一点的电场强度在量值上等于一个单位正电荷在该点所受到的电场力，电场强度的正方向规定为正电荷在该点所受电场力的方向。$$\\vec{E}=\\dfrac{\\vec{F}}{q}=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{q}{r^2}\\vec{e}{r}$$连续情况下：$$\\boldsymbol{E}=\\iiint{V} \\mathrm{~d} \\boldsymbol{E}=\\iiint_{V} \\frac{1}{4 \\pi \\varepsilon_{0}} \\frac{\\mathrm{d} q}{r^{2}} \\boldsymbol{e}_{r}$$电场：在电荷周围存在着一种特殊形态的物质，称为电场 静电力叠加原理：每个点电荷所受的总静电力，等于其他点电荷单独存在时，作用于该点电荷上的静电力之矢量和 试探电荷：用于判断电场的存在与否和电场强弱的电荷 场源电荷：激发电场的电荷 均匀电场（匀强电场）：电场中各点的电场强度的大小和方向都相同 电场强度叠加原理：电场中某点的总电场强度等于各个点电荷单独存在时，在该点的电场强度之矢量和 电偶极子 电矩（电偶极矩）：$\\vec{p}_{\\rm e}=q\\vec{l}$，其中 $\\vec{l}$ 为从 $-q$ 指向 $+q$ 的矢量 电偶极子在电场中所受力偶矩为$$\\vec{M}=\\vec{p}_{\\rm e}\\times \\vec{E}$$ 电（场强度）通量 真空中的高斯定理电场线，电场线越密，电场强度越大 电场强度 $\\vec{E}$ 大小的定义：在电场中任一点附近，通过该处垂直于电场强度 $\\vec{E}$ 方向的单位面积的电场线条数等于该点电场强度的大小，即 $E=\\dfrac{\\Delta N}{\\Delta S_{\\perp}}$ 电（场强度）通量：$\\varPhi_e=\\iint_S\\vec{E}\\cdot d\\vec{S}$ （真空中静电场的）高斯定理：$$\\varPhi_{\\rm e}=\\oiint \\vec{E}\\cdot d\\vec{S}=\\dfrac{1}{\\varepsilon_0} \\sum q_内​$$ 用途：求电场强度 如果选取的闭合曲面是球面，球体内电荷关于球面中心对称分布，则有 $E\\cdot 4\\pi r^2=\\dfrac{1}{\\varepsilon_0} \\sum q_内$ 电势 静电场的环路定理（静电场的）环路定理：静电场中电场强度 $E$ 的环流恒为0，即$$\\oint \\vec{E} \\cdot d\\vec{l}=0$$因此静电力做功与路径无关 高斯定理–&gt;静电场是有源场 环路定理–&gt;静电场是无旋场（不闭合），所以是有势场、保守力场 电场中某点电势能的量值： 单位正电荷放在该点时所具有的电势能 单位正电荷从该点经过任意路径到无穷远处时静电力做的功 $$W_{a}=q_{0} \\int_{a}^{\\infty} \\boldsymbol{E} \\cdot \\mathrm{d} \\boldsymbol{l}$$ 电势：$$U=\\int_r^{\\infin}\\vec{E}\\cdot d\\vec{l}$$ （真空中）点电荷的电势：$V_{\\rm a}=\\dfrac{q}{4\\pi\\varepsilon_0 r}$ 连续分布电荷中任意一点的电势：$$V_{a}=\\frac{1}{4 \\pi \\varepsilon_{0}} \\iiint_{\\tau} \\frac{\\rho \\mathrm{d} \\tau}{r}, \\quad V_{a}=\\frac{1}{4 \\pi \\varepsilon_{0}} \\iint_{s} \\frac{\\sigma \\mathrm{d} S}{r}, \\quad V_{a}=\\frac{1}{4 \\pi \\varepsilon_{0}} \\int \\frac{\\lambda \\mathrm{d} l}{r}$$ 电势差：$U_{ab}=V_a-V_b$ 等势面 电场强度与电势的微分关系$l$ 方向上：$E_l=-\\dfrac{\\partial V}{\\partial l}$ $$E=-\\nabla{U}=-{\\rm grad},U$$ 静电场中的金属导体静电感应：导体因受到外电场作用而发生的电荷重新分布的现象 感应电荷：导体上因静电感应而出现的电荷 静电平衡状态：导体上没有电荷做定向运动的状态 导体处于静电平衡状态的条件： 导体内部任何一点的电场强度都为0 靠近导体表面附近任何一点的电场强度方向都垂直于该点处的表面 静电平衡时，导体内各点与导体表面上各点的电势都相等，整个导体是一个等势体，导体表面是一个等势面。 导体的电势：处于静电平衡状态下，导体所具有的电势 由高斯定理可得，静电平衡时，导体表面外附近的电场强度$$E=\\dfrac{\\sigma}{\\varepsilon_0}$$其中，$\\sigma$ 为导体表面的电荷面密度 静电屏蔽：放在导体空腔中的物体因空腔导体屏蔽了外电场，而不会受到任何外电场的影响 静电场中的电介质电介质（绝缘体）：电阻率很高，导电能力极差的物质 极化：在外电场的作用下电介质出现极化电荷的现象，称为电介质的极化 无极分子的极化：位移极化 有极分子的极化：取向极化 有极分子：分子正负电荷的中心不重合，即电矩 $p_{\\rm e}\\ne 0$ 有电介质时的总电场强度$$E=E_0-E’$$ $$E=\\frac{E_{0}}{\\varepsilon_{\\mathrm{r}}}$$ 介电常数（电容率）：$\\varepsilon=\\varepsilon_0 \\varepsilon_r$，$C=\\varepsilon_{\\rm r}C_0$ 其中，$E$ 为电介质中的电场，$E’$ 为电介质极化后的附加电场（反向），$E_0$ 为外电场 规定电位移矢量：（由曲面内外的自由电荷和束缚电荷共同决定）$$\\vec{D}=\\varepsilon \\vec{E}$$ 记忆：这个电位移的概念有点类似光的干涉中光程的概念 电位移通量：$\\oiint \\vec{D} \\cdot d\\vec{S}$，仅与曲面内的自由电荷有关 注意：电场线和电位移线不一样，电位移线是由自由正电荷发出的，与电介质无关；而电场线是由自由正电荷或束缚正电荷发出的。 （有电介质时的）高斯定理：（在变化的磁场中仍成立）$$\\oiint \\vec{D}\\cdot d\\vec{S}=\\sum q_{内（自由）}$$（无限大均匀电介质中的）库伦定律：$\\vec{F}=\\dfrac{1}{4\\pi \\varepsilon} \\dfrac{q_1 q_2}{r^2} \\vec{e_r}$ 极化效应会削弱空间原有的电场强度，故 $\\varepsilon_r &gt;1$ 电容和电容器（孤立导体的）电容 $C$：导体所带电荷 $q$ 与相应电势 $V$ 之比，即 $C=\\dfrac{q}{V}$ 电容单位：${\\rm F}$，$1{\\rm pF}=10^{-12} {\\rm F}$ （电容器的）电容 $C$：电容器一个极板所带电荷和两极板电势差之比 平行板电容器电容 $C=\\dfrac{\\varepsilon S}{d}$ 球形电容器电容 $C=\\dfrac{q}{V_a -V_b}=\\dfrac{q}{\\frac{q}{4\\pi \\varepsilon} (\\frac{1}{R_a}-\\frac{1}{R_b})}=\\dfrac{4\\pi \\varepsilon R_a R_b}{R_b - R_a}$ 电容器串联 $\\dfrac{1}{C}=\\dfrac{1}{C_1}+\\dfrac{1}{C_2}$，串联总电容降低，但耐压程度提高（因为每个电容器上分配的电压小于总电压） 电容器并联 $C=C_1+C_2$，串联总电容提高，但耐压程度不变（因为每个电容器上的电压没有变化，等于总电压） 静电场的能量电场能量密度 $w_e$：电场中单位体积内的能量，$w_{\\rm e}=\\dfrac{DE}{2}=\\dfrac{\\varepsilon E^2}{2}$ 静电场能量：$W_{\\rm e}=\\iiint w_{\\rm e}dV$ 电流电流：大量电荷的定向移动 形成电流的条件： 可移动的电荷 维持电荷做定向移动的电场 直流电（恒定电流）：不随时间而改变的电流 稳恒电场：形成恒定电流的电场 欧姆定律：当一段均匀金属导体AB通有恒定电流，而且温度不变时，电流与其两端电压成正比，与导体两端电阻成反比。$I=\\dfrac{U}{R}$，$R=\\rho \\dfrac{l}{s}$ 电流密度：$\\vec{j}=\\gamma \\vec{E}$，电导率 $\\gamma=1/\\rho$ 焦耳定律：$Q=I^2Rt$ 电源：能够提供非静电力，而把其他形式的能量转化为电能的装置 电动势：非静电力将正电荷从负极移到正极所消耗的功与正电荷电荷量的比值，它反映的是电源将其他形式的能量转化为电能的能力 运动电荷激发磁场 磁感应强度（$B$）：描述磁场各点强弱与方向的物理量$$B=\\dfrac{F_{\\rm max}}{|q|v}$$当电荷运动方向与磁场方向垂直时，受力最大为 $F_{\\rm max}$ 一切磁现象的本源是电流 真空中磁场的毕奥萨伐尔定律：（一般用来计算某点的电磁感应强度） 宏观载流导线：$d\\vec{B}=\\dfrac{\\mu_{0}}{4 \\pi} \\dfrac{I \\mathrm{d} l \\sin (\\mathrm{d} l, \\boldsymbol{r})}{r^{2}}=\\dfrac{\\mu_0}{4\\pi} \\dfrac{Id\\vec{l}\\times \\vec{r}}{r^3}$ 运动电荷的磁场：$\\vec{B}=\\dfrac{\\mu_{0}}{4 \\pi} \\dfrac{qv \\sin (\\boldsymbol{v}, \\boldsymbol{r})}{r^{2}}=\\dfrac{\\mu_0}{4\\pi} \\dfrac{q\\vec{v}\\times\\vec{r}}{r^3}$ 其中 $\\mu_0$ 为真空磁导率 磁感应线磁感应线 右手螺旋法则判定 直电流 圆电流 所激发的磁场中磁感应线的方向 磁感应强度 $B$ 大小的定义：在数值上等于通过某点上垂直于 $B$ 矢量的单位面积的磁感应线条数（称为磁感应线密度） 磁通量：$\\varPhi_{\\mathrm{m}}=\\iint_{S} B \\cos \\theta \\mathrm{d} S=\\iint_{S} \\boldsymbol{B} \\cdot \\mathrm{d} \\boldsymbol{S}$，单位：韦伯（${\\rm Wb}$） 下标 m 是磁场 magnetic 的首字母 真空磁场的高斯定理：通过任意闭合曲面的总磁通量为0。（磁场是无源场）$$\\oiint_{S} \\boldsymbol{B} \\cdot \\mathrm{d} \\boldsymbol{S}=0$$真空磁场的安培环路定理：在磁场中，磁感应强度沿任何闭合路径的环流，等于这个闭合路径所围绕的各个电流之代数和的 $\\mu_0$ 倍。（磁场是非保守力场、无势场）$$\\oint_{l} \\boldsymbol{B} \\cdot \\mathrm{d} l=\\mu_{0} \\sum_{i} I_{i}$$由于磁感应强度的环流一般不为0，所以磁场是非保守力场或无势场 磁场对载流导线的作用：安培定律$$d\\vec{F}=Id\\vec{l}\\times \\vec{B}$$ 方向：右手螺旋法则或左手定则 均匀磁场载流线圈所受力矩$$\\vec{M}=NI\\vec{S}\\times\\vec{B}=\\vec{p}_{\\rm m}\\times \\vec{B}$$ 其中 $\\vec{p}_{\\mathrm{m}}=N I \\vec{S}$ 为载流线圈的磁矩。 载流线圈的正法线方向：通过右手螺旋法则确定 形成一个印象：磁场的作用总是使载流线圈的正法线方向扭到磁场的方向上来 磁场对运动电荷的作用力：洛伦兹力洛伦兹力：点电荷在磁场中运动时所受到的磁场的作用力。$$\\vec{F}_{\\rm m}=q\\vec{v}\\times\\vec{B}$$ 记忆：磁场B在最后面，都用右手螺旋法则 洛伦兹力永远不做功 汤姆逊实验：通过加速电场和偏转磁场来测定电子比荷 $e/m$ 质谱仪：原理和上面类似 霍尔效应：载流子同时受到电场和磁场的作用后达到平衡，电场方向出现电势差 磁介质有磁介质时的磁场：$B=B_0+B’$ 相对磁导率（$\\mu_{\\rm r}$） 弱磁物质：$B’\\ll B_0$ 顺磁质：$B&gt;B_0$ 逆磁质：$B&lt;B_0$ 强磁物质（铁磁质）：$B’\\gg B_0$ 软磁材料：矫顽力较小，易于磁化和退磁 硬磁材料：矫顽力很大 无限大均匀磁介质中的毕奥-萨伐尔定律：$$d\\vec{B}=\\dfrac{\\mu_{0}\\mu_{\\rm r}}{4 \\pi} \\dfrac{I \\mathrm{d} l \\sin (\\mathrm{d} l, \\boldsymbol{r})}{r^{2}}=\\dfrac{\\mu}{4\\pi} \\dfrac{Id\\vec{l}\\times \\vec{r}}{r^3}$$ 磁介质的性质方程：$$\\vec{B}=\\mu \\vec{H}$$$\\vec{H}$ 为磁场强度矢量 和电介质中区别：$\\vec{D}=\\varepsilon\\vec{E}$ 注意： 在弱磁物质中 $\\mu$ 为常数，但在强磁物质（铁磁质）中，$\\mu$ 不是恒量，$B$ 值总是落后于 $H$ 值的变化，具有磁滞特性。 铁磁质加温到居里点会变成顺磁质。 以上两点可用磁畴理论来解释。 有磁介质时的磁场安培环路定理：$$\\oint_l \\vec{H}\\cdot d\\vec{l}=\\sum_{\\rm i内} I_{\\rm i}$$ 作用：磁介质有对称性时求 $\\vec{H}$，然后求 $\\vec{B}$ 电磁感应电磁感应现象：闭合导体回路中的磁通量随时间发生改变时，回路中就出现电流 楞次定律：闭合回路中感应电流的流向，总是企图使感应电流本身所产生的通过回路面积的磁通量，去抵消或者补偿引起感应电流的磁通量的改变。（来拒去留） 法拉第电磁感应定律：感应电动势：$$\\mathscr{E}=-\\dfrac{d(N\\varPhi_{\\rm m})}{dt}=-\\dfrac{d\\varPsi}{dt}$$ 动生电动势：$\\mathscr{E}=\\int_{l}\\vec{E}{动生}\\cdot d\\vec{l}=\\int{l}(\\vec{v}\\times\\vec{B})\\cdot d\\vec{l}$ 根源：洛伦兹力（一种非静电力） 也可假想有一固定线框，用法拉第电磁感应定律来计算 感生电动势：$\\mathscr{E}=\\oint_{l} \\vec{E}{感生}\\cdot d\\vec{l}=-\\iint{S} \\dfrac{\\part \\vec{B}}{\\part t}\\cdot d\\vec{S}$ 根源：变化磁场产生的感生电场（涡旋电场） 自感电动势：由于回路中的电流所引起的磁通量变化而在回路自身中激起的电动势 $\\varPsi_{\\rm m}=Li$，$L$ 为自感，单位为亨利（$H$） $\\mathscr{E}_{L}=-L \\dfrac{\\mathrm{d} i}{\\mathrm{~d} t}$ 互感电动势：两个载流回路互相激起的感应电动势 $\\left.\\begin{array}{l}\\varPsi_{\\mathrm{m} 21}=M i_{1} \\ \\varPsi_{\\mathrm{m} 12}=M i_{2}\\end{array}\\right}$，$M$ 为互感 $\\mathscr{E}{21}=-\\dfrac{\\mathrm{d} \\varPsi{\\mathrm{m} 21}}{\\mathrm{d} t}=-M \\dfrac{\\mathrm{d} i_{1}}{\\mathrm{d} t}$，$\\mathscr{E}{12}=-\\dfrac{\\mathrm{d} \\varPsi{\\mathrm{m} 12}}{\\mathrm{d} t}=-M \\dfrac{\\mathrm{d} i_{2}}{\\mathrm{d} t}$ $M=k\\sqrt{L_1L_2}$，耦合系数 $k$ 满足 $0\\le k \\le 1$ 感生电场的环流不为 0，故为非保守力场，其电场线闭合 磁场的能量磁场能量体密度$$w_{\\mathrm{m}}=\\frac{W_{\\mathrm{m}}}{\\tau}=\\frac{B^{2}}{2 \\mu}=\\frac{1}{2} B H=\\frac{\\mu}{2} H^{2}$$总磁场能量$$W_{\\mathrm{m}}=\\dfrac{1}{2}LI^2=\\iiint_{\\mathrm{V}} \\frac{B^{2}}{2 \\mu} \\mathrm{d} \\tau$$ 注意只在磁介质中积分 可用来算自感 $L$ 位移电流电位移通量：$$\\Phi_{\\mathrm{e}}=\\iint_{S} D \\cdot \\mathrm{d} S$$位移电流：$$I_{\\mathrm{d}}=\\frac{\\mathrm{d} \\Phi_{\\mathrm{e}}}{\\mathrm{d} t}$$根据安培环路定理，有$$\\oint_{l} \\boldsymbol{H}^{(2)} \\cdot \\mathrm{d} \\boldsymbol{l}=\\iint_{S} \\frac{\\partial \\boldsymbol{D}}{\\partial t} \\cdot \\mathrm{d} \\boldsymbol{S}$$ 麦克斯韦方程组$$\\begin{array}{c}\\oiint_{S} D \\cdot \\mathrm{d} \\boldsymbol{S}=\\sum_{i} q_{i} \\\\oint_{l} \\boldsymbol{E} \\cdot \\mathrm{d} \\boldsymbol{l}=-\\iint_{S} \\dfrac{\\partial \\boldsymbol{B}}{\\partial t} \\cdot \\mathrm{d} \\boldsymbol{S} \\\\oiint_{S} \\boldsymbol{B} \\cdot \\mathrm{d} \\boldsymbol{S}=0 \\\\oint_{l} \\boldsymbol{H} \\cdot \\mathrm{d} \\boldsymbol{l}=\\sum_{i} I_{i}+\\iint_{S} \\dfrac{\\partial \\boldsymbol{D}}{\\partial t} \\cdot \\mathrm{d} S\\end{array}$$ 物质方程$$\\begin{array}{l}D=\\varepsilon E \\B=\\mu H \\j=\\gamma E\\end{array}$$ 振动 波简谐运动 简谐运动的定义 运动规律满足$$\\frac{\\mathrm{d}^{2} x}{\\mathrm{~d} t^{2}}+\\omega^{2} x=0$$的振动，称为简谐运动 简谐运动的表达式 $$\\begin{array}{l}x=A \\cos (\\omega t+\\varphi) \\v=\\dfrac{\\mathrm{d} x}{\\mathrm{d} t}=-\\omega A \\sin (\\omega t+\\varphi) \\a=\\dfrac{\\mathrm{d} v}{\\mathrm{d} t}=-\\omega^{2} A \\cos (\\omega t+\\varphi)\\end{array}$$ 振幅和初相$$\\begin{array}{l}A=\\sqrt{x_{0}^{2}+\\left(\\dfrac{v_{0}}{\\omega}\\right)^{2}} \\\\varphi=\\arctan \\left(-\\dfrac{v_{0}}{\\omega x_{0}}\\right)\\end{array}$$ 简谐运动的能量$$E=\\dfrac{1}{2}kA^2=\\dfrac{1}{2}m\\omega^2A^2$$ 简谐运动的合成 拍两个同方向、同频率简谐运动的合成 旋转矢量图 合振动的振动表达式$$x=A \\cos (\\omega t+\\varphi)$$其中$$A=\\sqrt{A_{1}^{2}+A_{2}^{2}+2 A_{1} A_{2} \\cos \\left(\\varphi_{2}-\\varphi_{1}\\right)}$$$$\\tan \\varphi=\\frac{A_{1} \\sin \\varphi_{1}+A_{2} \\sin \\varphi_{2}}{A_{1} \\cos \\varphi_{1}+A_{2} \\cos \\varphi_{2}}$$ 两个同方向、不同频率简谐运动的合成 拍$$\\begin{aligned}x &amp;=A \\cos \\left(\\omega_{1} t+\\varphi\\right)+A \\cos \\left(\\omega_{2} t+\\varphi\\right) \\&amp;=2 A \\cos \\left(\\frac{\\omega_{2}-\\omega_{1}}{2} t\\right) \\cos \\left(\\frac{\\omega_{2}+\\omega_{1}}{2} t+\\varphi\\right)\\end{aligned}$$ 两个互相垂直、同频率的简谐运动的合成 合振动的振动表达式 $$\\frac{x^{2}}{A_{1}^{2}}+\\frac{y^{2}}{A_{2}^{2}}-\\frac{2 x y}{A_{1} A_{2}} \\cos \\left(\\varphi_{2}-\\varphi_{1}\\right)=\\sin ^{2}\\left(\\varphi_{2}-\\varphi_{1}\\right)$$ 图形 椭圆或直线 两个互相垂直、不同频率的简谐运动的合成 李萨如图形 阻尼振动 振动表达式$$\\frac{\\mathrm{d}^{2} x}{\\mathrm{d} t^{2}}+2 \\beta \\frac{\\mathrm{d} x}{\\mathrm{d} t}+\\omega_{0}^{2} x=0$$其中 $\\omega_{0}^{2}=\\dfrac{k}{m}$，$2 \\beta=\\dfrac{\\gamma}{m}$ 微分方程的解 当阻尼较小，即 $\\beta^2&lt;\\omega_0^2$ 时$$x(t)=A \\mathrm{e}^{-\\beta t} \\cos (\\omega t+\\varphi)$$ 当阻尼较大，即 $\\beta^2&gt;\\omega_0^2$ 时$$x(t)=c_{1} \\mathrm{e}^{-\\left(\\beta-\\sqrt{\\beta^{2}-\\omega_{0}^{2}}\\right) t}+c_{2} \\mathrm{e}^{-\\left(\\beta+\\sqrt{\\beta^{2}-\\omega_{0}^{2}}\\right) t}$$ 当 $\\beta=\\omega_0$ 时$$x(t)=(c_1+c_2x) {\\mathrm e}^{-\\beta t}$$ 受迫振动 振动表达式$$\\frac{\\mathrm{d}^{2} x}{\\mathrm{d} t^{2}}+2 \\beta \\frac{\\mathrm{d} x}{\\mathrm{d} t}+\\omega_{0}^{2} x=h \\cos p t$$其中，$\\omega_{0}^{2}=\\dfrac{k}{m}$，$2 \\beta=\\dfrac{\\gamma}{m} $，$h=\\dfrac{H}{m}$ 方程的解（$\\beta^2&lt;\\omega_0^2$）$$x=A \\mathrm{e}^{-\\beta t} \\cos (\\omega t+\\varphi)+B \\cos \\left(p t+\\varphi_{\\mathrm{p}}\\right)$$其中，$B=\\dfrac{h}{\\sqrt{\\left(\\omega_{0}^{2}-p^{2}\\right)^{2}+4 \\beta^{2} p^{2}}}$，$\\varphi_{\\mathrm{p}}=\\arctan \\dfrac{-2 \\beta p}{\\omega_{0}^{2}-p^{2}}$ 共振角频率$$\\omega_{\\mathrm{r}}=\\sqrt{\\omega_{0}^{2}-2 \\beta^{2}}$$共振振幅$$B_{\\mathrm{r}}=\\frac{h}{2 \\beta \\sqrt{\\omega_{0}^{2}-\\beta^{2}}}$$ 机械波 机械波产生的条件： 要有作机械振动的物体（波源） 要有能够传播这种机械振动的弹性介质 波动过程就是振动相位的传播过程 波的类型 横波：质元振动方向与传播方向相垂直 横波传播时，介质要发生切向形变，液体和气体不能承受切变，因此只有固体能传播横波 纵波：质元振动方向与传播方向相一致 波的特征量：波速、波频、波长 三者之间的关系 $$u=\\nu \\lambda$$ 波速的计算 固态介质中 横波：$u=\\sqrt{\\dfrac{G}{\\rho}}$，或 $u=\\sqrt{\\dfrac{T}{\\mu}}$（在拉紧的细绳中） 纵波：$u=\\sqrt{\\dfrac{E}{\\rho}}$（近似） 其中，$G$：切变模量；$E$：弹性模量；$\\mu$：质量线密度；$\\rho$：密度 液体和气体中 纵波：$u=\\sqrt{\\dfrac{B}{\\rho}}$ 其中，$B$：体积模量 平面简谐波 波函数（波动表达式）$$y=A \\cos \\left[\\omega\\left(t-\\frac{x}{u}\\right)+\\varphi\\right]$$ $$y=A \\cos \\left[2 \\pi\\left(\\frac{t}{T}-\\frac{x}{\\lambda}\\right)+\\varphi\\right]$$ $$y=A \\cos \\left[2 \\pi\\left(\\nu t-\\frac{x}{\\lambda}\\right)+\\varphi\\right]$$ 波具有时间和空间上的周期性 平面简谐波的波函数定量地表达了行波的传播情况 平面波的波动方程（平面简谐波的微分方程）$$\\frac{\\partial^{2} y}{\\partial x^{2}}=\\frac{1}{u^{2}} \\frac{\\partial^{2} y}{\\partial t^{2}}$$ 能量密度$$w=\\frac{\\mathrm{d} E}{\\mathrm{~d} V}=\\rho A^{2} \\omega^{2} \\sin ^{2} \\omega\\left(t-\\frac{x}{u}\\right)$$ 平均能量密度$$\\bar{w}=\\frac{1}{T} \\int_{0}^{T} \\rho A^{2} \\omega^{2} \\sin ^{2} \\omega\\left(t-\\frac{x}{u}\\right) \\mathrm{d} t=\\frac{1}{2} \\rho A^{2} \\omega^{2}$$ 注意：波动中质元所拥有的能量与质点作简谐运动所拥有的能量不同：作简写运动的质点 是孤立系统，机械能守恒，$E_{\\rm k}$、$E_{\\rm p}$ 变化步调相反；而波动中的介质质元是非孤立系统，机械能不守恒，$E_{\\rm k}$、$E_{\\rm p}$ 变化步调相同。 能流密度（波印廷矢量、波的强度）：单位时间内通过垂直于波传播方向的单位面积上的平均能流$${\\boldsymbol I}=\\frac{1}{2} \\rho A^{2} \\omega^{2} \\boldsymbol{u}$$ 声波的能流密度为声强，光的能流密度为光强。 波的衍射、反射和折射 惠更斯原理：介质中任意波面上的各点，都可以看做是发射子波的波源，其后任意时刻，这些子波响应的波前的包迹就是新的波前。 波的衍射（或绕射）现象：波在传播过程中遇到障碍物时，波线发生弯曲并能绕过障碍物边缘的现象。 $d/\\lambda$ 越大，衍射现象越显著。 波的反射定律：反射角等于入射角，且入射角、法线和反射线在同一平面内。 波的折射定律：入射角的正弦与折射角的正弦之比等于第一种介质与第二种介质中的波速之比，即为一恒量，此恒量 $n_{21}$ 称为第二介质对第一介质的相对折射率；入射线、折射线和分界面法线在同一平面内。$$\\frac{\\sin i}{\\sin r}=\\frac{u_{1}}{u_{2}}=n_{21}=\\frac{n_2}{n_1}$$其中，$n_1$ 和 $n_2$ 为介质的绝对折射率（简称折射率）。 波的干涉 波的叠加原理：由于波具有传播的独立性，当几列波在介质中同时传播到空间某一区域内，该区域内任一点处质元的振动，为各列波单独存在时在该点所引起质元振动的位移之矢量和。 波的干涉现象：若两个波源，满足频率相同、振动方向相同、相位相同（或相位差恒定）的条件，则它们所发出的波在介质中相遇而叠加时，在相遇处的质元便同时参与这两个具有恒定相位差的同频率、同方向的振动。对两列波相遇区域内的各质元来说，其相位差不尽相同，因而这两列波在介质中相遇时，就出现某些点处的质元振动始终加强，而另一些点处的质元振动始终减弱的现象。这种现象称为波的干涉现象。 上述条件称为相干条件，满足相干条件的两个波源称为相干波源，由相干波源发出的波称为相干波。 合振幅 $A$ 最大和最小的条件$$\\delta=r_{1}-r_{2}=\\left{\\begin{array}{ll}\\pm k \\lambda, &amp; A=A_{1}+A_{2} \\\\pm(2 k+1) \\dfrac{\\lambda}{2}, &amp; A=\\left|A_{1}-A_{2}\\right|\\end{array}\\right.$$ 驻波：如果两列相干波振幅相同，在同一直线上沿相反方向传播，那么会形成一种特殊的干涉现象，即驻波。 驻波函数$$y=\\left(2 A \\cos \\frac{2 \\pi x}{\\lambda}\\right) \\cos \\omega t$$ 波腹和波节的位置$$x_{腹}=\\frac{k \\lambda}{2},\\quadx_{节}=\\frac{2 k+1}{4} \\lambda \\quad(k=0,\\pm 1,\\pm 2, \\cdots)$$ 驻波的能流密度$${\\boldsymbol I}=0$$ 半波损失：反射波有 $\\pi$ 的相位突变 条件：波从波疏介质传到波密介质（$\\rho u$ 较大的介质） 若波从波密介质传到波疏介质，则没有相位跃变，反射处为波腹","link":"/2021/02/17/1417.html"},{"title":"Latex 笔记","text":"一些技巧1234\\dfrac{}{} % 在行内使用行间大小显示分式，d和t是什么意思？\\tfrac{}{} % 在行间使用行内大小显示分式\\left\\{ \\right. % 多行大左括号\\left\\. \\right\\} % 多行大右括号 $$\\phi \\quad \\Phi \\quad \\varphi \\quad \\varPhi$$ 1\\phi \\Phi \\varphi \\varPhi % 注意这四个的区别，P大写说明字母大写，var是variable，用来表示变量","link":"/2021/03/06/2147.html"},{"title":"CSS 学习笔记","text":"简介 CSS 指层叠样式表 (Cascading Style Sheets) 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题 语法CSS 规则由两个主要的部分构成： 选择器：需要改变样式的 HTML 元素 一条或多条声明：由一个属性和一个值组成 1p {color:red;text-align:center;} /*这是个注释*/ 或 123456p{ color:red; /*这是个注释*/ text-align:center;} 选择器 分组选择器 1234h1,h2,p{ color:green;} 嵌套选择器 12345678910111213141516p{ color:blue; text-align:center;}.marked{ background-color:red;}.marked p{ color:white;}p.marked{ text-decoration:underline;} p{ }: 为所有 p 元素指定一个样式。 .marked{ }: 为所有 class=”marked” 的元素指定一个样式。 .marked p{ }: 为所有 class=”marked” 元素内的 p 元素指定一个样式。 p.marked{ }: 为所有 class=”marked” 的 p 元素指定一个样式。 id 和 classidid 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。 以下的样式规则应用于元素属性 id=”para1”: 12345#para1{ text-align:center; color:red;} class（类）1p.center {text-align:center;} /* center就是p的类 */ 伪类CSS伪类是用来添加一些选择器的特殊效果。 伪类的语法： 1selector:pseudo-class {property:value;} CSS类也可以使用伪类： 1selector.class:pseudo-class {property:value;} 选择器 示例 示例说明 :checked input:checked 选择所有选中的表单元素 :disabled input:disabled 选择所有禁用的表单元素 :empty p:empty 选择所有没有子元素的p元素 :enabled input:enabled 选择所有启用的表单元素 :first-of-type p:first-of-type 选择的每个 p 元素是其父元素的第一个 p 元素 :in-range input:in-range 选择元素指定范围内的值 :invalid input:invalid 选择所有无效的元素 :last-child p:last-child 选择所有p元素的最后一个子元素 :last-of-type p:last-of-type 选择每个p元素是其母元素的最后一个p元素 :not(selector) :not(p) 选择所有p以外的元素 :nth-child(n) p:nth-child(2) 选择所有 p 元素的父元素的第二个子元素 :nth-last-child(n) p:nth-last-child(2) 选择所有p元素倒数的第二个子元素 :nth-last-of-type(n) p:nth-last-of-type(2) 选择所有p元素倒数的第二个为p的子元素 :nth-of-type(n) p:nth-of-type(2) 选择所有p元素第二个为p的子元素 :only-of-type p:only-of-type 选择所有仅有一个子元素为p的元素 :only-child p:only-child 选择所有仅有一个子元素的p元素 :optional input:optional 选择没有”required”的元素属性 :out-of-range input:out-of-range 选择指定范围以外的值的元素属性 :read-only input:read-only 选择只读属性的元素属性 :read-write input:read-write 选择没有只读属性的元素属性 :required input:required 选择有”required”属性指定的元素属性 :root root 选择文档的根元素 :target #news:target 选择当前活动#news元素(点击URL包含锚的名字) :valid input:valid 选择所有有效值的属性 :link a:link 选择所有未访问链接 :visited a:visited 选择所有访问过的链接 :active a:active 选择正在活动链接 :hover a:hover 把鼠标放在链接上的状态 :focus input:focus 选择元素输入后具有焦点 :first-letter p:first-letter 选择每个 元素的第一个字母 :first-line p:first-line 选择每个 元素的第一行 :first-child p:first-child 选择器匹配属于任意元素的第一个子元素的 元素 :before p:before 在每个元素之前插入内容 :after p:after 在每个元素之后插入内容 :lang(language) p:lang(it) 为元素的lang属性选择一个开始值 CSS 样式表外部样式表123&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;&lt;/head&gt; 内部样式表1234567&lt;head&gt;&lt;style&gt;hr {color:sienna;}p {margin-left:20px;}body {background-image:url(&quot;images/back40.gif&quot;);}&lt;/style&gt;&lt;/head&gt; 内联样式表1&lt;p style=&quot;color:sienna;margin-left:20px&quot;&gt;这是一个段落。&lt;/p&gt; 多重样式优先级（内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式 注意：如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。 属性背景123h1 {background-color:#6495ed;}p {background-color:#e0ffff;}div {background-color:#b0c4de;} Property 描述 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。 background-repeat 设置背景图像是否及如何重复。 文本12345678910111213141516171819/* 文本颜色 */body {color:red;}h1 {color:#00ff00;}h2 {color:rgb(255,0,0);}/* 文本对齐方式 */h1 {text-align:center;}p.date {text-align:right;}p.main {text-align:justify;}/* 文本修饰 */a {text-decoration:none;}h1 {text-decoration:overline;}h2 {text-decoration:line-through;}h3 {text-decoration:underline;}/* 文本大小写 */p.uppercase {text-transform:uppercase;}p.lowercase {text-transform:lowercase;}p.capitalize {text-transform:capitalize;}/* 文本缩进 */p {text-indent:50px;} 属性 描述 color 设置文本颜色 direction 设置文本方向。 letter-spacing 设置字符间距 line-height 设置行高 text-align 对齐元素中的文本 text-decoration 向文本添加修饰 text-indent 缩进元素中文本的首行 text-shadow 设置文本阴影 text-transform 控制元素中的字母 unicode-bidi 设置或返回文本是否被重写 vertical-align 设置元素的垂直对齐 white-space 设置元素中空白的处理方式 word-spacing 设置字间距 字体1234567p.normal {font-style:normal;}p.italic {font-style:italic;}p.oblique {font-style:oblique;}body {font-size:100%;}h1 {font-size:2.5em;}h2 {font-size:1.875em;}p {font-size:0.875em;} Property 描述 font 在一个声明中设置所有的字体属性 font-family 指定文本的字体系列 font-size 指定文本的字体大小 font-style 指定文本的字体样式 font-variant 以小型大写字体或者正常字体显示文本。 font-weight 指定字体的粗细。 链接1234a:link {color:#000000;} /* 未访问链接*/a:visited {color:#00FF00;} /* 已访问链接 */a:hover {color:#FF00FF;} /* 鼠标移动到链接上 */a:active {color:#0000FF;} /* 鼠标点击时 */ 列表12345ul.a {list-style-type: circle;}ul.b {list-style-type: square;} ol.c {list-style-type: upper-roman;}ol.d {list-style-type: lower-alpha;} 可以按顺序设置如下属性： list-style-type list-style-position list-style-image 如果上述值丢失一个，其余仍在指定的顺序，就没关系。 表格12345678table{ border-collapse:collapse;}table,th, td{ border: 1px solid black;} 盒子![CSS box-model](E:\\Typora_img\\CSS 学习笔记\\box-model.gif) Margin(外边距) - 清除边框外的区域，外边距是透明的。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，内边距是透明的。 Content(内容) - 盒子的内容，显示文本和图像。 123456div { width: 300px; border: 25px solid green; padding: 25px; margin: 25px;} 尺寸 属性 描述 height 设置元素的高度。 line-height 设置行高。 max-height 设置元素的最大高度。 max-width 设置元素的最大宽度。 min-height 设置元素的最小高度。 min-width 设置元素的最小宽度。 width 设置元素的宽度。 可见性1234h1.hidden {visibility:hidden;} /* 会占空间 */h1.hidden {display:none;} /* 不会占空间 */li {display:inline;} /* 把列表项显示为内联元素 */span {display:block;} /* 把span元素作为块元素 */ 定位position 属性的五个值： static 1234div.static { position: static; border: 3px solid #73AD21;} relative 12345h2.pos_left{ position:relative; left:-20px;} fixed 123456p.pos_fixed{ position:fixed; top:30px; right:5px;} absolute 123456h2{ position:absolute; left:100px; top:150px;} sticky 1234567div.sticky { position: -webkit-sticky; /* Safari */ position: sticky; top: 0; background-color: green; border: 2px solid #4CAF50;}","link":"/2021/03/09/2146.html"},{"title":"JavaScript 学习笔记","text":"简介JavaScript 是 web 开发人员必须学习的 3 门语言中的一门： HTML 定义了网页的内容 CSS 描述了网页的布局 JavaScript 网页的行为 12345&lt;script&gt;document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;);document.write(&quot;&lt;p&gt;这是一个段落。&lt;/p&gt;&quot;);&lt;/script&gt;&lt;button type=&quot;button&quot; onclick=&quot;alert('欢迎!')&quot;&gt;点我!&lt;/button&gt; JavaScript 是脚本语言，浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。 用法HTML 中的脚本必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间。 脚本可被放置在 HTML 页面的 &lt;body&gt; 和 &lt;head&gt; 部分中。 通常的做法是把函数放入 &lt;head&gt; 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;script&gt;function myFunction(){ document.getElementById(&quot;demo&quot;).innerHTML=&quot;我的第一个 JavaScript 函数&quot;;}&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的 Web 页面&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;一个段落。&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 或者将 js 外置 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的 Web 页面&lt;/h1&gt;&lt;p id=&quot;demo&quot;&gt;一个段落。&lt;/p&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;myFunction 保存在名为 &quot;myScript.js&quot; 的外部文件中。&lt;/p&gt;&lt;script src=&quot;myScript.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; myScript.js 文件代码如下： 1234function myFunction(){ document.getElementById(&quot;demo&quot;).innerHTML=&quot;我的第一个 JavaScript 函数&quot;;} 语法和 C 语言差不多。变量不用定义数据类型。 字面量12345678910// 数字（Number）字面量 可以是整数或者是小数，或者是科学计数(e)3.141001123e5// 字符串（String）字面量可以使用单引号或双引号&quot;John Doe&quot;'John Doe'// 表达式字面量用于计算5 + 65 * 10 123[40, 100, 1, 5, 25, 10] // 数组（Array）字面量{firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:50, eyeColor:&quot;blue&quot;} // 对象（Object）字面量。类似 C 语言的结构体function myFunction(a, b) { return a * b;} // 函数（Function）字面量 变量JavaScript 使用关键字 var 来声明变量， 使用等号来为变量赋值： 1234567891011var x, y;x = 5;y = 6;// 或var y = 22;// 或var lastname = &quot;Doe&quot;, age = 30, job = &quot;carpenter&quot;;// 或var a = &quot;Doe&quot;,b = 30,c = &quot;carpenter&quot;; 变量可以通过变量名访问。在指令式语言中，变量通常是可变的。字面量是一个恒定的值。 如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。 另外，可以将变量声明放后面，即先用再声明 当您声明新变量时，可以使用关键词 “new” 来声明其类型： 12345var carname=new String;var x= new Number;var y= new Boolean;var cars= new Array;var person= new Object; 作用域在 JavaScript 函数内部声明的变量（使用 var）是局部变量，所以只能在函数内部访问它。 在函数外声明的变量是全局变量，网页上的所有脚本和函数都能访问它。 生存期JavaScript 变量的生命期从它们被声明的时间开始。 局部变量会在函数运行以后被删除。 全局变量会在页面关闭后被删除。 在 HTML 中, 全局变量是 window 对象: 所有数据变量都属于 window 对象。 你的全局变量，或者函数，可以覆盖 window 对象的变量或者函数。局部变量，包括 window 对象可以覆盖全局变量和函数。 运算符 类型 实例 赋值，算术和位运算符 = + - * / 条件，比较及逻辑运算符 == != &lt; &gt; 语句分隔用分号来结束语句，也可以不加。可以放一行。 关键字 abstract else instanceof super boolean enum int switch break export interface synchronized byte extends let this case false long throw catch final native throws char finally new transient class float null true const for package try continue function private typeof debugger goto protected var default if public void delete implements return volatile do import short while double in static with 注释和 C 语言一样，// 单行注释，/* 和 */ 多行注释。 数据类型可以用 typeof 函数来查看变量的数据类型 字符串（string） 数字（number） NaN 也是 number 布尔（boolean） 对象（object） 数组（array）、Date() 都是 object null 也是 object 函数（function） 符号（symbol） 未定义（undefined） 注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。 constructor 属性返回所有 JavaScript 变量的构造函数，因此你可以使用 constructor 属性来查看对象是否为数组 (包含字符串 “Array”)： 1234567&quot;John&quot;.constructor // 返回函数 String() { [native code] }(3.14).constructor // 返回函数 Number() { [native code] }false.constructor // 返回函数 Boolean() { [native code] }[1,2,3,4].constructor // 返回函数 Array() { [native code] }{name:'John', age:34}.constructor // 返回函数 Object() { [native code] }new Date().constructor // 返回函数 Date() { [native code] }function () {}.constructor // 返回函数 Function(){ [native code] } 不同数据类型的变量定义： 12345678910111213var bool = true;var length = 16; // Number 通过数字字面量赋值var points = x * 10; // Number 通过表达式字面量赋值var lastName = &quot;Johnson&quot;; // String 通过字符串字面量赋值var cars = [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;]; // Array 通过数组字面量赋值var person = {firstName:&quot;John&quot;, lastName:&quot;Doe&quot;}; // Object 通过对象字面量赋值length = null; // 清空变量，类型变为对象length = undefined; // 彻底清空，恢复到未定义状态，类型为未定义// 一元运算符`+`的用法var y = &quot;5&quot;; // y 是一个字符串var z = &quot;fsad&quot; // z 也是一个字符串var yy = + y; // yy 是一个数字var zz = + z: // zz 是一个数字 NaN 引号中的引号全部为字符串，也可以加转义符号 \\，效果一样 JavaScript 拥有动态数据类型。这意味着相同的变量可用作不同的类型： 123var x; // x 为 undefinedvar x = 5; // 现在 x 为数字var x = &quot;John&quot;; // 现在 x 为字符串 函数123function myFunction(a, b) { return a * b; // 返回 a 乘以 b 的结果} 其他 大小写敏感 使用 Unicode 字符集 JavaScript 中，常见的是驼峰法的命名规则，如 lastName (而不是lastname) JavaScript 会忽略多余的空格。您可以向脚本添加空格，来提高其可读性 用 \\ 换行 输出 使用 window.alert() 弹出警告框。 使用 document.write() 方法将内容写到 HTML 文档中。 如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。 使用 innerHTML 写入到 HTML 元素。 使用 console.log() 写入到浏览器的控制台。 变量-对象 在 JavaScript 中，对象是非常重要的，当你理解了对象，就可以了解 JavaScript 。 JavaScript 对象是变量的容器。 定义 JavaScript 对象可以跨越多行，空格跟换行不是必须的： 12345678910var person = { firstName:&quot;John&quot;, lastName:&quot;Doe&quot;, age:50, eyeColor:&quot;blue&quot; fullName : function() // 对象方法 { return this.firstName + &quot; &quot; + this.lastName; }}; 对象属性123person.lastName;// 或person[&quot;lastName&quot;]; 对象方法对象的方法定义了一个函数，并作为对象的属性存储。 对象方法通过添加 () 调用 (作为一个函数)。 该实例 12name = person.fullName(); // 访问 person 对象的 fullName() 方法namefunc = person.fullName; // 访问 person 对象的 fullName 属性（一个字符串） HTML 事件HTML 事件可以是浏览器行为，也可以是用户行为。 以下是 HTML 事件的实例： HTML 页面完成加载 HTML input 字段改变时 HTML 按钮被点击 例： 1234&lt;button onclick=&quot;getElementById('demo').innerHTML=Date()&quot;&gt;现在的时间是?&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;!--或者在按钮本身上输出--&gt;&lt;button onclick=&quot;this.innerHTML=Date()&quot;&gt;现在的时间是?&lt;/button&gt; 常见的 HTML 事件 事件 描述 onchange HTML 元素改变 onclick 用户点击 HTML 元素 onmouseover 用户在一个HTML元素上移动鼠标 onmouseout 用户从一个HTML元素上移开鼠标 onkeydown 用户按下键盘按键 onload 浏览器已完成页面的加载 条件语句if else123456789101112if (condition1){ 当条件 1 为 true 时执行的代码}else if (condition2){ 当条件 2 为 true 时执行的代码}else{ 当条件 1 和 条件 2 都不为 true 时执行的代码} switch1234567891011switch(n){ case 1: 执行代码块 1 break; case 2: 执行代码块 2 break; default: 与 case 1 和 case 2 不同时执行的代码} 循环语句和 C 语言一样可以用 break 和 continue 语句。 for1234for (var i=0;i&lt;cars.length;i++){ document.write(cars[i] + &quot;&lt;br&gt;&quot;);} while1234while (条件){ // 需要执行的代码} 12345do{ // 需要执行的代码}while (条件); 标签1234567891011cars=[&quot;BMW&quot;,&quot;Volvo&quot;,&quot;Saab&quot;,&quot;Ford&quot;];list: // list就是一个标签{ document.write(cars[0] + &quot;&lt;br&gt;&quot;); document.write(cars[1] + &quot;&lt;br&gt;&quot;); document.write(cars[2] + &quot;&lt;br&gt;&quot;); break list; document.write(cars[3] + &quot;&lt;br&gt;&quot;); document.write(cars[4] + &quot;&lt;br&gt;&quot;); document.write(cars[5] + &quot;&lt;br&gt;&quot;); } 错误12345678try { ... // 异常的抛出 throw &quot;这是一个自定义错误&quot;} catch(err) { ... // 异常的捕获与处理} finally { ... // 结束处理。不论之前的 try 和 catch 中是否产生异常都会执行该代码块。} 123456789101112var txt=&quot;&quot;; function message() { try { adddlert(&quot;Welcome guest!&quot;); } catch(err) { txt=&quot;本页有一个错误。\\n\\n&quot;; txt+=&quot;错误描述：&quot; + err.message + &quot;\\n\\n&quot;; txt+=&quot;点击确定继续。\\n\\n&quot;; alert(txt); } } 调试方法一： 1234a = 5;b = 6;c = a + b;console.log(c); 方法二： 设置断点 方法三： 123var x = 15 * 5;debugger;document.getElementbyId(&quot;demo&quot;).innerHTML = x; 严格模式 “use strict” 指令只允许出现在脚本或函数的开头。 JSONJSON 简介 JSON 英文全称 JavaScript Object Notation JSON 是一种轻量级的数据交换格式。 JSON是独立的语言 * JSON 易于理解。 * JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。 文本可以被任何编程语言读取及作为数据格式传递。 12345{&quot;sites&quot;:[ {&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.runoob.com&quot;}, {&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;}, {&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;}]} JSON 格式在语法上与创建 JavaScript 对象代码是相同的。 由于它们很相似，所以 JavaScript 程序可以很容易的将 JSON 数据转换为 JavaScript 对象。 JSON 语法规则 数据为 键/值 对。 数据由逗号分隔。 大括号保存对象 方括号保存数组 例： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;为 JSON 字符串创建对象&lt;/h2&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var text = '{ &quot;sites&quot; : [' + '{ &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; },' + '{ &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; },' + '{ &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; } ]}'; obj = JSON.parse(text);document.getElementById(&quot;demo&quot;).innerHTML = obj.sites[1].name + &quot; &quot; + obj.sites[1].url;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 函数 描述 JSON.parse() 用于将一个 JSON 字符串转换为 JavaScript 对象。 JSON.stringify() 用于将 JavaScript 值转换为 JSON 字符串。 异步编程setTimeout1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;p&gt;回调函数等待 3 秒后执行。&lt;/p&gt;&lt;p id=&quot;demo1&quot;&gt;&lt;/p&gt;&lt;p id=&quot;demo2&quot;&gt;&lt;/p&gt;&lt;script&gt;setTimeout(function () { document.getElementById(&quot;demo1&quot;).innerHTML=&quot;RUNOOB-1!&quot;;}, 3000);document.getElementById(&quot;demo2&quot;).innerHTML=&quot;RUNOOB-2!&quot;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 异步 AJAX1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;strong&gt;以下内容是通过异步请求获取的：&lt;/strong&gt;&lt;/p&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var xhr = new XMLHttpRequest(); xhr.onload = function () { // 输出接收到的文字数据 document.getElementById(&quot;demo&quot;).innerHTML=xhr.responseText;} xhr.onerror = function () { document.getElementById(&quot;demo&quot;).innerHTML=&quot;请求出错&quot;;} // 发送异步 GET 请求xhr.open(&quot;GET&quot;, &quot;https://www.runoob.com/try/ajax/ajax_info.txt&quot;, true);xhr.send();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Promise1234567891011121314function print(delay, message) { return new Promise(function (resolve, reject) { setTimeout(function () { console.log(message); resolve(); }, delay); });}print(1000, &quot;First&quot;).then(function () { return print(4000, &quot;Second&quot;);}).then(function () { print(3000, &quot;Third&quot;);}); async await123456async function asyncFunc() { await print(1000, &quot;First&quot;); await print(4000, &quot;Second&quot;); await print(3000, &quot;Third&quot;);}asyncFunc();","link":"/2021/03/09/2144.html"},{"title":"XML 学习笔记","text":"简介XML 指可扩展标记语言（eXtensible Markup Language）。 XML 是一种很像HTML的标记语言。 XML 被设计用来传输和存储数据，而 HTML 被设计用来显示数据。 XML 很重要，也很容易学习。 XML 被设计为具有自我描述性。 XML 是 W3C 的推荐标准。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;note&gt;&lt;!-- This is a comment --&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; XML 语言没有预定义的标签。 HTML 中使用的标签都是预定义的。HTML 文档只能使用在 HTML 标准中定义过的标签（如 、 等等）。 语法 XML 文档必须包含根元素。该元素是所有其他元素的父元素。 XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。 所有的元素都可以有子元素 XML 声明文件的可选部分，如果存在需要放在文档的第一行 所有的 XML 元素都必须有一个关闭标签 在 HTML 中，某些元素不必有一个关闭标签，比如： 12&lt;p&gt;This is a paragraph.&lt;br&gt; XML 标签对大小写敏感 XML 属性值必须加引号（单引号、双引号均可） 1234&lt;note date=&quot;12/11/2007&quot;&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;/note&gt; &lt; 和 &amp; 非法，可用“实体引用”解决 实体引用 符号 含义 &amp;lt; &lt; less than &amp;gt; &gt; greater than &amp;amp; &amp; ampersand &amp;apos; ‘ apostrophe &amp;quot; “ quotation mark 注：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。 在 XML 中，文档中的空格不会被删减。 XML 以 LF 存储换行。 在 Windows 应用程序中，换行通常以一对字符来存储：回车符（CR）和换行符（LF）。 在 Unix 和 Mac OSX 中，使用 LF 来存储新行。 在旧的 Mac 系统中，使用 CR 来存储新行。 XML 元素必须遵循以下命名规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 可使用任何名称，没有保留的字词。 属性属性通常提供不属于数据组成部分的信息。在下面的实例中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要： 1&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt; 如果属性值本身包含双引号，您可以使用单引号，就像这个实例： 1&lt;gangster name='George &quot;Shotgun&quot; Ziegler'&gt; 或者您可以使用字符实体： 1&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt; XML 元素 vs. 属性请看这些实例： 1234&lt;person sex=&quot;female&quot;&gt;&lt;firstname&gt;Anna&lt;/firstname&gt;&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 12345&lt;person&gt;&lt;sex&gt;female&lt;/sex&gt;&lt;firstname&gt;Anna&lt;/firstname&gt;&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 在第一个实例中，sex 是一个属性。在第二个实例中，sex 是一个元素。这两个实例都提供相同的信息。 没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用元素吧。 属性难以阅读和维护。请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。 XML 文档验证DTD合法的 XML 文档是”形式良好”的 XML 文档，这也符合文档类型定义（DTD）的规则： 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE note SYSTEM &quot;Note.dtd&quot;&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; 在上面的实例中，DOCTYPE 声明是对外部 DTD 文件的引用。下面的段落展示了这个文件的内容。 XML SchemaW3C 支持一种基于 XML 的 DTD 代替者，它名为 XML Schema： 123456789101112&lt;xs:element name=&quot;note&quot;&gt;&lt;xs:complexType&gt;&lt;xs:sequence&gt;&lt;xs:element name=&quot;to&quot; type=&quot;xs:string&quot;/&gt;&lt;xs:element name=&quot;from&quot; type=&quot;xs:string&quot;/&gt;&lt;xs:element name=&quot;heading&quot; type=&quot;xs:string&quot;/&gt;&lt;xs:element name=&quot;body&quot; type=&quot;xs:string&quot;/&gt;&lt;/xs:sequence&gt;&lt;/xs:complexType&gt;&lt;/xs:element&gt; XML 渲染用 CSS 显示 XML1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;cd_catalog.css&quot;?&gt;&lt;CATALOG&gt;&lt;CD&gt;&lt;TITLE&gt;Empire Burlesque&lt;/TITLE&gt;&lt;ARTIST&gt;Bob Dylan&lt;/ARTIST&gt;&lt;COUNTRY&gt;USA&lt;/COUNTRY&gt;&lt;COMPANY&gt;Columbia&lt;/COMPANY&gt;&lt;PRICE&gt;10.90&lt;/PRICE&gt;&lt;YEAR&gt;1985&lt;/YEAR&gt;&lt;/CD&gt;&lt;CD&gt;&lt;TITLE&gt;Hide your heart&lt;/TITLE&gt;&lt;ARTIST&gt;Bonnie Tyler&lt;/ARTIST&gt;&lt;COUNTRY&gt;UK&lt;/COUNTRY&gt;&lt;COMPANY&gt;CBS Records&lt;/COMPANY&gt;&lt;PRICE&gt;9.90&lt;/PRICE&gt;&lt;YEAR&gt;1988&lt;/YEAR&gt;&lt;/CD&gt;...&lt;/CATALOG&gt; 使用 CSS 格式化 XML 不是常用的方法。W3C 推荐使用 XSLT。 使用 XSLT 显示 XML","link":"/2021/03/09/2142.html"},{"title":"SVG 学习笔记","text":"简介 SVG 意为可缩放矢量图形（Scalable Vector Graphics） SVG 使用 XML 格式定义图像 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 123456789101112&lt;html&gt;&lt;body&gt; &lt;h1&gt;My first SVG&lt;/h1&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;&lt;/svg&gt; &lt;/body&gt;&lt;/html&gt; 由于SVG是XML文件，SVG图像可以用任何文本编辑器创建，但它往往是与一个绘图程序一起使用，如 Inkscape，以更方便地创建SVG图像。 12345678&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot;&quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot; /&gt;&lt;/svg&gt; 第一行包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是”独立的”，或含有对外部文件的引用。standalone=”no” 意味着 SVG 文档会引用一个外部文件——在这里，是 DTD 文件。 第二和第三行引用了这个外部的 SVG DTD。该 DTD 位于 “http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;。该 DTD 位于 W3C，含有所有允许的 SVG 元素。 SVG 代码以 &lt;svg&gt; 元素开始，包括开启标签 &lt;svg&gt; 和关闭标签 &lt;/svg&gt; 。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。 SVG 的 &lt;circle&gt; 用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。r 属性定义圆的半径。 stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。 fill 属性设置形状内的颜色。我们把填充颜色设置为红色。 关闭标签的作用是关闭 SVG 元素和文档本身。 注：所有的开启标签必须有关闭标签！ SVG 在 HTML 中形状SVG有一些预定义的形状元素，可被开发者使用和操作： 矩形 &lt;rect&gt; 圆形 &lt;circle&gt; 椭圆 &lt;ellipse&gt; 线 &lt;line&gt; 折线 &lt;polyline&gt; 多边形 &lt;polygon&gt; 路径 &lt;path&gt; 矩形1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)&quot;/&gt;&lt;/svg&gt; 圆形1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;&lt;/svg&gt; 椭圆1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;ellipse cx=&quot;300&quot; cy=&quot;80&quot; rx=&quot;100&quot; ry=&quot;50&quot; style=&quot;fill:yellow;stroke:purple;stroke-width:2&quot;/&gt;&lt;/svg&gt; 直线1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot; style=&quot;stroke:rgb(255,0,0);stroke-width:2&quot;/&gt;&lt;/svg&gt; 多边形 polygon来自希腊。 “Poly” 意味 “many” ， “gon” 意味 “angle”. 12345&lt;!--三点法创建一个三角形--&gt;&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;200,10 250,190 160,210&quot; style=&quot;fill:lime;stroke:purple;stroke-width:1&quot;/&gt;&lt;/svg&gt; 多段线123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;polyline points=&quot;0,40 40,40 40,80 80,80 80,120 120,120 120,160&quot; style=&quot;fill:white;stroke:red;stroke-width:4&quot; /&gt;&lt;/svg&gt; 路径&lt;path&gt; 元素用于定义一个路径。 下面的命令可用于路径数据： M = move to L = line to H = horizontal line to V = vertical line to C = curve to（三次贝塞尔曲线） S = smooth curve to（光滑内塞尔曲线） Q = quadratic Bézier curve（二次贝塞尔曲线） T = smooth quadratic Bézier curve to（光滑二次贝塞尔曲线） A = elliptical Arc（椭圆弧） Z = close path 注意：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。 例： 123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;path d=&quot;M150 0 L75 200 L225 200 Z&quot; /&gt;&lt;/svg&gt; 输出效果： 内塞尔曲线（重点！） 参考：路径 - SVG | MDN (mozilla.org) 我们从稍微复杂一点的三次贝塞尔曲线C入手，三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数： 1C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy) 这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。如果你熟悉代数或者微积分的话，会更容易理解控制点，控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程。（文字描述不好，维基百科上有图示，更直观。）![img](E:\\Typora_img\\SVG 学习笔记=Cubic_Bezier_Curves.png) 123456789101112131415&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;190px&quot; height=&quot;160px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;path d=&quot;M10 10 C 20 20, 40 20, 50 10&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt; &lt;path d=&quot;M70 10 C 70 20, 120 20, 120 10&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt; &lt;path d=&quot;M130 10 C 120 20, 180 20, 170 10&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt; &lt;path d=&quot;M10 60 C 20 80, 40 80, 50 60&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt; &lt;path d=&quot;M70 60 C 70 80, 110 80, 110 60&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt; &lt;path d=&quot;M130 60 C 120 80, 180 80, 170 60&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt; &lt;path d=&quot;M10 110 C 20 140, 40 140, 50 110&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt; &lt;path d=&quot;M70 110 C 70 140, 110 140, 110 110&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt; &lt;path d=&quot;M130 110 C 120 140, 180 140, 170 110&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;&lt;/svg&gt; 上面的例子里，创建了9个三次贝塞尔曲线。有一点比较遗憾，标记控制点的代码会比较庞大，所以在这里舍弃了。（之前所有点都用circle标记，此处一样，只不过没把代码列出来）。如果你想更准确地控制它们，可以自己动手把他们画出来。图例上的曲线从左往右看，控制点在水平方向上逐渐分开，图例上的曲线从上往下看，控制点和曲线坐标之间离得越来越远。这里要注意观察，曲线沿着起点到第一控制点的方向伸出，逐渐弯曲，然后沿着第二控制点到终点的方向结束。 你可以将若干个贝塞尔曲线连起来，从而创建出一条很长的平滑曲线。通常情况下，一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变）。这样，你可以使用一个简写的贝塞尔曲线命令S，如下所示： 1S x2 y2, x y (or s dx2 dy2, dx dy) S命令可以用来创建与前面一样的贝塞尔曲线，但是，如果S命令跟在一个C或S命令后面，则它的第一个控制点会被假设成前一个命令曲线的第二个控制点的中心对称点。如果S命令单独使用，前面没有C或S命令，那当前点将作为第一个控制点。下面是S命令的语法示例，图中左侧红色标记的点对应的控制点即为蓝色标记点。 ![img](E:\\Typora_img\\SVG 学习笔记=ShortCut_Cubic_Bezier.png) 1234&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;190px&quot; height=&quot;160px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;path d=&quot;M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;&lt;/svg&gt; 另一种可用的贝塞尔曲线是二次贝塞尔曲线Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标。 1Q x1 y1, x y (or q dx1 dy1, dx dy) ![img](E:\\Typora_img\\SVG 学习笔记=Quadratic_Bezier.png) 1234&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;190px&quot; height=&quot;160px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;path d=&quot;M10 80 Q 95 10 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;&lt;/svg&gt; 就像三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个差不多的T命令，可以通过更简短的参数，延长二次贝塞尔曲线。 1T x y (or t dx dy) 和之前一样，快捷命令T会通过前一个控制点，推断出一个新的控制点。这意味着，在你的第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线。 ![img](E:\\Typora_img\\SVG 学习笔记=Shortcut_Quadratic_Bezier.png) 1234&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;190px&quot; height=&quot;160px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;path d=&quot;M10 80 Q 52.5 10, 95 80 T 180 80&quot; stroke=&quot;black&quot; fill=&quot;transparent&quot;/&gt;&lt;/svg&gt; 虽然三次贝塞尔曲线拥有更大的自由度，但是两种曲线能达到的效果总是差不多的。具体使用哪种曲线，通常取决于需求，以及对曲线对称性的依赖程度。 至此可知 https://cdn.jsdelivr.net/npm/hanzi-writer-data@2.0.1/⺀.json 文件内容的含义了： 1{&quot;strokes&quot;: [&quot;M 323 706 Q 325 699 328 694 Q 334 686 367 671 Q 474 619 574 561 Q 600 545 617 543 Q 627 545 631 559 Q 641 576 613 621 Q 575 684 334 717 Q 321 719 323 706 Z&quot;, &quot;M 312 541 Q 314 535 316 531 Q 320 524 347 512 Q 455 461 563 397 Q 588 380 606 380 Q 615 382 619 396 Q 629 414 602 457 Q 564 519 321 554 Q 320 555 319 555 Q 310 555 312 541 Z&quot;], &quot;medians&quot;: [[[336, 704], [450, 666], [554, 620], [587, 595], [614, 558]], [[317, 548], [347, 531], [455, 496], [543, 456], [578, 430], [602, 395]]]} $${\\mathbf {B}}(t)=(1-t)^2{\\mathbf {P}}{0}+2t(1-t){\\mathbf {P}}{1}+t^2{\\mathbf {P}}_{2}{\\mbox{ , }}t\\in [0,1]$$ 文本123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; fill=&quot;red&quot;&gt;I love SVG&lt;/text&gt;&lt;/svg&gt; I love SVG 线条属性 stroke：定义一条线、文本或元素轮廓颜色 stroke-width：定义了一条线、文本或元素轮廓厚度 stroke-linecap：定义不同类型的开放路径的终结 stroke-dasharray：用于创建虚线 参考 SVG 教程 | 菜鸟教程 (runoob.com) 路径 - SVG | MDN (mozilla.org)","link":"/2021/03/10/2030.html"},{"title":"Python 学习笔记","text":"基础语法编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码： 1# -*- coding: cp-1252 -*- 标识符 第一个字符必须是字母表中字母或下划线’_’。 标识符的其他的部分有字母、数字和下划线组成。 标识符对大小写敏感。 在 Python 3中，非 -ASCII 编码的标识符也是允许的了。 Python 保留字保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword module，可以输出当前版本的所有保留字： 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释Python 中单行注释以 # 开头，多行注释采用三对单引号（’’’）或者三对双引号（”””）将注释括起来。 缩进Python 最具特色的就是使用缩进来表示代码块。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。 标准数据类型Python 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 字符串 Python 中单引号和双引号使用完全相同。 使用三对引号(‘’’或”””)可以囊括一个多行字符串。 转义符 ‘' 自然字符串， 通过在字符串前加 r 或 R。 如 r”this is a line with \\n” 则\\n会显示，并不是换行。 Python 允许处理 unicode 字符串，加前缀 u 或 U， 如 u”this is an unicode string”。 字符串是不可变的。 按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量 [头下标: 尾下标: 步长] 1234word = '字符串'sentence = &quot;这是一个句子。&quot;paragraph = &quot;&quot;&quot;这是一个段落，可以由多行组成&quot;&quot;&quot; 实例： 1234567891011121314151617#!/usr/bin/python3 str='Runoob' print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始后的所有字符print(str[1:5:2]) # 输出从第二个开始到第五个且每隔两个的字符print(str * 2) # 输出字符串两次print(str + '你好') # 连接字符串 print('------------------------------') print('hello\\nrunoob') # 使用反斜杠(\\)+n转义特殊字符print(r'hello\\nrunoob') # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 这里的 r 指 raw，即 raw string，会自动将反斜杠转义，例如： 1234&gt;&gt;&gt; print('\\n') # 输出空行&gt;&gt;&gt; print(r'\\n') # 输出 \\n&gt;&gt;&gt;\\n 以上实例输出结果： 123456789101112RunoobRunooRnoonoobuoRunoobRunoobRunoob你好------------------------------hellorunoobhello\\nrunoob 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入执行下面的程序在按回车键后就会等待用户输入： 实例: 123#!/usr/bin/python3 input(&quot;\\n\\n按下 enter 键后退出。&quot;) 以上代码中 ，”\\n\\n”在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。 同一行显示多条语句Python 可以在同一行中使用多条语句，语句之间使用分号 (;) 分割，以下是一个简单的实例： 实例: 123#!/usr/bin/python3 import sys; x = 'runoob'; sys.stdout.write(x + '\\n') 使用脚本执行以上代码，输出结果为： 1runoob 使用交互式命令行执行，输出结果为： 123&gt;&gt;&gt; import sys; x = 'runoob'; sys.stdout.write(x + '\\n')runoob7 此处的 7 表示字符数。 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之代码组。 像 if、while、def 和 class 这样的复合语句，首行以关键字开始，以冒号 ( : ) 结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句 (clause)。 如下实例： 123456if expression : suiteelif expression : suite else : suite print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=””： 实例: 12345678910111213#!/usr/bin/python3 x=&quot;a&quot;y=&quot;b&quot;# 换行输出print( x )print( y ) print('---------')# 不换行输出print( x, end=&quot; &quot; )print( y, end=&quot; &quot; )print() 以上实例执行结果为： 1234ab---------a b import 与 from…import在 Python 用 import 或者 from…import 来导入相应的模块。 将整个模块 (somemodule) 导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 导入 sys 模块123456import sysprint('================Python import mode==========================')print ('命令行参数为:')for i in sys.argv: print (i)print ('\\n python 路径为',sys.path) 导入 sys 模块的 argv,path 成员1234from sys import argv,path # 导入特定的成员 print('================python from import===================================')print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 命令行参数很多程序可以执行一些操作来查看一些基本信息，Python 可以使用 -h 参数查看各参数帮助信息： 123456789$ python -husage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...Options and arguments (and corresponding environment variables):-c cmd : program passed in as string (terminates option list)-d : debug output from parser (also PYTHONDEBUG=x)-E : ignore environment variables (such as PYTHONPATH)-h : print this help message and exit[ etc. ] 参考https://www.w3cschool.cn/python3/python3-tutorial.html","link":"/2021/03/12/1301.html"},{"title":"UR5e 绘画","text":"模拟环境1234roslaunch ur_gazebo ur5.launch limited:=true roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch sim:=true limited:=true roslaunch ur5_moveit_config moveit_rviz.launch config:=true roslaunch draw_core start_draw.launch 真实环境1234roslaunch ur_modern_driver ur5_bringup.launch robot_ip:=192.168.83.1roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch roslaunch ur5_moveit_config moveit_rviz.launch config:=true roslaunch draw_core start_draw.launch 参考https://www.guyuehome.com/27468","link":"/2021/03/16/2249.html"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"TODO","slug":"TODO","link":"/tags/TODO/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"SLAM","slug":"SLAM","link":"/tags/SLAM/"},{"name":"WIFI","slug":"WIFI","link":"/tags/WIFI/"},{"name":"课程","slug":"课程","link":"/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"电脑故障","slug":"电脑故障","link":"/tags/%E7%94%B5%E8%84%91%E6%95%85%E9%9A%9C/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"无线通信","slug":"无线通信","link":"/tags/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"XML","slug":"XML","link":"/tags/XML/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"机械臂","slug":"机械臂","link":"/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"SLAM","slug":"SLAM","link":"/categories/SLAM/"},{"name":"ROS","slug":"ROS","link":"/categories/ROS/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"VLC","slug":"VLC","link":"/categories/VLC/"},{"name":"电脑故障","slug":"电脑故障","link":"/categories/%E7%94%B5%E8%84%91%E6%95%85%E9%9A%9C/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"},{"name":"Latex","slug":"Latex","link":"/categories/Latex/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"XML","slug":"XML","link":"/categories/XML/"},{"name":"SVG","slug":"SVG","link":"/categories/SVG/"},{"name":"Python","slug":"Python","link":"/categories/Python/"}]}