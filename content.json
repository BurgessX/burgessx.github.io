{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Git 学习笔记","text":"参考：廖雪峰的官方网站 Git简介Git的特点 Git是一种分布式版本控制系统（区别于集中式）。 在Git的版本管理中，文件的创建、修改、删除都被Git处理为“修改”。Git管理的是修改，而非文件。 Git上手安装 Git首先从Git官网下载安装包，安装完成后，打开Git Bash，输入 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 创建版本库 首先创建并进入文件夹 12mkdir learngitcd learngit 通过git init命令把这个目录变成Git可以管理的仓库 1git init 添加文件 将文件（假如叫*.txt）放到文件夹下，然后在该文件夹下执行 1git add *.txt 也可以同时添加多个文件或分多次添加多个文件。 提交文件，并添加更新内容的说明 1git commit -m &quot;I wrote a file named *.txt&quot; 时光机穿梭更新文档修改完文档后，重复“添加文件”小节中的步骤即可更新修改内容到版本库。 另外，使用命令git status可以查看版本库的暂存区的当前状态，命令git diff可以查看修改的内容。 版本找回每次执行git commit都会提交一个新的版本，使用git log可以查看最近的三个版本记录，git log --pretty=oneline可以简化输出。 回退到上一个版本： 1git reset --hard HEAD^ 回退到上上个版本： 1git reset --hard HEAD^^ 回退100个版本： 1git reset --hard HEAD~100 上面的例子说明HEAD（其实是一个指针）就是当前版本。 也可直接跳到指定版本： 1git reset --hard id 其中id可以使用命令git reflog查看（id没必要写全，写前几位就行）。该命令记录了每一次版本更换命令。 工作区、暂存区和主存区如图，git add命令会将工作区（Working Directory）的文件添加到版本库的暂存区（stage）处，而git commit命令会将暂存区的文件添加到主存区（master）处（姑且这么叫吧）。 另外可以发现，在一般情况下，工作区和主存区的文件树都是相对完整的，而暂存区只有部分文件。 版本丢弃 丢弃工作区的改动当执行 git checkout .或者git checkout -- &lt;file&gt;命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 丢弃暂存区的改动命令git reset HEAD &lt;file&gt;可以把暂存区的指定文件&lt;file&gt;的修改撤销，重新放回工作区（unstage），这时候工作区的&lt;file&gt;的内容也会被修改，我们再使用git checkout -- &lt;file&gt;命令即可把工作区&lt;file&gt;的修改给丢弃掉，恢复工作区的状态。这样两步实现了暂存区指定文件&lt;file&gt;的丢弃。 也可以用git rm --cached &lt;file&gt;命令一步就把文件的修改信息从暂存区删除而不改变工作区。 如果暂存库的修改内容已经用git commit命令提交到本地版本库了，可以参考版本找回一节回退版本；若推送到了远程库则无法回退。 丢弃工作区和暂存区的改动当执行git checkout HEAD .或者git checkout HEAD &lt;file&gt;命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 文件删除问题Git 速度慢方法一 123456git clone https://github.com/cpselvis/geektime-webpack-course.git# 改为git clone https://github.com.cnpmjs.org/cpselvis/geektime-webpack-course.git# cnpmjs：company npm/js 方法二 https 改成 git，即 1git clone git://github.com/cpselvis/geektime-webpack-course.git 方法三 配置ssh key（方法网上找），完了之后 1git clone git@github.com/cpselvis/geektime-webpack-course.git","link":"/2021/08/06/0201.html"},{"title":"HTML 学习笔记","text":"HTML模板1234567891011121314151617&lt;!DOCTYPE html&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt;&lt;p&gt;我的第一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2021/08/06/0201.html"},{"title":"","text":"我的第一个网页！！！ 这里是顶部~ Hello HTML~ 开始学习HTML。 不知道这东东有什么用。不知道能不能学到能自己做网页的程度。 有什么用自己百度一下？ href应该是超链接（Hyper Reference）的缩写，好记！但a怎么记？一个超链接？好吧可以。 这玩意怎么换行呀？不会只能用p标签吧？？？ 接下来加载一张图片试试？ 用什么图片好呢？emmm。头像？ src是source的缩写啦。btw，突然发现可以用两个p标签来换行 真正的换行方法！ 好吧，用br标签才是真正的换行方法。换行~再换行~OK~换行标签br只有开始标签，没有结束标签耶。 换行标签其实也要关闭，在br后面加上一斜杠（表示关闭）才是标准的写法。 HTML属性的用法 开头的百度一下链接就用到了一种属性（href）。双引号是最常用的，不过使用单引号也没有问题。 提示: 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name='John \"ShotGun\" Nelson'。 参考链接：菜鸟教程 字号大小怎么调整呢？答案：也是用属性。 六号最大，一号最小。 好吧我发现其实更大也可以。 HTML水平线 用hr标签就可以啦~（horizon的缩写？）试试看！ 啦啦啦这里是一段 emmm不是说好了标签都要关闭吗。。怎么hr不用。。有斜杠反而不显示。 HTML注释 好吧这个我在最前面已经试过了。 HTML段落注意事项 标签内的回车会被视为一个空格。连续的回车或空行会被视为一个。所以要在段内换行还是得用br标签。 HTML文本格式化 这是粗体 这是斜体 这是code标签，应该是显示代码的吧。试试，function a_func(int a, int num); 这是下标，这是上标。好吧，我想试试水：H2O。 除了用b和i，加粗和斜体也可以用strong标签和em（emphasize？）标签。 其他标签，例如： 1.用于字体放大的big标签； 2.用于presentation？？的pre标签。 可能是为了方便排版吧。 用了这个标签后，字体会变成和code标签内的字体一样，回车=换行，空格 有多少 就 显示多少。 3.address标签 这个好鸡肋啊 深圳南山 by Wu 4.abbr标签（abbreviation） 这个挺有用的哟。 5.dir标签，用于更改文字方向。这个真的没卵用。 6.q标签，引用（quote）标签。鲁迅说：这个也没啥用。显示上没啥区别呀。就多了个引号。 7.ins（insert）：插入标签。 好像就是有个下划线的效果？ 8.del（delete）：删除标签。 删除线效果。 9.还有好多标签啊。。。全部列在这里吧。 dfn（definition）：定义标签，某个词首次出现的时候可以用一下。 samp（sample）：样本标签。这个不知道有什么用。。 kbd（keyboard）：键盘输入标签。 var（variable）：变量标签。 HTML链接（续） 上面简单介绍了链接的使用方法，其实链接不仅可以是一个网址，也可以是一张图片，一个位置等。 一个网址的高阶用法： 要链接到哪里好呢？算了还是百度吧。。访问百度网站 这样写可以在新标签中打开网站。其他target属性试试： 用parent模式访问百度 用self模式访问百度 用top模式访问百度 链接的id属性： 这个就挺有用的，可以返回到特定位置，如返回顶部 图片链接：点击能跳转到百度 >","link":"/2021/08/06/0201.html"},{"title":"Latex学习笔记","text":"环境编译过程1234(xe/pdf)latex main.tex # 表示使用 latex, pdflatex 或 xelatex 编译，下同bibtex main.aux(xe/pdf)latex main.tex(xe/pdf)latex main.tex 无新的引用时可只用(xe/pdf)latex编译一次。 VS Code在命令面板中输入 LaTeX Workshop 就可以看到所有的命令，在命令旁边就可以看到快捷键。 Ctrl + Alt + B：编译Ctrl + Alt + C：清除 auxiliary 文件Ctrl + Alt + J：定位跳转到光标所在位置对应的 PDF 文件位置Ctrl + Alt + V：打开 PDF 预览 文件类型12345678tex - tex文件是最常见的latex文件，也是平时编写文章的文件cls - cls文件是latex的格式文件，规定了tex源文件的排版格局，称为类文件（class），一般使用\\documentclass{}导入sty - sty文件是宏包文件（package），一般使用\\usepackage{}导入bst - bst文件是参考文件的格式文件，一般使用\\bibliographystyle{}导入bib - bib文件是参考文献的库，一般使用\\bibliography{}导入dtx - 包含类或宏包及其说明文件的文件，需用同名.ins文件或docstrip工具分解。 bst - bib style hitszthesis.cls和hitszthesis.cfg可由hitszthesis.ins和hitszthesis.dtx生成 Classes are .cls files; packages are stored in .sty files. They are very similar, the main difference being that you can load only one class per document. 参考文献条目BibTeX条目类型@article期刊杂志的论文必要域: author, title, journal, year.可选域: volume, number, pages, month, note. volume是卷号，number是期号 @book公开出版的图书必要域: author/editor, title, publisher, year.可选域: volume/number, series, address, edition, month, note. @booklet无出版商或作者的图书必要域: title.可选域: author, howpublished, address, month, year, note. @conference等价于 inproceedings必要域: author, title, booktitle, year.可选域: editor, volume/number, series, pages, address, month, organization, publisher, note. @inbook书籍的一部分章节必要域: author/editor, title, chapter and/or pages, publisher, year.可选域: volume/number, series, type, address, edition, month, note. @incollection书籍中带独立标题的章节必要域: author, title, booktitle, publisher, year.可选域: editor, volume/number, series, type, chapter, pages, address, edition, month, note. @inproceedings会议论文集中的一篇必要域: author, title, booktitle, year.可选域: editor, volume/number, series, pages, address, month, organization, publisher, note. @manual技术文档必要域: title.可选域: author, organization, address, edition, month, year, note. @mastersthesis硕士论文必要域: author, title, school, year.可选域: type, address, month, note. @misc其他必要域: none可选域: author, title, howpublished, month, year, note. @phdthesis博士论文必要域: author, title, year, school.可选域: address, month, keywords, note. @proceedings会议论文集必要域: title, year.可选域: editor, volume/number, series, address, month, organization, publisher, note. @techreport教育，商业机构的技术报告必要域: author, title, institution, year.可选域: type, number, address, month, note. @unpublished未出版的论文，图书必要域: author, title, note.可选域: month, year. 一些技巧1234567891011121314151617\\dfrac{}{} % 在行内使用行间大小显示分式，d和t是什么意思？\\tfrac{}{} % 在行间使用行内大小显示分式\\displaystyle{\\frac{}{}}\\begin{equation}\\label{eq:f} \\left\\{ \\begin{array}{c} \\displaystyle{f_{\\text{x}}=\\frac{f}{s_{\\text{x}}}}\\\\[8pt] % &lt;--这里可以调整间距 \\displaystyle{f_{\\text{y}}=\\frac{f}{s_{\\text{y}}}}\\\\ \\end{array} \\right.\\end{equation}\\left\\{ \\right. % 多行大左括号\\left\\. \\right\\} % 多行大右括号 希腊字母记忆$$\\phi \\quad \\Phi \\quad \\varphi \\quad \\varPhi$$ 1\\phi \\Phi \\varphi \\varPhi % 注意这四个的区别，P大写说明字母大写，var是variable，用来表示变量 公式换行与等号对齐123456\\begin{equation} \\begin{aligned} a &amp;= b+c\\\\ &amp;= c+b \\end{aligned}\\end{equation} 对齐12345678910111213\\vskip 0pt % 立即转为竖直模式\\hskip 0pt % 立即转为水平模式\\vfill % 在当前段落后竖直填充无限空间，使用多个可以使得元素均布排列\\hfill % 在当前段落后水平填充无限空间，使用多个可以使得元素均布排列\\vspace{\\fill} % 在当前行后面竖直填充无限空间\\hspace{\\fill} % 在当前行后面水平填充无限空间\\vspace{1ex} % 行尾竖直空1个x的距离\\hspace{1em} % 水平空1个M的距离\\hspace{\\stretch{1}} % 水平留出一倍的距离（需要多处使用） 浮动体空白太多用\\clearpage命令进行调整。（放在图片前面，这样图片和后面的文字就会变成一页） 自定义Latex宏包宏包括命令和环境两种？ 命令就是类似\\hspace{}、\\par这种，环境就是类似 123\\begin{equation} 1+1=2\\end{equation} TEX宏定义命令定义123456\\def&lt;命令及参数&gt;{&lt;定义&gt;} % 参数用#1、#2等表示，需要手动加括号，也可以不加括号\\gdef&lt;命令及参数&gt;{&lt;定义&gt;} % 相当于\\global\\def\\edef&lt;命令及参数&gt;{&lt;定义&gt;} % 编译时会将命令完全展开\\xdef&lt;命令及参数&gt;{&lt;定义&gt;} % 相当于\\global\\edef\\let&lt;宏2&gt;=&lt;宏1&gt; % 定义一个新的宏（宏2）并将已有的宏1的定义赋值给它。赋值后二者无任何关联 条件判断1234567891011121314%% 条件判断\\if &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\fi\\if &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi % 下面同理\\ifx &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi\\ifnum &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi% 用来判断常整数或计数器（\\value{&lt;计数器&gt;}）\\ifdim &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi% 用来判断长度变量\\ifodd &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi% 用来判断整数是否为奇数% 条件判断符号有“=”、“&gt;”和“&lt;”\\ifcase&lt;变量&gt; &lt;0的内容&gt; \\or&lt;1的内容&gt; \\or&lt;2的内容&gt; ... \\else&lt;其他数字的内容&gt;\\fi\\relax % 什么都不做 变量定义12345678910111213\\newif&lt;变量&gt; % 定义一个布尔型变量，默认初始化为false。注意这个&lt;变量&gt;一定要以`\\if`开头% 或\\newif&lt;变量&gt; &lt;初始化值&gt;% 例：\\newif\\if@twocolumn% 等价于\\newif\\if@twocolumn \\@twocolumnfalse% 定义后就可以在不同地方用`\\@twoclumntrue`或`\\@twocolumnfalse`命令来给\\if@twocolumn赋值，而且可以用\\if@twocolumn \\relax % 真时执行\\else \\relax % 假时执行\\fi @当作字母来处理，是一种约定俗成的用法。带有@的命令表示宏包的内部命令。如\\WBX@twocolumn LATEX宏定义1234567\\newcommand&lt;命令&gt;[参数个数]{&lt;定义&gt;} % 定义新命令\\renewcommand&lt;命令&gt;[参数个数]{&lt;定义&gt;} % 如果命令已存在，则覆盖原定义\\providecommand&lt;命令&gt;[参数个数]{&lt;定义&gt;} % 如果命令已存在，则本定义无效\\newenvironment&lt;环境&gt;[参数个数]{&lt;定义&gt;} % 定义新环境\\renewenvironment&lt;环境&gt;[参数个数]{&lt;定义&gt;} % 如果环境已存在，则覆盖原定义\\provideenvironment&lt;环境&gt;[参数个数]{&lt;定义&gt;} % 如果环境已存在，则本定义无效 ifthen或xifthen宏包定义12texdoc ifthen # 见ifthen文档texdoc xifthen # 见xifthen文档 BugLaTeX Error: Environment CJKfilltwosides undefined.将项目中所有CJKfntef关键字都换成xeCJKfntef即可 Text page 7 contains only floats.这是一个警告，意思是生成的pdf的第7页只有浮动体。 Font shape `U/rsfs/m/n’ in size &lt;15.05624&gt; not available (Font) size &lt;14.4&gt; substituted.mathrsfs 宏包（数学花体宏包）的bug：使用了未定义的字体大小 编译报错：Recipe terminated with error.项目路径不能有中文名 插入图片的路径不能为中文，不能有空格。 编译报错：Missing number, treated as zero.\\begin{minipage}后面没有加参数 编译报错：Paragraph ended before \\Gin@ii was complete.\\includegraphics[width=\\textwidth]{{CR-02.png}多写了一个{。。。","link":"/2021/08/06/0144.html"},{"title":"Linux 网络编程","text":"B/S和C/S模型 B/S：浏览器/服务器模型 C/S：客户端/服务器模型 OSI七层模型 应用层：用户定义。FTP协议 传输层：端口号（区分不同应用）。TCP协议 网络层：IP，存放源IP（数据是谁发的）和目的IP（最终发送给谁）。IP协议 网络接口层（链路层）：通过ARP数据报寻路（同时会读取网络层的目的IP）。以太网协议 NAT映射表：用于局域网IP与公网IP的转换。 解决IP冲突：由于源IP可能是某局域网中的一个IP，可能会与目的IP（也在某一局域网中）重复，因此连接局域网的路由器有一个NAT映射表，将局域网中的每一个IP映射成路由器的“IP+不同端口”。 解决IP数不足：局域网只需要少量的ip地址（甚至一个）就可以满足专用地址网中所有计算机与internet的通信需求。 Socket（套接字）编程定义 IP：在网络环境中唯一地标识一台主机 Port（端口号）：在主机中唯一地标识一个进程 Socket=IP+Port：在网络环境中唯一地标识一个进程 成对出现 原理 管道通信：半双工通信 套接字通信：全双工通信（一个文件描述符指向两个缓冲区：一个读一个写） 预备知识 大端存储：低位存于高位，高位存于低位（网络字节序） 小端存储：低位存于低位，高位存于高位（主机字节序） 函数： htons()/ntohs()：host to net, short（短整型，16位）。本地字节序（小端存储）转网络字节序（大端存储） htonl()/ntohl()：net to host, long（长整型，32位）。网络字节序（大端存储）转本地字节序（小端存储） The htons () function converts the unsigned short integer hostshort from host byte order to network byte order. The ntohl () function converts the unsigned integer netlong from network byte order to host byte order. The ntohs () function converts the unsigned short integer netshort from network byte order to host byte order. inet_pton()：point to net，点分十进制字符串转网络字节序 inet_ntop()：net to point，网络字节序转点分十进制字符串 sockaddr数据结构 使用$man 7 ip指令查看 struct sockaddr：早期使用 struct sockaddr_in：后来使用 16位地址类型（sa_family_t sin_family) AF_INET（IPV4） AF_INET6（IPV6） AF_UNIX（本地协议） 16为位端口号(in_port_t sin_port) 32位IP地址(struct in_addr sin_addr) 8字节填充 函数 头文件 #include &lt;sys/types.h&gt; #include&lt;sys/socket.h&gt; ```cint socket(int domain, int type, int protocol); 123456789101112131415 * domain * AF_INET（IPV4） * AF_INET6（IPV6） * AF_UNIX（本地协议） * type * SOCK_STREAM：流式协议，默认使用TCP * SOCK_DGRAM：默认使用UDP * protocol：传0表示使用默认协议 * return * 成功：返回指向新创建的socket的文件描述符 * 失败：返回-1，设置errno * ```c int bind(int sockfd, const struct sockaddr *addr, socketlen_t addrlen); 作用：绑定IP和Port，如果没有调用，系统自动分配IP和Port，故服务器需要调用，而客户端不需要调用 sockfd：socket文件描述符 addr：构造出的IP地址+端口号 addrlen：sizeof(addr) return 成功：返回0 失败：返回-1，设置errno ```cint listen(int sockfd, int backlog); 12345678910 * 作用：设置最多同时可以有多少个客户端与之建立连接（不是保持连接。建立连接需要一定时间） * sockfd：socket文件描述符 * backlog：指定最多同时可以有多少个客户端与之建立连接 * return * 成功：返回0 * 失败：返回-1 * ```c int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); 作用：阻塞，直到有客户端连接 sockfd：服务器的socket文件描述符 addr：传出参数，返回链接客户端地址信息（IP+Port） addrlen：传入传出参数，传入sizeof(addr)，传出客户端的addr长度 return 成功：返回一个新的socket文件描述符，用于和客户端通信 失败：返回-1，设置errno ```cint connect(int sockfd, struct sockaddr *addr, socklen_t addrlen); 12345678 * sockfd：socket文件描述符 * addr：传入参数，指定服务器地址信息（IP+Port） * addrlen：传入传出参数，传入sizeof(addr) * return：成功返回0，失败返回-1，设置errno * ```c read return： 大于0：实际读到的字节数 等于0：数据读完 -1：异常 errno == EINTR：被信号中断 errno == EAGAIN（EWOULDBLOCK）：以非阻塞方式读，并且没有数据 errno == 其他：出现错误 ```cssize_t Readn(int fd, void *vptr, size_t n); // 非标准库函数，自己写{ size_t nleft; // 剩余的未读取的字节数 ssize_t nread; // 实际读到的字节数 char *ptr; ptr = vptr; nleft = n; // 一开始一共n个字节未读 while(nleft &gt; 0) { nread = read(fd, ptr, nleft); if(nread &lt; 0) { if(errno == EINTR) nread = 0; else return -1; } else if(nread == 0) // 读完了 { break; } else { nleft -= nread; ptr += nread; } } return n - nleft; // 返回读取到的字节数，一般为n } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112 ## 流程![img](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1576816388100&amp;di=ff7c777d013db380942e96d988f3bc34&amp;imgtype=0&amp;src=http%3A%2F%2Fimages.cnblogs.com%2Fcnblogs_com%2Fjasonwang%2F201104%2F201104180939247446.png)* server.c 1. socket()：建立套接字，得到文件描述符 2. struct sockaddr_in addr初始化 2. bind()：传入构造的addr，将sockfd与IP+Port绑定 3. listen()：设置最大同时发起连接的数量 4. accept()：阻塞等待客户端发起连接 5. read()：读取客户端数据 6. 数据处理 7. write()：给客户端写数据 8. close()* client.c 1. socket() 2. bind()：可以不调用，系统则自动绑定随机IP和端口号 3. connect()：发起连接 4. write()：向服务器写数据 5. read()：读取服务器发来的数据 6. close()## 服务器程序* server.c```c/* *发送一个小写字母，返回一个大写字母 */#include &lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;sys/socket.h&gt;#include&lt;stdlib.h&gt;#include&lt;arpa/inet.h&gt; //sockaddr_in的头文件#include&lt;ctype.h&gt; //toupper的头文件#include&lt;strings.h&gt; //bzero的头文件#define SERV_IP &quot;127.0.0.1&quot; //Linux预定义的本机IP，存放在etc/hosts文件中#define SERV_PORT 6666 //端口号，可随便定义，但注意1000以下给系统使用，最大65535int main(void){ int lfd, cfd; struct sockaddr_in serv_addr, clie_addr; socklen_t clie_addr_len = sizeof(clie_addr); char buf[BUFSIZ], clie_IP[BUFSIZ]; //BUFSIZ是一个宏 int n, i; //n为接收到的字符数 int ret; bzero(&amp;serv_addr, sizeof(serv_addr)); // 将serv_addr结构体内存空间清零 lfd = socket(AF_INET, SOCK_STREAM, 0); // 创建套接字，用来建立连接的 if(lfd == -1) { perror(&quot;socket error&quot;); exit(1); } serv_addr.sin_family = AF_INET; //IPV4 serv_addr.sin_port = htons(SERV_PORT);//本地字节序转化为网络字节序 serv_addr.sin_addr.s_addr = htonl(INADDR_ANY)；//INADDR_ANY是一个宏会自动获取当前网卡对应的有效IP // 或用serv_addr.sin_addr.s_addr = inet_addr(SERV_IP)字符串转网络字节序函指定特定IP地址，即 // 或用inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr)。注意与上面不一样，这里是将serv_addr.sin_addr.s_addr的地址传入函数进行赋值，而不是用函数的返回值对serv_addr.sin_addr.s_addr进行赋值 ret = bind(lfd, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); // 将IP和Port绑定起来 if(ret == -1) { perror(&quot;bind error&quot;); exit(1); } ret = listen(lfd, 128); //默认128 if(ret == -1) { perror(&quot;listen error&quot;); exit(1); } cfd = accept(lfd, (struct sockaddr *)&amp;clie_addr, &amp;clie_addr_len); if(cfd == -1) { perror(&quot;accept error&quot;); exit(1); } printf(&quot;client IP:%s, client port:%d\\n&quot;, inet_ntop(AF_INET, &amp;clie_addr.sin_addr.s_addr, clie_IP, sizeof(clie_IP)), ntohs(clie_addr.sin_port)); //打印连接客户端的IP地址和端口号 while(1) { n = read(cfd, buf, sizeof(buf)); //小写转大写int toupper(int c); //大写转小写int tolower(int c); for(i = 0; i &lt; n; i++) { buf[i] = toupper(buf[i]); } write(cfd, buf, n); } close(lfd); close(cfd); return 0;} 单独进行服务器测试 123$ gcc server.c -0 server //编译$ ./server //运行服务器程序$ nc 127.0.0.1 6666 //连接到本机 查看端口号是否被占用 12$ sudo su //获取root权限$ netstat -apn | grep 6666 查看IP信息 1$ ip -a 注意：要先ctrl+c关闭客户端，再关闭服务器。若先关闭服务器，则服务器套接字不会马上清除，而会进入TIME_WAIT状态，这时若再重启服务器，server程序执行到bind函数处会报错（Address already in use），即地址已被使用。此时是无法强制回收该套接字的，需要等待一段时间，直到套接字被自动回收。 客户端程序 client.c 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;sys/socket.h&gt;#include&lt;arpa/inet.h&gt;#define SERV_IP &quot;127.0.0.1&quot;#define SERV_PORT 6666 //注意与服务器程序对应int main(void){ int cfd; struct sockaddr_in serv_addr; //服务器的IP+Port socklen_t serv_addr_len = sizeof(serv_addr); char buf[BUFSIZ]; int n; cfd = socket(AF_INET, SOCK_STREAM, 0); //创建套接字 memset(&amp;serv_addr, 0, sizeof(serv_addr)); //将serv_addr结构体内存空间初始化为0 serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(SERV_PORT); inet_pton(AF_INET, SERV_IP, &amp;serv_addr.sin_addr.s_addr); connect(cfd, (struct sockaddr *)&amp;serv_addr, serv_addr_len); while(1) { fgets(buf, sizeof(buf), stdin); //读一行，以\\n作为结束标志，加上\\0 write(cfd, buf, strlen(buf)); //写到套接字中写缓冲区 n = read(cfd, buf, sizeof(buf));//读取套接字的读缓冲区 write(STDOUT_FILENO, buf, n); //写到屏幕 } close(cfd); return 0;} 错误处理 wrap.c 例：将socket函数封装成Socket函数 123456789int Socket(int family, int type, int protocol){ int n; if((n = socket(family, type, protocol)) &lt; 0) { perr_exit(&quot;socket error&quot;); } return n;} 只将首字母大写，方便在vi中用K命令直接查看帮助文档，否则用下面的命令 1$ :!man 2 socket TCP协议TCP通信时序（建立连接的三次握手和关闭连接的四次握手） 由于网络层与硬件联系紧密，因此不太稳定。因此传输层有如下解决方式： UDP：完全不弥补，无连接不可靠报文传输 TCP：完全弥补，面向连接的可靠数据包传递 TCP通信时序图如下","link":"/2021/08/06/0201.html"},{"title":"iperf 帮助文档","text":"Usage: iperf [-s|-c host] [options] iperf [-h|–help] [-v|–version] Client/Server: -b, –bandwidth #[KMG | pps] bandwidth to send at in bits/sec or packets per second -e, –enhancedreports use enhanced reporting giving more tcp/udp and traffic information -f, –format [kmKM] format to report: Kbits, Mbits, KBytes, MBytes -i, –interval # seconds between periodic bandwidth reports -l, –len #[KM] length of buffer to read or write (default 8 KB) -m, –print_mss print TCP maximum segment size (MTU - TCP/IP header) -o, –output output the report or error message to this specified file -p, –port # server port to listen on/connect to -u, –udp use UDP rather than TCP -w, –window #[KM] TCP window size (socket buffer size) -z, –realtime request realtime scheduler -B, –bind bind to , an interface or multicast address -C, –compatibility for use with older versions does not sent extra msgs -M, –mss # set TCP maximum segment size (MTU - 40 bytes) -N, –nodelay set TCP no delay, disabling Nagle’s Algorithm -V, –ipv6_domain Set the domain to IPv6 Server specific: -s, –server run in server mode -U, –single_udp run in single threaded UDP mode -D, –daemon run the server as a daemon Client specific: -c, –client run in client mode, connecting to -d, –dualtest Do a bidirectional test simultaneously -n, –num #[KM] number of bytes to transmit (instead of -t) -r, –tradeoff Do a bidirectional test individually -t, –time # time in seconds to transmit for (default 10 secs) -B, –bind [ | ip:port] bind src addr(s) from which to originate traffic -F, –fileinput input the data to be transmitted from a file -I, –stdin input the data to be transmitted from stdin -L, –listenport # port to receive bidirectional tests back on -P, –parallel # number of parallel client threads to run -T, –ttl # time-to-live, for multicast (default 1) -Z, –linux-congestion set TCP congestion control algorithm (Linux only) Miscellaneous: -x, –reportexclude [CDMSV] exclude C(connection) D(data) M(multicast) S(settings) V(server) reports -y, –reportstyle C report as a Comma-Separated Values -h, –help print this message and quit -v, –version print version information and quit [KM] Indicates options that support a K or M suffix for kilo- or mega- The TCP window size option can be set by the environment variableTCP_WINDOW_SIZE. Most other options can be set by an environment variableIPERF_, such as IPERF_BANDWIDTH. Source at http://sourceforge.net/projects/iperf2/Report bugs to iperf-users@lists.sourceforge.net","link":"/2021/08/06/0201.html"},{"title":"systemd 网络配置命令","text":"参考：https://blog.csdn.net/boyemachao/article/details/87366505 sytemd-network.service 的配置文件可以位于 /usr/lib/systemd/network/ 或者 /etc/systemd/network/ 目录下，后者具有最高优先级。配置文件有三种类型： .network 文件，设置网卡的 IP 等各项属性 .netdev 文件，新建一个虚拟网卡 .link 文件，每当一个网卡出现时，udev 都会查找与它同名的 .link 文件 这几类文件都遵循下面的规则： 各选项的值都支持星号 * 通配符 当 [Match] 段内的条件都匹配时，后面的配置项才会被激活 如果 [Match] 段为空，表示后面的配置项在任何情况下都可用 无论配置文件在哪个目录，都会统一按照字典顺序进行加载 同名文件可以相互替换 如果要给 enp0s20f6 配置一个静态 IP ，可以在 /etc/systemd/network/ 目录下新建一个 eth0.network 文件，内容如下： 1234567[Match]Name=enp0s20f6 # 匹配名为 enp0s20f6 的网卡[Network]DHCP=none # 关闭 DHCP 客户端Address=192.168.5.242/24 # 设置 IP 和子网掩码（24位）Gateway=192.168.5.50 # 设置网关，这项设置会将该网卡添加到缺省路由DNS=8.8.8.8 # 设置 DNS 如果要使用 DHCP 自动获取 IP ，也将 DHCP 设为如下值： v4 ，只接受 ipv4 的 IP v6 ，只接受 ipv6 的 IP both ，同时接受 ipv4 和 ipv6 格式的 IP 启动 DHCP 客户端后，Gateway 和 DNS 也会自动获取，有时我们不希望这样，可以在配置文件中添加一个 [DHCP] 段，做如下设置： 123[DHCP]UseDNS=false # 不使用 DHCP 分配的 DNS ，默认值是 trueUseRoutes=false # 不会将本网卡设为缺省路由，默认值是 true 在这里会出现一个 Bug ，就是 UseRoutes 设置无效，高版本中已经解决，解决方案在 https://github.com/systemd/systemd/pull/3075 。 配置完之后重启网络： 1systemctl restart systemd-networkd","link":"/2021/08/06/0201.html"},{"title":"Argparse库学习笔记","text":"简介Argparse 模块是 Python 标准库中推荐的命令行解析模块，可以用来编写有选项和参数的 Python 脚本，使用脚本时就像使用 Linux 的命令行软件一样。如： 1python demo.py -f 'filename.txt' -o 'dir/dir2' 引入 Argparse 模块只需要在 Python 脚本中 1import argparse 即可 脚本编写流程定义 ArgumentParser 对象123import argparseparser = argparse.ArgumentParser() # 定义 ArgumentParser 对象 ArgmentParser 类的声明如下： 1class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True, exit_on_error=True) 各参数含义如下： prog - 程序的名称（默认：sys.argv[0]），会在帮助文本中显示 usage - 描述程序用途的字符串（默认值：根据添加到解析器的参数生成），会在帮助文本中显示 description - 在参数帮助文档之前显示的文本（默认值：无），会在帮助文本中显示 epilog - 在参数帮助文档之后显示的文本（默认值：无） parents - 一个 ArgumentParser 父对象的列表，父对象需要先实例化，子对象会包括父对象的所有参数 formatter_class - 用于自定义帮助文档输出格式的类，有以下四种： argparse.RawDescriptionHelpFormatter - description 按原样输出 argparse.RawTextHelpFormatter - 整个 help 文本按原样输出 argparse.ArgumentDefaultsHelpFormatter - 自动添加默认的值的信息到每一个帮助信息的参数中 argparse.MetavarTypeHelpFormatter - 在帮助文本中以添加参数时指定的 type （而不是使用默认的格式 dest）作为显示的参数名 prefix_chars - 可选参数的前缀字符集合（默认值：’-‘），例：prefix_chars = '-+' 表示 - 或 + 都可以作为选项的前缀 fromfile_prefix_chars - 输入参数时，当需要从文件中读取部分参数时，此关键字指定用于标识文件名的前缀字符集合（默认值：None），从文件读取的参数在默认情况下必须一个一行 argument_default - 参数的全局默认值（默认值： None） conflict_handler - 解决冲突选项的策略（通常没必要设置） add_help - 是否为解析器添加一个 -h/--help 选项（默认值： True） allow_abbrev - 如果缩写是无歧义的，则允许缩写长选项 （默认值：True） exit_on_error - 决定当错误发生时是否让 ArgumentParser 附带错误信息退出。 (默认值: True) 用 add_argument() 添加参数参数可分为两种： 选项参数（optional argument），类似 -f、--foo 注意：选项参数不一定是可选参数，可不可选可通过 require 关键字指定，如果脚本中引用了此参数，则此参数不可选。另外，选项参数也可作为标志选项来使用，即用户在传入选项时后面不跟参数值 位置参数（positional argument），类似 bar 12345import argparseparser = argparse.ArgumentParser() # 定义 ArgumentParser 对象parser.add_argment('-f', '--foo') # 添加选项参数，注意这里只添加了一个选项参数，二者效果相同parser.add_argment('bar') # 添加位置参数 add_argument() 函数的声明如下： 1ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest]) 各参数的含义如下： name or flags - 添加的位置参数（如 bar）或选项参数（如 -f、--foo、--foo-the-bar，可以传入多个作为别名）的名称 action - 当参数在命令行中出现时使用的动作基本类型（默认为 store），主要有如下几种 store - 存储参数值 store_const - 存储 const 关键字所指定的值，一般用于将选项参数设为标志选项 append - 将参数值添加到列表中 append_const - 将 const 关键字所指定的值添加到列表中 count - 将参数出现的次数作为参数值 help - 打印完整的帮助信息并退出，默认有此动作 version - 打印 version 关键字所指定的信息 extend - 和 append 一模一样，我没看出有什么区别 argparse.BooleanOptionalAction - 例：通过传入 --foo 使 foo=True，传入 --no-foo 使 foo=False nargs - 命令行参数应当消耗的数目 N（整数）- 具体数目 注意：nargs=1 和不指定 nargs 不同，虽然命令行参数数量都是1，但解析参数后返回的属性的数据类型不一样，前者为单元素列表，后者为一个元素 ? - 一个或零个，零个的话会用 default 的值来赋值，另外如果只传入选项字符串而后面没有跟参数值的话，会用 const 的值来赋值 * - 零个及以上 + - 至少一个 const - 被一些 action 和 nargs 选择所需求的常数 default - 当参数未在命令行中出现并且也不存在于命名空间对象时所产生的值 type - 命令行参数应当被转换成的数据类型 choices - 可用的参数的容器 指定参数的范围，如choices='XYZ'则表示参数为X、Y、Z的其中之一 required - 此命令行选项是否可省略 （仅选项可用） help - 一个此选项作用的简单描述 metavar - 在使用方法消息（help的usage部分）中显示的参数值示例 dest - 被添加到 parse_args() 所返回对象上的属性名 对于位置参数，返回对象的属性名默认为调用add_argument()添加位置参数时传入的位置参数名 对于选项参数，返回对象的属性名默认为调用add_argument()添加选项参数时传入的选项参数字符串 参考 https://docs.python.org/zh-cn/3/howto/argparse.html https://docs.python.org/zh-cn/3/library/argparse.htm","link":"/2021/08/06/0201.html"},{"title":"Python爬虫","text":"环境配置见《Python学习笔记》 常用库 库名称 作用 来源 urllib 发送HTML数据请求 python内置 BeautifulSoup 解析HTML pip install bs4 requests 发送GET和POST请求 pip install requests","link":"/2021/08/06/0201.html"},{"title":"UR5e 绘画","text":"模拟环境1234roslaunch ur_gazebo ur5.launch limited:=true roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch sim:=true limited:=true roslaunch ur5_moveit_config moveit_rviz.launch config:=true roslaunch draw_core start_draw.launch 真实环境1234roslaunch ur_modern_driver ur5_bringup.launch robot_ip:=192.168.83.1roslaunch ur5_moveit_config ur5_moveit_planning_execution.launch roslaunch ur5_moveit_config moveit_rviz.launch config:=true roslaunch draw_core start_draw.launch 参考https://www.guyuehome.com/27468","link":"/2021/08/06/0201.html"},{"title":"SLAM 学习笔记","text":"参考：高翔的视觉SLAM十四讲 引言困难之处 三维空间的运动 受到噪声影响 数据来源只有图像 人类看到的是图像，计算机看到的是数值矩阵 从学习角度来看 牵涉到的理论太广 从理论到实现困难 资料缺乏 需要的知识 机器人学 计算机视觉 状态估计（有噪声） 计算机科学（写代码来实现） 预备知识 数学：高等数学、线性代数（矩阵论）、概率论 编程：C++、Linux，了解语法和基本命令即可 不提供windows环境下的方案 推荐书籍 The Bible: Multiple View Geometry in Computer Vision State Estimation for Robotics: A Matric-Lie-Group Approach Probabilistic Robotics 第二讲 初识SLAM两类传感器 二维码marker GPS 导轨、磁条 携带于机器人本体上的 IMU 激光 相机 SLAM强调未知环境，更重视携带式传感器 相机分类 单目：Monocular，通过移动相机估计深度（Moving View Stereo） 双目：Stereo，通过视差计算深度 深度：RGBD，通过物理方法（TOF、结构光）直接测量深度 其他：鱼眼、全景、Event Camera，etc. 单目估计深度的方法：运动起来后，近处的物体运动快，远处的物体运动慢 双目相机：通过左右眼的微小差异判断远近，远处的物体变化小，近处的物体变化大 深度相机特点：深度值较准确；量程小；易受干扰 视觉SLAM框架 前端：VO 后端：Optimization 回环检测：Loop Closing 建图：Mapping 视觉里程计 相邻图像估计相机运动 基本形式：通过两张图像计算运动和结构 不可避免地有漂移 方法 特征点法 直接法 后端优化 从带有噪声的数据中优化轨迹和地图（状态估计问题） 最大后验概率估计（MAP） 方法：前期以EKF为代表，现在以图优化为代表 回环检测 检测机器人是否回到早先位置 识别到达过的场景 计算图像间的相似性 方法：词袋模型 建图 用于导航、规划、通讯、可视化、交互等 度量地图 vs 拓扑地图 稀疏地图 vs 稠密地图 数学描述 离散时间 位置x 路标y 噪声v 观测z 用g++或gcc编译： 1g++ main.cpp -o helloSLAM 运行 1./helloSLAM 用g++来编译很麻烦，所以一般新建CMakeLists.txt文件，采用cmake生成一个工程，产生MakeFile等文件，再用make命令来编译。 创建CMakeLists.txt 12cmake .make 因为编译会生成许多中间文件，我们不想要，所以可以新建一个build文件夹，进入此文件夹，然后 12cmake ..make 这样cmake生成的临时文件和make生成的可执行文件都会放到build文件夹下。 IDE: KDevelopKDevelop可以很方便地编译cmake工程，因此这里假设我们的C++工程中已经创建好了CMakeLists.txt文件。 打开工程点击Project-&gt;Open/Import Project，然后选择CMakeLists.txt文件即可自动创建工程。 创建工程后会自动将工程添加到Project视图的Build Sequence下。 编译编译有多种方法： 点击Build会按顺序执行Build Sequence下的项目，该队列可以自行增删和调序。 选中项目，点击Build Selection图标（在Projects Tool Bar中，空白处右键可调出）理论上即可编译选中的项目。 但实测发现在Build Sequence中有项目时，Build Selection按钮和Build按钮一样会把Build Sequence下的项目全部编译。 选中项目，右键点击Build即可编译指定项目。 启动配置Run-&gt;Configure Launches-&gt;Add New，即可对项目新建自定义的启动配置，包括选择可执行文件、行为和依赖。 这一步可不配置按默认。如果有多个可执行文件的话可以配置一下要执行的可执行文件。 执行两种方法： Run-&gt;Current Launch Configuration，选中要执行的项目，然后点Execute执行。 在Project视图中选中要执行的项目，右键Execute As-&gt;Compiled Binary。 总结全部用右键的方法最直接了。 三维空间刚体运动旋转矩阵、变换矩阵、四元数、欧拉角 Eigen库 旋转矩阵旋转矩阵R 正交 行列式为1 特殊正交群 变换矩阵变换矩阵T、齐次坐标 特殊欧式群 EIGEN的矩阵运算库EIGEN：C++的矩阵运算库 1sudo apt-get install libeigen3-dev /usr/include/eigen3 没有库，只是头文件(所以不用链接到库文件（函数的实现）！) 1include_directories( &quot;/usr/include/eigen3&quot; ) 123Eigen::Matrix&lt;double, 3, 3&gt; R1_33Eigen::Matrix3f R2_33 // float型3×3矩阵Eigen::Vector3d v1 // 3×1向量 注意：矩阵的变量类型要一样才能乘，比如double不能乘float QR分解求矩阵的逆。比直接求逆快一些。 角轴或轴角或旋转向量罗德里格斯公式：RF公式 Rn=n： n绕自己转还是自己。 看成特征方程，特征值为1 欧拉角分类 定轴、动轴 顺序：X-Y-Z等 问题：万向锁（Gimbal Lock） 第二次旋转如果是正负90度，则第三次旋转和第一次旋转实际上是绕同一个轴，使得系统丢失了一个自由度，这说明欧拉角会存在奇异性问题 四元数四元数是复数的一种扩展，有三个虚部，可以表达三维空间中的旋转 四元数可以转换成角轴、旋转矩阵、欧拉角 四元数旋转一个空间点：p=[0,x,y,z]，经过变换q，成了p’ $p’=qpq^{-1}$ EIGEN的几何模块乘法可以不同维度。 四元数三个虚部在前。 可以用pangolin可视化 需要GLEW依赖： 1sudo apt install libglew-dev 李群与李代数直接优化旋转矩阵很困难，参数耦合，李代数为无约束的优化。 群群是一种集合加上一种运算的代数结构（抽象代数知识） 性质（充要条件） 封闭性 结合律 幺元 逆 “凤姐咬你” 可以验证 旋转矩阵集合和矩阵乘法构成群 变换矩阵集合和矩阵乘法构成群 SO(3)和SE(3)都是群 李群 具有连续（光滑）性质的群 既是群也是流形 SO(3)和SE(3)都是李群 但是SO(3)和SE(3)只有定义良好的乘法，没有加法，所以难以进行取极限、求导等连续操作 李代数李群和李代数是一一对应的关系 性质 封闭性 双线性 自反性 雅可比等价 三维空间向量+叉积运算 构成李代数 所以so(3)也是李代数 李括号运算 se(3)也满足李代数性质 李代数可以理解成向量或矩阵形式 指数映射和对数映射指数映射：罗德里格斯公式 对数映射 se(3)到SE(3)的指数映射 李代数求导与扰动模型 扰动模型更简洁、实用 推导用到了：泰勒展开、叉乘和反对称矩阵的关系 SOPHUS库不需要make install 最好make install sophus库分为无模板和模板两种版本。 ch4/useSophus/CMakeList.txt文件修改如下： 123456789cmake_minimum_required( VERSION 2.8 )project( useSophus )include_directories( &quot;/usr/include/eigen3/&quot; )include_directories( &quot;/usr/local/include/sophus/&quot; ) # 这里是头文件add_executable( useSophus useSophus.cpp )target_link_libraries( useSophus &quot;/usr/local/lib/libSophus.so&quot; )# 这里是链接到函数的实现 在Sophus中，se(3)的平移在前，旋转在后. 相机与图像相机模型齐次坐标：与距离无关 单目：小孔成像 畸变 径向畸变 切向畸变 双目：通过视距可测距离 RGB-D 原理： ToF：面光、红外光；玻璃测不到 结构光： OpenCV图像处理库可参考：https://docs.opencv.org/master/d7/d9f/tutorial_linux_install.html 1sudo apt-get install libopencv-dev # 二进制安装 3.1.0 /usr/local/ 点云工具libpcl-dev：pcl库 pcl-tools：包含pcl可视化 非线性优化状态估计问题 线性系统，高斯噪声 非线性系统，非高斯噪声 历史上用滤波器 近年用非线性优化 最大后验估计 最大似然估计 最速下降法（一阶）、牛顿法（二阶） 高斯牛顿法：JT J近似H LM方法： CERESgoogle的库 网站：ceres sover 12345mkdir buildcd buildcmake ..makesudo make install G2O","link":"/2021/08/06/0201.html"},{"title":"Win10 频繁开启代理导致断网问题","text":"新文章：https://blog.csdn.net/weixin_44091885/article/details/106594289 重置IE浏览器设置没用 关闭微软账户同步设置没用 卸载前几天安装的银联、农行安全控件没用 用火绒监控ProxyEnable注册表有用，多次检测到微软的smartscreen程序试图开启代理，经过百度后知道这是ie的一个子程序，用来监测上网的。虽然可以设置监测到就自动禁止，但我想从根本上解决问题： 禁用方法： IE-&gt;internet选项-&gt;安全-&gt;自定义级别-&gt;使用Windows Defender SmartScreen-&gt;禁用 最后有时候还是会断网，但恢复得很快。然后我还不满意就试了一下下面的方法 贴吧大神的方法结果电脑就崩了。能开机，但是系统设置出现了一些空白，等等一堆bug。 1，进入安全模式(必须，否则会失败)2， 打开注册表(win+R， 运行regedit)3，注册表左侧栏点击第一个计算机，再点击顶部菜单栏“编辑”-“查找”，输入127.0.0.1，点击“查找下一个”，耐心等候4，查找完毕，观察右侧栏，是否有焦点自动选中的项目，直接删掉，删完按F3(表示继续查找下一个)，一直重复直到把找出来的相关项目都删了为止5，最后按F5保存。重启电脑。完美解决。不放心可以1-5步骤重复一遍，确保与127.0.0.1相关的注册表项目删除干净Tips：1，请务必进入安全模式，否则无效2，查找注册表时，一定是右侧栏焦点选中的项目才可以删除，否则不要随便删除 最后在msdn上下了最新版的win10重装了系统。软件基本不用重装，就是一开始在桌面右键点某个应用的时候卡住了。重启了也不行。最后用腾讯电脑管家的右键管理一看，一大堆软件都放右键了。。全部取消就恢复正常了。 重装电脑后网络当然就没问题了。","link":"/2021/08/06/0201.html"},{"title":"Windows问题与解决方法","text":"Onedrive相关无法删除文件/文件夹对磁盘进行检查并修复即可。 文件夹状态一直为挂起原因是有些隐藏文件默认不同步，比如Word文件的缓存等。解决办法是取消“隐藏受保护的操作系统文件”，然后将缓存文件删除。","link":"/2021/07/29/1627.html"},{"title":"在 BIOS 中将 SATA 改为 AHCI 后重启蓝屏","text":"如果是UEFI+GPT分区表模式，那么给ubuntu分区的时候不用设置/boot分区，而要设置efi系统分区；如果是legacy+MBR分区表那么就要设置/boot分区。 格式化是针对主分区和逻辑分区的。要格式化是因为这和操作系统管理文件系统有关系。没有格式化的分区就像一张白纸，要写入数据，必须对白纸打上“格子”，每个格子里面写一块。而操作系统只认这些格子。所以要先用windows格式化，让windows认得移动硬盘，再用ubuntu格式化？","link":"/2021/08/06/0201.html"},{"title":"OpenVLC 文件树","text":"文件树Driver decode_rs.c：RS解码 encode_rs.c：计算数据的校验位，进行RS编码 openvlc.c：vlc相关，mac层* openvlc.h reed_solomon.c：rs初始化，计算数据的校验位（encode_rs.c） rs.c：RS算法，包括初始化查询表 rslib.h：rs结构体、编码/解码器库 vlc.mod.c PRU RX deploy.sh main_pru0.c main_pru1.c resource_table_pru0.h resource_table_pru1.h TX deploy.sh main_pru1.c resource_table_pru0.h resource_table_pru1.h 网络等配置TX： usb0网卡IP：192.168.7.2 vlc0网卡IP：192.168.0.1 RX： usb0网卡IP：192.168.7.2 vlc0网卡IP：192.168.0.2","link":"/2021/08/06/0201.html"},{"title":"电子技术笔记","text":"常用半导体元器件PN结 P型半导体：在硅（或锗）的晶体中掺入三价元素硼（B） 多数载流子：空穴 少数载流子：自由电子 N型半导体：在硅（或锗）的晶体中掺入五价元素磷（P） 多数载流子：自由电子 少数载流子：空穴 PN结 原本P型和N型半导体都呈电中性，但多子由于浓度差异产生扩散作用，在中间相互中和耗尽，产生方向从N指向P的内电场，阻挡多子的扩散作用，少子由于内电场作用产生漂移运动，二者达到动态平衡，使中间形成空间电荷区（也叫耗尽层&lt;多子耗尽&gt;、阻挡层&lt;阻挡多子扩散&gt;），即PN结。 外加正向电压 外电场方向与内电场方向相反，内电场减弱，空间电荷区变窄 扩散作用加强，漂移运动减弱 外加正向电压超过死区电压后（可以理解为超过内电场电压），外电路形成较大的正向电流 外加反向电压 外电场方向与内电场方向相同，内电场加强，空间电荷区变宽 扩散作用减弱，漂移运动加强 外电路形成较小的反向电流，且受温度影响较大 二极管普通二极管 伏安特性曲线： 反向击穿：电击穿可恢复，热击穿不可恢复 主要参数 最大整流电流（额定正向平均电流） 最高反向工作电压：约为反向击穿电压的一半或三分之二 最大反向电流 稳压二极管 简称稳压管，又称齐纳二极管。 反向特性曲线比普通二极管更陡一些，工作在反向击穿区。 主要参数 稳压电压 稳定电流和最大稳定电流 最大耗散功率 动态电阻 电压温度系数，有正有负 应用 整流电路：将交流电变为脉动的直流电（反向截止） 钳位电路：钳制电路某点的电位（正向导通） 隔离电路：利用二极管截止时电流很小，电路近似于断路（反向截止） 限幅电路：利用二极管正向导通、反向截止，以及电压源输出恒定电压的特性（正向导通、反向截止） 稳压电路：利用稳压管稳压（稳压管反向稳压） 三极管双极型晶体管（BJT） 半导体三极管分为双极型晶体管（Bipolar Junction Transistor，BJT）和场效应晶体管两大类。 双极型晶体管习惯上简称为三极管或晶体管 分类 按组合：NPN型和PNP型 按封装：直插式和贴片式 BJT的放大作用的条件 内部条件：基区很薄且掺杂浓度远低于发射区 外部条件：发射结正向偏置，集电结反向偏置 共发射极接法下，发射极电流、基极电流、集电极电流的关系：$I_{\\mathrm{E}}=I_{\\mathrm{C}}+I_{\\mathrm{B}}$，$I_{\\rm E} \\approx I_{\\rm C} \\gg I_{\\rm B}$ 输入特性曲线 输出特性曲线 三个区域 放大区：$U_{\\rm CE}&gt;U_{\\rm BE}$ 电流情况：集电极电流与基极电流近似成正比 偏置情况：发射结处于正向偏置，集电结处于反向偏置 截止区：$U_{\\rm BE}\\le 0$ 电流情况：基极电流为零，集电极电流很小 偏置情况：集电结和发射结均处于反向偏置 近似等效：此时集电极电流 $I_{\\rm CEO}$ 称为穿透电流，其值很小，BJT集电极与发射极之间相当于开路 饱和区：$U_{\\rm BE}&gt;U_{\\rm CE}$ 电流情况：基极电流对集电极电流的影响较小，二者不成正比 偏置情况：集电结与发射结均处于正向偏置 近似等效：此时集电极与发射极之间的电压 $U_{\\rm CES}$ 称为BJT的饱和压降，其值很小，BJT集电极与发射极之间相当于短路 简化的小信号模型（近似为电流控制电流源） 只适用于小信号的情况，忽略了 $U_{\\rm CE}$ 对 $I_{\\rm B}$ 和 $I_{\\rm C}$ 的影响 场效应晶体管 场效应管（Field Effect Transistor，FET）是利用外加电压产生的电场强度来控制其导电能力的一种半导体器件。 分类 按结构分：结型场效应晶体管、绝缘栅型场效应晶体管（又称为金属氧化物半导体场效应管，Metal Oxide Semiconductor FET，MOSFET） 绝缘栅型场效应晶体管（也叫单极型晶体管） 分类 N沟道和P沟道 增强型和耗尽型。耗尽型有原始沟道，增强型没有，需要外加电压。因此，如果要判别一个没有型号的 MOSFET 是增强型还是耗尽型，只要检查它在零栅压下，在漏、源极间加电压时是否能导通，就可作出判别。 ![image-20210323195305867](https://cdn.jsdelivr.net/gh/burgessx/img-bed@main/blog/20210425100240.png) 原理：以共源极电路为例，MOSFET 利用电场效应改变导电沟道的宽度来控制漏极电流的大小 特性曲线 N沟道增强型 MOSFET N沟道耗尽型 MOSFET 三个区域 可变电阻区：等效为一个可变电阻 线性放大区（恒流区）：$I_{\\rm D}$ 随 $U_{\\rm GS}$ 的增大而增大 击穿区：漏区与衬底间的PN结被反向击穿 主要参数 增强型：开启电压 耗尽型：夹断电压、饱和漏极电流 共同参数 最大漏-源极击穿电压 栅-源直流输入电阻：在漏、源两极短路的情况下，外加栅-源直流电压与栅极直流电流的比值。 栅-源击穿电压 最大漏极电流和最大耗散功率 低频跨导 $g_{\\mathrm{m}}=\\left.\\frac{\\Delta I_{\\mathrm{D}}}{\\Delta U_{\\mathrm{GS}}}\\right|{U{\\mathrm{DS}}={\\text 常数}}$ 小信号模型（近似为电压控制电流源） 半导体光电器件 半导体光电器件的原理：在光照作用下，照射光中的光子能够破坏半导体晶体的共价键，释放出电子；在电场作用下，电子与空穴复合发出的能量也能以一定波长的光的形式辐射。 发光二极管 发光二极管相比普通二极管，它的PN结面做得比较宽，半导体材料的掺杂浓度也比普通二极管高得多。 分类：直插式、贴片式 光电二极管 注意：使用光电二极管时，应反向接入电路 主要参数 暗电流：无光照时的反向饱和电流 光电流：额定照度下的反向电流 灵敏度：在给定波长的光照下，单位光功率产生的光电流 峰值波长：使光电二极管具有最大响应灵敏度的光的波长 响应时间：指加定量光照后，光电流达到稳定值的 60% 所需的时间 注意：光电二极管的暗电流随温度变化而变化，因此，对稳定性要求较高的电路，需要考虑进行温度补偿。 双极型光电晶体管 又称光电三极管 分类 按管脚数：三引脚、两引脚 等效 光电耦合器 简称光耦，又称光电隔离器。 原理图 基本放大电路共射极放大电路 输入电路图解 输出电路图解 静态分析 静态工作点的选择：避免截止失真和饱和失真 稳定静态工作点 使用分压式偏置共射极放大电路 其中 $C_{\\rm E}$ 为**旁路电容**，使 $R_{\\rm E}$ 只对直流分量 $I_{\\rm C}$ 有稳定作用。 稳定静态工作点的过程 动态分析 放大电路的主要性能指标 放大倍数（增益） 输入电阻 对于信号源而言，放大电路相当于它的负载，输入电阻即为负载的阻值 为减小信号损失，一般要求放大电路的输入电阻大一些好 输出电阻 对负载而言，放大电路相当于一个电压源，输出电阻即为电压源的内阻 为增大带负载的能力，一般要求放大电路的输出电阻小一些好 微变等效电路 画法：首先要画出放大电路的交流通路，然后再将BJT用它的小信号模型来替代。 以固定式偏置共射极放大电路为例： 共集电极放大电路 场效应晶体管共源极放大电路静态分析 BJT 是电流控制型器件，放大电路依靠调整基极电流 $I_{\\rm B}$ 来获得合适的静态工作点；MOSFET 是电压控制型器件，放大电路的静态工作点由栅-源电压 $U_{\\rm GS}$ 决定。 偏置电路形式 自给式偏置：用于耗尽型 MOSFET 分压式偏置：用于增强型 MOSFET 或耗尽型 MOSFET 动态分析以分压式偏置共源极放大电路为例 微变等效电路 集成运算放大器 内部电路组成框图 符号 电压传输特性 主要性能参数 开环差模电压放大倍数 共模抑制比 差模输入电阻 输入失调电压 输入失调电流 最大共模输入电压 最大差模输入电压 理想运算放大器 符号 电压传输特性 工作在线性区时的两个结论 虚短、虚地（若接地） 虚断","link":"/2021/08/06/0201.html"},{"title":"Git Book 学习","text":"起步关于版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 我们对保存着软件源代码的文件作版本控制，但实际上，你可以对任何类型的文件进行版本控制。 本地版本控制系统许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。 为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。 其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 RCS 的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中化的版本控制系统接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？ 于是，集中化的版本控制系统（Centralized Version Control Systems，简称 CVCS）应运而生。 这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 多年以来，这已成为版本控制系统的标准做法。 分布式版本控制系统于是分布式版本控制系统（Distributed Version Control System，简称 DVCS）面世了。 在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 Git 简史Git 是什么三种状态现在请注意，如果你希望后面的学习更顺利，请记住下面这些关于 Git 的概念。 Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）、已修改（modified） 和 已暂存（staged）。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 已提交表示数据已经安全地保存在本地数据库中。 这会让我们的 Git 项目拥有三个阶段：工作区、暂存区以及 .git 目录（即 Git 仓库）。 工作区是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。 按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。 基本的 Git 工作流程如下： 在工作区中修改文件。 将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。 提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。 命令行安装 Git初次运行 GIt 前的配置Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 --system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。） ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 --global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。 当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 --local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。） 每一个级别会覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 在 Windows 系统中，Git 会查找 $HOME 目录下（一般情况下是 C:\\Users\\$USER ）的 .gitconfig 文件。 Git 同样也会寻找 /etc/gitconfig 文件，但只限于 MSys 的根目录下，即安装 Git 时所选的目标位置。 如果你在 Windows 上使用 Git 2.x 以后的版本，那么还有一个系统级的配置文件，Windows XP 上在 C:\\Documents and Settings\\All Users\\Application Data\\Git\\config ，Windows Vista 及更新的版本在 C:\\ProgramData\\Git\\config 。此文件只能以管理员权限通过 git config -f &lt;file&gt; 来修改。 你可以通过以下命令查看所有的配置以及它们所在的文件： 1$ git config --list --show-origin 用户信息安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改： 12$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com 再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。 检查配置信息1$ git config --list # 检查 Git 的所有配置 1git config &lt;key&gt; # 检查 Git 的某一项配置 由于 Git 会从多个文件中读取同一配置变量的不同值，因此你可能会在其中看到意料之外的值而不知道为什么。 此时，你可以查询 Git 中该变量的 原始 值，它会告诉你哪一个配置文件最后设置了该值： 12$ git config --show-origin rerere.autoUpdatefile:/home/johndoe/.gitconfig false 文本编辑器如果你想使用不同的文本编辑器，例如 Emacs，可以这样做： 1$ git config --global core.editor emacs 在 Windows 系统上，如果你想要使用别的文本编辑器，那么必须指定可执行文件的完整路径。 它可能随你的编辑器的打包方式而不同。 获取帮助若你使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）： 123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 例如，要想获得 git config 命令的手册，执行 1$ git help config 此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 -h 选项获得更简明的 “help” 输出： 1$ git &lt;verb&gt; -h Git help1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ git --helpusage: git [--version] [--help] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;] [--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path] [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare] [--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;] [--super-prefix=&lt;path&gt;] [--config-env=&lt;name&gt;=&lt;envvar&gt;] &lt;command&gt; [&lt;args&gt;]These are common Git commands used in various situations:start a working area (see also: git help tutorial) clone Clone a repository into a new directory init Create an empty Git repository or reinitialize an existing onework on the current change (see also: git help everyday) add Add file contents to the index mv Move or rename a file, a directory, or a symlink restore Restore working tree files rm Remove files from the working tree and from the index sparse-checkout Initialize and modify the sparse-checkoutexamine the history and state (see also: git help revisions) bisect Use binary search to find the commit that introduced a bug diff Show changes between commits, commit and working tree, etc grep Print lines matching a pattern log Show commit logs show Show various types of objects status Show the working tree statusgrow, mark and tweak your common history branch List, create, or delete branches commit Record changes to the repository merge Join two or more development histories together rebase Reapply commits on top of another base tip reset Reset current HEAD to the specified state switch Switch branches tag Create, list, delete or verify a tag object signed with GPGcollaborate (see also: git help workflows) fetch Download objects and refs from another repository pull Fetch from and integrate with another repository or a local branch push Update remote refs along with associated objects'git help -a' and 'git help -g' list available subcommands and someconcept guides. See 'git help &lt;command&gt;' or 'git help &lt;concept&gt;'to read about a specific subcommand or concept.See 'git help git' for an overview of the system. Git 基础 获取 Git 仓库通常有两种获取 Git 项目仓库的方式： 将尚未进行版本控制的本地目录转换为 Git 仓库； 从其它服务器 克隆 一个已存在的 Git 仓库。 在已存在目录中初始化仓库1git init 123git add *.cgit add LICENSEgit commit -m 'initial project version' 克隆现有的仓库12git clone https://github.com/libgit2/libgit2git clone https://github.com/libgit2/libgit2 mylibgit # 克隆并重命名 记录每次更新到仓库Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。 Git的三种传输协议： 协议名称 URL样式 https https://github.com:username/repositoryname.git git git://github.com:username/repositoryname.git ssh git@github.com:username/repositoryname.git 请记住，你工作目录下的每一个文件都不外乎这两种状态：已跟踪 或 未跟踪。 已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后， 它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是 Git 已经知道的文件。 工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。 初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们。 用 git add 可以追踪新建文件，用 git rm 命令可以取消追踪文件。 追踪机制的好处是让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 检查当前文件状态123git statusgit status -sgit status --short 123456$ git status -s M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。 例如，上面的状态报告显示： README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile 文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。 跟踪新文件1git add &lt;files | directory&gt; git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 git add 是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来。 忽略文件一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 123$ cat .gitignore*.[oa]*~ 第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件 文件 .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。 1234567891011121314151617# 忽略所有的 .a 文件*.a# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件!lib.a# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO/TODO# 忽略任何目录下名为 build 的文件夹build/# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txtdoc/*.txt# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件doc/**/*.pdf 查看已暂存和未暂存的修改可以用 git diff 命令来回答两个问题： 当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 虽然 git status 已经通过在相应栏下列出文件名的方式回答了这个问题，但 git diff 能通过文件补丁的格式更加具体地显示哪些行发生了改变。 命令 git diff 比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容： 1git diff 命令 git diff --staged 将比对已暂存文件与最后一次提交的文件差异： 12git diff --stagedgit diff --cached # --staged 和 --cached 是同义词 请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 git diff 后却什么也没有，就是这个原因。 提交更新123git commitgit commit -v # 显示详细的内容修改提示git commit -m &quot;Commit message.&quot; 这样会启动你选择的文本编辑器来输入提交说明。 启动的编辑器是通过 Shell 的环境变量 EDITOR 指定的，一般为 vim 或 emacs。 当然也可以使用 git config --global core.editor 命令设置你喜欢的编辑器。 每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。 跳过使用暂存区域尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 git commit 加上 -a 选项（all，即commit包括工作区和暂存区），Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤： -a 选项使提交包含所有修改过的文件。 这很方便，但是要小心，有时这个选项会将不需要的文件添加到提交中。 移除文件如果文件处于未修改和暂存区无记录的状态，则可以删除文件： 1git rm &lt;files&gt; 这个命令会将文件从工作目录中删除，并将更改记录（“删除”这个操作记录，即取消跟踪）添加到暂存区。 也可以手动删除（rm &lt;files&gt;），然后再 git rm 或 git add 添加删除的记录到暂存区。 1git rm --cached README # 仅删除暂存区的记录，且取消追踪文件，但文件在文件目录中还在 如果要删除之前修改过或已经放到暂存区的文件，则必须使用强制删除选项 -f（译注：即 force 的首字母）。 移动文件1git mv &lt;file&gt; &lt;file | directory&gt; 查看提交历史1git log --pretty=oneline 撤销操作在 Git 中任何 已提交 的东西几乎总是可以恢复的。 修改提交信息1git commit --amend # 提交暂存区，同时可以修改上一次提交的信息 取消暂存的文件1git reset HEAD &lt;file&gt; 撤消对文件的修改撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）: 1git checkout -- &lt;file&gt; 请务必记得 git checkout -- &lt;file&gt; 是一个危险的命令。 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。 远程仓库的使用查看远程仓库12git remote # 列出你指定的每一个远程服务器的简写git remote -v # 会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL origin ——这是 Git 给你克隆的仓库服务器的默认名字。 添加远程仓库1git remote add &lt;shortname&gt; &lt;url&gt; # 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写 从远程仓库中抓取（fetch）与拉取（pull）1git fetch &lt;remote&gt; # 会抓取克隆（或上一次抓取）后新推送的所有工作 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你的当前分支设置了跟踪远程分支（阅读下一节和 Git 分支 了解更多信息）， 那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库1git push &lt;remote&gt; &lt;branch&gt; 只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取（fetch）他们的工作并将其合并进你的工作后才能推送。 查看某个远程仓库1git remote show &lt;remote&gt; 远程仓库的重命名与移除1git remote rename &lt;remote&gt; &lt;remote-new-name&gt; # 重命名 值得注意的是这同样也会修改所有远程跟踪 &lt;remote&gt; 仓库的分支的名字。 那些过去引用 &lt;remote&gt;/master 的现在会引用 &lt;remote-new-name&gt;/master。 12git remote rm &lt;remote&gt;git remote remove &lt;remote&gt; # 移除 一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。 打标签标签分类 轻量（lightweight）标签：可以有多个，一般填写版本号，如“v1.0”。 附注（annotated）标签：可以有多个，一般填写属性式标签，如修改日期、作者等。 123456789101112131415161718192021222324# 显示标签git tag # 显示所有标签git tag -l &quot;v1.8.*&quot; # 按特定模式查找标签git show &lt;tagname&gt; # 显示指定标签# 添加标签git log --pretty=oneline # 显示提交历史git tag v2.0 # 给当前版本打标签？git tag -a v1.4 4fdagga # 给4fdagga添加轻量标签git tag -a v1.4 -m &quot;Author:Burgess&quot; # 给v1.4添加附注标签# 推送标签（注意：直接git push不会推送标签）git push &lt;remote&gt; v1.4 # 将v1.4的标签推送到远程（比如origin）git push &lt;remote&gt; --tags # 推送所有不在远程仓库的标签# 删除本地标签git tag -d &lt;tagname&gt;# 删除远程标签git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; # 方法一。注意`:`前面有个空格git push &lt;remote&gt; --delete &lt;tagname&gt; # 方法二# checkout标签（用于修改旧版本的错误等）git checkout v2.0 # 最好不要这么用，会使你的仓库处于“分离头指针（detached HEAD）”的状态git checkout -b &lt;new-branch&gt; v2.0 # 将v2.0拉到新分支 特点： 本地标签和远程标签是分开管理的，直接 git push 不会推送标签。 Git 别名例如： 1234git config --global alias.co checkoutgit config --global alias.br branchgit config --global alias.ci commitgit config --global alias.st status 再例如： 1git config --global alias.unstage 'reset HEAD --' 这会使下面的两个命令等价： 12git unstage fileA # 取消暂存git reset HEAD -- fileA 总结Git 分支分支的本质是指针，当前分支为HARD指针所指向的分支。 注意：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 12345678git branch # 查看当前所有分支git branch testing # 创建新分支git checkout testing # 切换分支git checkout -b testing # 创建并切换分支git merge testing # 合并分支（先checkout到主分支master，这样testing分支会合并到master中）git branch -d testing # 删除分支git branch -D testing # 强制删除（未合并的）分支 解决合并冲突： 12git add # 合并时有冲突（两个分支修改了同一个地方），手动修改后git add解决冲突git mergetool # 打开合并分支图形化工具 12git branch --merged # 查看已合并到当前分支的分支（这些分支可以删掉）git branch --no-merged 123git branch -m old new # 分支重命名git branch -m new # 创建新分支git branch -M new # 强制创建新分支 远程分支","link":"/2021/08/06/0201.html"},{"title":"Linux 常用命令及相关问题","text":"Linux 常用命令准确地说应该是 Linux shell 常用命令 最常用的命令12345678910111213141516171819202122232425262728293031323334353637383940414243cd .. # 返回上一级目录cd # 返回根目录cd directory_name # 进入文件夹cd - # 返回上一次目录cd ~ # 普通用户进入 /home/&lt;user&gt; 文件夹，root 进入 /root 文件夹pwd # 显示当前目录ls # 显示当前文件夹下的文件和文件夹ls -a # 显示当前文件夹下的文件和文件夹，包括隐藏文件ls -l # 显示长信息，包括文件权限，修改时间等ls -i # 显示inode（物理索引）信息ls abc* # 列出以abc开头为文件名的所有文件rm # 删除mv # 移动cp # 拷贝mkdir directory_name # 创建文件夹mkdir -p dir1/dir2 # 递归创建文件夹touch filename # 创建文件./filename # 运行当前文件夹下的filename文件。如果不加“./”，则系统会到PATH宏下找文件？reboot # 重启su # 进入root模式（密码：root，也有可能初始没设置）exit # 如果是在root模式下，则会退出root；如果是普通用户模式下，则会退出系统sudo command_name #以root权限执行命令clear # 清屏reset # 应该是重启终端# 或者 ctrl+l 也可以清屏# ctrl+u 清除当前光标位置前面的输入apt installapt remove # 注意：慎用 apt-get autoremoveexport [-fnp][变量名称]=[变量设置值] # export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。env # 查看当前shell的所有环境变量whereis &lt;pkg_name&gt;which &lt;pkg_name&gt; # 可以用来查看命令实际运行的绝对路径lsof -i:ipv46_files # 查找网络文件的pidkill -9 pid # 杀死进程 管道常用命令 参考：https://www.jianshu.com/p/9c0c2b57cb73 顺序执行多条命令 1command1;command2;command3; 有条件的执行多条命令 1command1 &amp;&amp; command2 || command3 &amp;&amp;：如果前一条命令执行成功则执行下一条命令||：与&amp;&amp;命令相反，执行不成功时执行这个命令 $?：存储上一次命令的返回结果 12$ which git &gt; /dev/null &amp;&amp; git --help // 如果存在git命令，执行git --help命令$ echo $? 管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的正确输出（stdout）直接作为下一个进程的输入（stdin）。 eg： 12ls -l /etc | more # 分页打印 /etc 下的文件，按q退出netstat -an | grep &quot;ESTABLISHED&quot; # 查看当前建立连接的用户 选取命令cut123456cut -d '分隔字符' -f field // 用于分隔字符cut -c 字符范围[参数说明]-d : 后面接分隔字符,通常与 -f 一起使用-f : 根据-d 将信息分隔成数段，-f 后接数字 表示取出第几段-c : 以字符为单位取出固定字符区间的信息 grep功能：按行过滤 123456789101112131415grep [OPTION]... PATTERNS [FILE]...[OPTION]-a ：将binary文件以text文件的方式查找数据-w ：全字匹配-v ：反向搜索-l ：只打印含有关键词的文件的名称-L ：只打印不含有关键词的文件的名称-n ：显示行数-c ：统计多少行-A ：列出后面的邻行-B ：列出前面的邻行-C ：列出前后的邻行-E ：扩展正则表达式-e ：正则表达式 eg： 12345678910111213grep -i 'hello world' menu.h main.c # 查找，忽略大小写grep '^leo' /etc/passwd # 搜索 /etc/passwd 文件中开头是 leo 的行grep 'bash$' /etc/passwd # 搜索 /etc/passwd 文件中行尾是 bash 的行grep -E '^root|bash$' passwd # 多条件查找：passwd中以root开头或以bash结尾的行grep -l '123' *.[ch] # 在当前目录下的所有 .c 或 .h 文件中找指定字符串，若找到则其打印文件名cat /etc/dnsmasq.conf | grep -e '^[^#]' # 寻找文件的非注释行find . -name ’*.[ch]’ | xargs grep -l thingfind . -name ’*.[ch]’ -print0 | xargs -r -0 grep -l thing # 比上面更加安全的写法grep -l sprintf ‘find $HOME -name ’*.c’ -print‘ # 等价于下面的命令。find $HOME -name ’*.c’ -print | xargs grep -l sprintf # 寻找含有sprintf的.c文件 排序：sort1234567891011sort [OPTION]... [FILE]...[OPTION]-f ：忽略大小写的差异，例如A 与a 视为编码相同-b ：忽略最前面的空格部分-M ：以月份的名字来排序，例如JAN, DEC 等等的排序方法-n ：使用『纯数字』进行排序默认是以文字型态来排序的)-r ：反向排序-u ：过滤掉相同的行，类似uniq，但不相邻的也会过滤-t ：分隔符号，预设是用[tab] 键来分隔-k ：以那个区间(field) 来进行排序的意思 计数：wc功能：word count 计数 123456789wc [OPTION]... [FILE]...[OPTION]-l ：仅打印行数 newline-w ：仅打印词数 word-m ：仅打印字符数 character-L ：仅打印最大行长度-c ：仅打印字节数 eg： 1234567wc file.txt # 依次打印file.txt文件的newline, word, character数目wc file1.txt file2.txt # 分别依次打印file1.txt和file2.txt文件和总计的newline, word, character数目wc -l file.txt # 打印file.txt的行数# 结合管道ls | wc -l # 打印当前目录文件和目录总数ls -l | grep '^d' | wc -l # 打印当前目录下的目录总数ls -l | grep '^-' | wc -l # 打印当前目录下的文件总数 过滤紧邻重复行：uniq记忆：unique 功能：过滤紧邻重复行，没有真的删除 12345uniq [OPTION]... [INPUT [OUTPUT]][OPTION]-i ：忽略大小写的不同-c ：进行计数 eg： 123uniq file.txt # 过滤 file.txt 中的紧邻重复行uniq -c file.txt # 过滤 file.txt 中的紧邻重复行并计数touch file2.txt &amp;&amp; uniq file.txt &gt; file2.txt # 保存 file.txt 中删除紧邻重复行后的结果到 file2.txt 双向重定向命令：tee 123tee [-a] file[参数]-a : 以累加的方式，将数据加入file中 字符转换命令tr1234tr [-ds] set[参数]-d : 删除信息当中的set1这个字符串-s : 替换掉重复的字符 col1234col [-xb][参数]-x ： 将tab键换成对等的空格键-b : 在文字内有反斜杠(/)时，仅保留反斜杠最后接的那个字符 join123456join [-ti12] file1 file2 [参数]` -t : join 默认以空格符分隔数据，并且对比第一个字段的数据 ,如果两个文件相同，则将两条数据连成一行 -i : 忽略大小写的差异 -1 : 说明第一个文件通过那个字段来进行分析 -2 : 说明第二个文件通过那个字段来分析 paste1234paste [-d] file1 file2[ 参数]-d : 后面可以接分隔字符，默认以[tab]来分隔的- : 如果file部分写成-，表示接受standard input数据的意思 expand123expand [-t] file[参数]-t : 后面接数字，一般，一个tab可以用8个空格代替，可以自行定义代表几个空格 切割命令split12345split [-bl] file prefix [参数] -b : 后面可接欲切割文件的大小，可加单位，例如b,k,m等 -l : 以行数来进行切割 PREFIX : 代表前导符，可作为切割文件的前导文字 Vim 相关命令 vim是vi的升级版 命令行输入 vimtutor 就可以看到教程 基本操作 vim的三种模式 命令模式 其他模式下按Esc键可进入命令模式 输入模式 命令模式下按i或a或o可进入 “i”命令可以在当前光标之前插入文本。“a”命令可以在当前光标之后插入文本。（实测也是光标之前）“o”命令可以在当前行的下面另起一行，并使当前模式转为Insert模式。“O”命令(注意是大写的字母O)将在当前行的上面另起一行。 输入模式下，按Insert键可以选择插入模式（INSERT）还是替换模式（REPLACE） 底线命令模式 命令模式下输入:可进入，按回车结束运行 命令模式命令选择与跳转 命令 作用 gg 跳到文首 V 选择（Visual Line模式） G 跳到文尾（Ground） ggVG 全选 Visual Line下选择文本后，可执行以下命令： 命令 作用 d 删除 y 复制到&quot;剪切板 p 粘贴&quot;剪切板中的内容 “+y 复制到系统剪贴板(也就是vim的+寄存器） “+p 从系统剪贴板粘贴 删除 命令 作用 x 删除一个字符 dd 删除光标当前行 撤销与重做 命令 作用 u 撤销上一步操作 U 一次撤消对最后一次编辑的一行的全部操作。第二次使用该命令则会撤消前一个”U”的操作。 ctrl+r 重做（撤销撤销操作） 底线命令模式命令常用12345:wq! # 强制保存并退出:/keyword # 从上往下查找，按“n”跳到下一个，“*”和“.”可以模糊匹配:?keyword # 从下往上查找，按“n”跳到下一个:set nu # 显示行数（nu=number）:23 # 跳到第23行 编码与格式1234:set ff # 查看文件格式（fileformat）:set ff=unix # 设置文件格式为unix。解决文件无法执行问题。:set fileencoding # 查看文件编码:set fileencoding=utf-8 # 设置文件编码为utf-8。解决文件乱码问题。 输入模式命令暂无。 网络相关命令123456789101112writewallpingifconfigmaillast # 查看用户登录信息lastlogtraceroutenetstat # 显示网络相关信息netstat -rn # 查看路由列表，可以看到网关service network restart # 重启网络mount # 挂载（一般挂载在/mnt的某个子目录下） 相关文件123456789/etc/resolv.conf # 临时修改DNS/etc/systemd/resolved.conf # 一般是一个指向上面的软连接。永久修改DNS/etc/network/interface # 网络配置文件/etc/hosts # hosts 列表/etc/netplan/*.yaml # ubuntu用netplan配置网络# netplan try # 应用前先验证# netplan apply # 应用配置 测试123ping &lt;$IP|$DOMAIN&gt; # 注意ping使用的协议是ICMP，不是TCP或UDPftp &lt;$IP|$DOMAIN&gt;wget &lt;$IP|$DOMAIN&gt; 重启1234service network-manager restart # Ubuntuservice networking restart # Debiansystemctl restart systemd-resolved.servicesystemctl restart NetworkManager.service 查看状态12systemd-resolve --status # 会报错systemctl status systemd-resolved.service 其他命令1ps -ef | grep process_name # 列出系统中当前运行的名字包含process_name的进程 12uname -a # unix name：显示电脑以及操作系统的相关信息，或者uname -r # 查看linux内核版本 1chmod -R 777 file_foder_name # 修改文件或文件夹的权限 1man command_name # 查看命令的帮助文件 12echo $PATH # 查看环境变量PATHenv # 查看环境变量 scp 命令功能：跨服务器加密传文件 1234567# 在windows系统的cmd中# win -&gt; linuxscp -r E:\\file_foder_name debian@192.168.137.2:/home/AA/BB # 跨服务器加密复制文件夹scp E:\\AA\\BB\\filename debian@192.168.137.2:/home/AA/BB # 跨服务器加密复制文件# (win请求)linux -&gt; winscp -r debian@192.168.137.2:/home/AA/BB E:\\file_foder_name # 跨服务器加密复制文件夹scp debian@192.168.137.2:/home/AA/BB E:\\AA\\BB\\filename # 跨服务器加密复制文件 ln 命令12ln filename filename_lnk # 建立硬链接（Hard Link）ln -s filename filename_lnk # 建立软连接（Symbolic Link，符号链接） 软硬链接的区别：https://blog.csdn.net/yagamil/article/details/40076509 find 命令看手册 1find &lt;路径&gt; -name &quot;filename*&quot; -size +100k -print 123-iname # 忽略大小写-mindepth-maxdepth xargs 命令和find命令配合使用，见find手册 tar 命令tar.gz压缩： 1tar -zcvf 压缩文件名.tar.gz 被压缩文件名 解压缩： 1tar -zxvf 压缩文件名.tar.gz -C 解压路径（不含文件名） 各参数含义： -z：有gzip属性的 -x：解压 -v：显示所有过程 -f：使用档案名字（放最后） 参考：https://www.cnblogs.com/manong--/p/8012324.html tar解压： 1tar -xvf file.tar systemctl1234567891011121314151617181920212223242526272829systemctl list-units ##列出当前系统服务的状态systemctl list-unit-files ##列出服务的开机状态systemctl status sshd ##查看指定服务的状态systemctl stop sshd ##关闭指定服务systemctl start sshd ##开启指定服务systemctl restart sshd ##从新启动服务systemctl enable sshd ##设定指定服务开机开启systemctl disable sshd ##设定指定服务开机关闭systemctl reload sshd ##使指定服务从新加载配置systemctl list-dependencies sshd ##查看指定服务的倚赖关系systemctl mask sshd ##冻结指定服务systemctl unmask sshd ##启用服务systemctl set-default multi-user.target ##开机不开启图形systemctl set-default graphical.target ##开机启动图形setterm ##文本界面设定color 常用软件包及命令tree1tree # 显示目录树 shawdowsocks123sslocal -c /home/burgess/shadowsocks.conf -d start # 开启梯子sslocal -c /home/burgess/shadowsocks.conf -d stop # 关闭梯子sslocal -s server.com -p 8388 -k password # 添加或修改参数 注意中间替换成配置文件的路径（burgess是用户名） 一次性配置命令1sudo cp .bashrc /root/.bashrc # 在普通用户模式下使用。会使root模式下也有配色。 1sudo passwd # 修改root密码，要先输入当前用户登录密码 Linux 常用快捷键1234567891011ctrl+a ： 光标移动到命令行开头ctrl+e ： 光标移动到命令行结尾ctrl+c ： 强制终止当前命令ctrl+l ： 剪切光标之前的内容ctrl+k ： 剪切光标之后的内容ctrl+y ： 粘贴ctrl+l或ctrl+k剪切的内容ctrl+r ： 搜索历史命令ctrl+d ： 关闭当前终端ctrl+z ： 暂停并放入后台ctrl+s ： 暂停屏幕输出ctrl+q ： 恢复屏幕输出 Linux 通配符和其他特殊符号通配符123456789？ ：匹配一个任意字符* ：匹配零个或多个任意字符[] ：匹配中括号内的任意一个字符[-] ：匹配范围内的任意一个字符[^] ：匹配后取反 特殊符号1234567'' ：原封不动输出&quot;&quot; ：$、`和\\有特殊含义`` ：``中是系统命令。bash会先执行其中的命令$() ：与``一样，不容易看错# ：注释$ ：调用变量的值。或${}\\ ：转义符。取消特殊符号的特殊含义 Linux 正则表达式 正则表达式 不等于 通配符（wildcard） 正则表达式分基础的正则表达式（BRE，Basic Regexp）和扩展的正则表达式（ERE，Extended Regexp） 转义符\\能将正则表达式字符变成普通字符 12345678910* 前一个字符匹配0次或任意多次.. 匹配除了换行符外任意一个字符.^ 匹配行首. 例如：^hello 会匹配以 hello 开头的行.$ 匹配行尾. 例如：hello$ 会匹配以 hello 结尾的行.[] 匹配中括号中指定的任意一个字符，制匹配一个字符. 例如：[aoeiu] 匹配任意一个元音字母，[0-9] 匹配任意一位数字，[a-z][0-9]匹配小写字和一位数字构成的两位字符.[^] 匹配除中括号的字符以外的任意一个字符. 例如：[^0-9] 匹配任意一位非数字字符，[^a-z] 表示任意一位非小写字母.\\ 转义符. 用于取消特殊符号的含义.\\{n\\} 表示其前面的字符恰好出现 n 次. 例如：[0-9]\\{4\\} 匹配 4 位数字，[1][3-8][0-9]\\{9\\} 匹配手机号码.\\{n,\\} 表示其前面的字符出现不小于 n 次. 例如：[0-9]\\{2,\\}表示两位及以上的数字.\\{n,m\\} 表示其前面的字符至少出现 n 次，最多出现 m 次. 例如：[a-z]\\{6,8\\} 匹配6到8位的小写字母. Linux 输入输出重定向 设备 设备文件名 文件描述符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/stdout 1 标准输出 显示器 /dev/stderr 2 标准错误输出 输出重定向标准输出重定向 命令 &gt; 文件 ：以覆盖的方式写入命令的正确输出 命令 &gt;&gt; 文件 ：以追加的方式写入命令的正确输出 标准错误输出重定向 错误命令 2&gt; 文件 ：以覆盖的方式写入命令的错误输出 错误命令 2&gt;&gt; 文件 ：以追加的方式写入命令的错误输出 将正确输出和错误输出都保存在同一个文件中 1234命令 &gt; 文件 2&gt;&amp;1命令 &gt;&gt; 文件 2&gt;&amp;1命令 &amp;&gt; 文件命令 &amp;&gt;&gt; 文件 将正确输出和错误输出分开保存 12命令 &gt; 文件1 2&gt; 文件2命令 &gt;&gt; 文件1 2&gt;&gt; 文件2 不输出 1命令 &amp;&gt; /dev/null 输入重定向eg： 123wc # 键盘输入，统计行数等。按 ctrl+d 结束输入wc -l &lt; hello.txt # 统计 hello.txt 文件的行数wc &lt;&lt; hello # 用得很少，将键盘输入给wc命令，以hello为输入结束符 多命令顺序执行与管道符; &amp;&amp; || dd 命令 1dd if=infile of=outfile bs=bytes count=bytesnum 1命令 &amp;&amp; echo yes || echo no shell 变量变量不能以数字开头 bash中变量类型默认为字符串 变量的值有空格，需要用单引号或双引号括起来 变量分类 用户自定义变量 环境变量 位置参数变量：向脚本当中传递参数或数据的，变量名不能自定义，变量的作用固定 预定义变量：Bash中定义好的变量，变量名不能自定义，变量的作用固定 123echo $varname # 变量调用set # 查看所有变量unset varname # 删除变量 Linux Shell 脚本简介硬件-内核-shell-应用程序 分类： Bourne shell 系列：sh、ksh、bash、psh、zsh C shell 系列：csh、tcsh 1cat /etc/shells # 查看支持的shell shell 脚本文件头： 1#！/bin/bash 执行方法： 1234chmod 755 hello.sh./hello.sh# 或者bash hello.sh # 不需要执行权限就能执行 echo命令 123echo -e &quot;\\e[1;31mabcd\\e[0m&quot; # 红色输出abcd# 30m=黑色，31m=红色，32m=绿色，33m=黄色# 34m=蓝色，35m=洋红，36m=青色，37m=白色 注意 Linux 中的 shell 脚本回车符默认为 $，而 Windows 中默认为 ^M$ 1cat -A hello.sh # 打印文件内容，包括隐藏符号 转换文件可用 dos2unix 或 unix2dos 软件 12dos2unix hello.shunix2dos hello.sh 更多内容见 shell 脚本命令学习 Linux 相关问题git clone 下载的文件夹无法移动git clone之前忘记cd到合适的位置了，于是clone完之后想通过mv命令将文件夹移到它的上一级目录，但提示Permission denied，于是root模式下加了777权限，也不行，不知道为什么，最后删了重新下载。 更换软件源12sudo cp /etc/apt/sources.list /etc/apt/sources.list.backupvim /etc/apt/sources.list 然后将原有内容注释掉或删掉，再粘贴新的源即可。清华的debian镜像源如下 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free 手机 USB 共享网络手机网络设置通过USB共享网络。 12ifconfig # 或 ip a 查看手机usb网卡名称，假设为usb0sudo dhclient usb0 git clone 速度太慢方法有以下几种： 若是 https，则在 github.com 后面加 .cnpmjs.org。 把 https 换成 git 永久配置 DNS永久停止Ubuntu默认dns本地服务 12sudo systemctl disable --now systemd-resolvedvim /etc/NetworkManager/NetworkManager.conf 修改NetworkManager：在[main]节点下增加如下配置： 1dns=none # none 不会生成dns配置到/etc/resolve.conf，default 则会生成 设置default，否则每次重启会被系统自动重置/etc/resolve.conf为nameserver 127.0.0.53 重启NetworkManager： 1sudo systemctl restart NetworkManager 如果不行，删除 /etc/resolv.conf 文件（红色，符号链接到的源文件不存在），然后再重启网络，resolv.conf 文件会自动生成 Ubuntu20.04 中文输入法目标：想在不改变系统语言（英文）的情况下安装系统自带的中文输入法。 安装语言支持 Settings &gt; Region &amp; Language &gt; Manage Installed Languages &gt; Install / Remove Languages &gt; Chinese (Simplified) &gt; Apply ，将 Chinese (Simplified) 拖到 English 上方使其不变灰。然后Keyboard input method system &gt; IBus &gt; Close。 注意：添加完简体中文后，键盘布局中才能找到 Chinese (Intelligent Pinyin)。 添加键盘布局（输入方法） Settings &gt; Region &amp; Language &gt; Input Sources &gt; + &gt; Chinese &gt; Chinese (Intelligent Pinyin) &gt; Add。 设置系统语言（即终端、桌面和其他软件的语言） Settings &gt; Region &amp; Language &gt; Language &gt; English（随便哪一个都可以）。 重启。 平时切换输入法快捷方式为 Win + 空格。","link":"/2021/02/27/2346.html"},{"title":"PHP学习笔记","text":"Hello worldindex.php文件 123&lt;?php echo(&quot;Hello world!&quot;);?&gt; cmd运行 1php.exe -f &quot;E:\\server\\Apache24\\htdocs\\index.php&quot; 环境配置ApacheApache控制台程序路径为Apache24\\bin\\ApacheMonitor.exe。 httpd命令123httpd # 打开服务httpd -t # 测试配置文件语法httpd -M # 查看模块 httpd.conf配置文件12345678910Define SRVROOT &quot;E:/server/Apache24&quot;# 加载PHPLoadModule php7_module 'E:/server/php7/php7apache2_4.dll'# 加载PHP配置文件PHPIniDir 'E:/server/php7'# 分配任务给PHPAddType application/x-httpd-php .phpServerName localhost MySQL先将MySQL的安装路径下的bin文件夹路径添加到系统变量PATH中。 测试：MySQL客户端访问MySQL服务端（注意选项和值之间没有空格）： 1mysql -hlocalhost -P3306 -uroot -p密码 -hlocalhost -P3306可省略，密码可先不输入，即 1mysql -uroot -p PHPApache加载PHP，而PHP需要加载MySQL。在php.ini中修改或添加如下内容 123456789; 增加扩展路径extension_dir = &quot;E:/server/php7/ext&quot;;增加mysqli拓展;extension=php_mysql.dll ;这是php5的写法，php7用mysqli代替extension=mysqli; 增加时区date.timezone = PRC 然后修改index.php文件进行测试： 123&lt;?php phpinfo();?&gt; 然后重启Apache，浏览器输入localhost/index.php即可看到php信息页，其中能找到mysqli扩展，说明该扩展已成功加载。 虚拟主机分类 基于IP的虚拟主机（通过多个网卡来实现） 基于域名的虚拟主机（） PHP语法PHP代码标记 ASP标记 1&lt;% php代码 %&gt; 短标记 1&lt;? php代码 ?&gt; 脚本标记 1&lt;script language=&quot;php&quot;&gt;php代码&lt;/script&gt; 标准标记 1&lt;?php php代码 ?&gt; PHP注释 行注释：//或# 块注释：/* */ PHP语句分割符英文分号; 特殊说明： ?&gt;有语句结束的作用，因此最后一行可以不加;（不建议这么做）。 ?&gt;通常不加，这样后面的空行会被忽略，减少传输的数据量。 PHP变量数据库数据是原始数据，PHP变量用来传递数据库的数据，以便进行变量的处理。 1234567891011&lt;?php $var1; // 定义变量 $var2 = 1; // 定义同时赋值 echo $var2; // 访问变量 $var2 = 2; // 修改变量 echo '&lt;hr/&gt;', $var2; unset($var2); // 删除变量 变量名称可为中文（不建议） 预定义变量$_GET - 获取所有以GET方式提交的表单数据$_POST - POST提交的数据$_REQUEST - GET和POST提交的数据$GLOBALS - PHP中所有的全局变量$_SERVER - 服务器信息$_SESSION - session会话数据$_COOKIE - cookie会话数据$_ENV - 环境信息$_FILES - 用户上传的文件信息 可变变量例： 12345678&lt;? // 可变变量 // 定义两个变量 $a = 'b'; $b = 'lalal'; echo $$a; 最后会输出lalal 变量传值将一个变量赋值给另外一个变量 变量传值的方式： 值传递：两个变量有相同的值，但彼此没关系 12345&lt;?php $a = 1; $b = $a; $a = 2; echo $a, $b, '&lt;br/&gt;'; // 输出21 引用传递：让两个变量指向同一个地址 12345&lt;?php; $a = 1; $b = &amp;$a; $a = 2; echo $a, $b, '&lt;br/&gt;'; // 输出22 内存分区： 栈区：程序可以操作的内存部分（不存数据，只运行程序代码），少但是快 代码段：存储程序的内存部分（不执行） 数据段：存储普通数据（分为全局区和静态区） 堆区：存储复杂数据，大但是效率低 PHP常量常量定义方式 define('常量名', 常量值); const 常量名 = 常量值; 例： 123&lt;?php define('PI', 3.14); const PII = 3.14; 注意： 常量的命名规则比变量要松散，可以使用一些特殊字符，但只能用define()来定义，比如define('-_-', 'smile') define()和const定义的常量是有区别的（访问权限有区别） 用define()定义的常量默认不区分大小写，如果要区分的话，可以指定define()函数的第三个参数为true 常量访问方式 直接使用：echo PI 用constant()函数：echo constant('-_-') 系统常量例： 1echo PHP_VERSION, '&lt;br/&gt;', PHP_INT_SIZE, '&lt;br/&gt;', PHP_INT_MAX 魔术常量，值会跟着环境变化，但用户改变不了，例如 __DIR__ - 当前被执行脚本的绝对路径（不含文件名）__FILE__ - 当前被执行脚本的绝对路径（包含文件名）__LINE__ - 当前语句所属的行数__NAMESPACE__ - 当前所属的命名空间__CLASS__ - 当前所属的类__METHOD__ - 当前所属的方法 PHP数据类型PHP数据类型指的是存储的数据本身的类型。PHP是一种弱类型语言，变量本身没有数据类型。 类型分类 简单（基本）数据类型 整型 - int/integer，默认有符号 1234567&lt;?php $a = 120; // 十进制 $b = 0b110; // 二进制，b是binary $c = 0172; // 八进制 $d = 0x1a0; // 十六进制 echo $a, '~', $b, '~', $c, '~', $d; // PHP中默认以十进制输出 // 进制转换函数有`decbin()`、`dechex()`等 浮点型 - float/double，表示小数或整型存不下的整数 12345&lt;?php $f1 = 1.23; $f2 = 1.23e10; // 科学计数法 $f3 = PHP_INT_MAX + 1; // 超过整型能够存储的最大值后会用浮点型存储 var_dump($f1, $f2, $f3); 注意浮点型不能作精确判断 字符串型 - string 布尔类型 - bool/boolean，只有两个值：true或false 1234&lt;?php $b1 = true; $b2 = FALSE; // 大小写都行 var_dump($b1, $b2); 复合数据类型 对象 - object 数组 - array 特殊数据类型 资源 - resource，存放PHP外部数据，如数据库，文件 空 - NULL 伪类型 mixed - 多种类型，用在函数参数中 number 类型转换方式 自动转换 - 系统根据需求自己判断，自己转换（效率偏低） 1234&lt;?php $a = '1.1.1aaa'; $b = 'bbb2.2.2'; echo $a + $b; // 输出1.1 强制（手动）转换 123&lt;?php $a = '1.1.1aaa'; echo (int)$a; // 输出1.1 字符串转数值的规则 以字母开头的字符串，永远为0 以数字开头的字符串，取值到碰到字符或第二个小数点为止 类型判断用is_int()、is_bool()等函数，可配合var_dump()函数来使用，例： 1234&lt;?php $a = 'true'; echo is_bool($a); // 输出不显示 echo var_dump(is_bool($a)); // 输出bool(false) 还可以用gettype()来获取数据类型字符串，用settype()函数来永久改变数据的类型，如 12345&lt;?php $a = '1.1.1aaa'; echo gettype($a), '&lt;br/&gt;'; // 输出string settype($a, 'int'); echo gettype($a), '&lt;br/&gt;', $a; // 输出integer和1 最后，可用empty()函数来判断变量的值是否为真，用is_null()或isset()函数来判断变量是否被赋值了，具体可以查表。 PHP运算符 赋值运算符 = += -= *= /= %= .= - 将左边的变量和右边的变量连接起来，然后赋值给左边的变量 算数运算符 + - * / % 比较运算符 &gt; &gt;= &lt; &lt;= == - 数据大小相同，比如字符串’123’可以等于整型123 != === - 全等于，大小和数据类型都相同 ！== - 不全等于，大小和数据类型不都相同 逻辑运算符 &amp;&amp; || ! 连接运算符 . - 将两个变量连接到一起 错误抑制符 @ - 抑制错误输出，在语句前加即可，即@(语句) 三目运算符 表达式1?表达式2:表达式3 - 如果表达式1成立，则执行表达式2，否则执行表达式3 自操作运算符（可前置或后置） ++ -- 位运算符 &amp; | ~ - 按位非 ^ - 按位异或 &lt;&lt; - 按位左移，右边补零（相当于乘2） &gt;&gt; - 按位右移，左边全部补原来的符号位 计算机码 原码：二进制数据，首位为符号位（0位正，1位负） 反码：符号位不变，正数的反码为原码，负数的反码其他位取反 补码：正数的补码为原码，负数的补码为反码+1（计算机存储的是补码） PHP流程控制顺序结构分支结构if分支1234567if(条件表达式1){ // 满足条件表达式1后要执行的代码段}elseif(条件表达式2){ // 满足条件表达式2后要执行的代码段}else{ // 不满足以上所有条件表达式后要执行的代码段} switch分支1234567891011switch(变量){ case 值1: // 要执行的代码段 break; case 值1: // 要执行的代码段 break; default: // 要执行的代码段 break;} 循环结构for循环123for(表达式1;表达式2;表达式3){ // 循环体} 类似C++，各表达式作用如下 表达式1：初始化，多个语句用逗号隔开 表达式2：条件判断 表达式3：变量更新 经测试，括号中的变量是全局变量。 while循环123while(条件表达式){ // 循环体} do-while循环123do{ // 循环体}while(条件表达式); foreach循环针对数组。 循环控制循环控制：continue、break。switch中也能用，if中不能用。 流程控制替代语法HTML和PHP混搭 例：打印九九乘法表 1234567891011&lt;table border=2&gt; &lt;?php for($i = 1; $i &lt;= 9; $i++){ ?&gt; &lt;tr&gt; &lt;?php for($j = 1; $j &lt;= $i; $j++){ ?&gt; &lt;td&gt; &lt;?php echo $j . ' × ' . $i . ' = ' . $j * $i; ?&gt; &lt;/td&gt; &lt;?php } ?&gt; &lt;/tr&gt; &lt;?php } ?&gt;&lt;/table&gt; 替代语法： for(;;){可用for(;;):替代，}可用endfor;替代 1234567891011&lt;table border=2&gt; &lt;?php for($i = 1; $i &lt;= 9; $i++): ?&gt; &lt;tr&gt; &lt;?php for($j = 1; $j &lt;= $i; $j++): ?&gt; &lt;td&gt; &lt;?php echo $j . ' × ' . $i . ' = ' . $j * $i; ?&gt; &lt;/td&gt; &lt;?php endfor ?&gt; &lt;/tr&gt; &lt;?php endfor ?&gt;&lt;/table&gt; 同理，if、switch、for、while和foreach都有类似的替代语法（do-while没有）。 PHP文件包含在PHP脚本中包含另一个PHP文件。 文件包含的四种形式 include include_once - 若多次包含同一个文件，则只会在第一次遇到的时候包含 require - 与include基本相同 require_once - 与include_once基本相同 require和include的区别：require要求包含文件时必须成功包含，否则终止程序运行；而include则可继续执行。 语法 123&lt;?php include '文件名'; include('文件名'); 注意：包含的文件会单独进行编译，然后再包含到主程序中，因此包含的文件中若有语法错误，主程序中包含文件的语句前的代码段也能正常运行。 文件加载路径用绝对路径和相对路径的区别： 绝对路径效率低，但安全 相对路径效率高，但不安全 注意：嵌套包含的时候用相对路径容易出错。 PHP函数基本语法1234function 函数名($arg1, $arg2){ // 函数体 // return 返回值;} 注意： 函数的调用可在函数的定义之前，因为在代码编译的时候，函数会存入内存，然后程序执行的时候，在调用函数处系统便能找到内存中的对应函数，不会报错。 函数定义时参数可冗余，即在函数体中不使用。 函数体中可以调用其他函数。 函数返回值默认为NULL。 return可以在文件中使用，将结果提交给包含它的文件。 形参默认值1234function 函数名($arg1, $arg2 = 0){ // 函数体 // return 返回值;} 注意：默认值的定义要放在最后面，不能左边形参有默认值，而后面没有。 引用传递1234function 函数名($arg1, &amp;$arg2){ // 函数体 // return 返回值;} 注意：只有变量能够被引用传递！ 可变函数12345678&lt;?php function display(){ echo __FUNCTION__;}$func = 'display';$func(); // 可变函数 一般用于给函数传递函数（回调函数）。 匿名函数1234567// 定义$func = function(){ // 函数体};// 调用$func(); 闭包：closure。在函数中调用外部变量时用到。 匿名函数的作用：在函数内部定义匿名函数，并返回匿名函数。然后在函数外部就可以调用函数内部的匿名函数了。 PHP变量作用域的生存周期 全局变量 作用域：全局空间，函数内部一般不可访问 生存周期：脚本周期 局部变量 作用域：函数空间（局部空间） 生存周期：函数周期 超全局变量：系统预定义变量（$GLOBALS[]数组） 作用域：没有访问限制 在函数内部访问全局变量的方法： 通过传参 通过GLOBALS[]数组 12345678&lt;?php $arg = 'something';function display(){ echo $GLOBALS['arg']; // 函数内部访问全局变量的一种方法}display(); 通过在函数内部使用global关键字声明全局变量 如果在函数中global声明的变量在全局空间（外部）存在，则该变量指向外部的全局变量 如果在函数中global声明的变量在外部不存在，则系统会自动在全局空间（外部）定义一个全局变量，并让变量指向此全局变量 12345678910111213&lt;?php $arg1 = 'something';function display(){ global $arg1; echo $arg1; // 函数内部访问全局变量的一种方法 global $arg2; // 全局空间中不存在 $arg2 = ' new'; echo $arg2;}display(); // 输出 something newecho '&lt;br/&gt;', $arg2; // 输出 new 静态变量一般在函数中定义。在重复调用函数的时候，系统会自动跳过static关键字所在行，使得静态变量只初始化一次。 123456789&lt;?php function display(){ static $arg = 1; echo $arg++; } display(); // 输出1 display(); // 输出2 display(); // 输出3 PHP常用系统函数输出相关12print();print_r(); 时间相关123456&lt;?php echo date('Y 年 m 月 d 日 H:i:s', 132456789), '&lt;br/&gt;'; echo date('Y 年 m 月 d 日 H:i:s'), '&lt;br/&gt;'; echo time(), '&lt;br/&gt;'; // 当前时间戳 echo microtime(), '&lt;br/&gt;'; // 当前时间戳以及微秒数 echo strtotime('tomorrow 10 hours'), '&lt;br/&gt;'; // 字符串转时间戳 数学相关12345678910max();min();rand(); // 得到指定区间的随机整数mt_rand(); // 与rand一样，但效率更高round(); // 四舍五入ceil();floor();pow(); // 指数运算abs();sqrt(); 函数相关123456function_exists(); // 判断函数是否存在// 在函数内部使用func_get_arg(); // 获取函数中指定下标的参数（从0开始）func_get_args(); // 获取函数所有实参func_num_args(); // 获取函数实参数量 问题cmd操作1234e: # 转到E盘cd dir\\dir2 # 注意用反斜杠dir # 相当于lscommand /? # 查看帮助 端口被占用假设端口80倍占用 123netstat -aon | findstr “80” # 假设找到PID为5588的进程占用了80端口tasklist | findstr “5588” # 看看是什么进程taskkill /pid &quot;5588&quot; /f # 强制关闭进程 the requested operation has failed启动Apache控制台，然后左键图标，Start后出现此错误。一开始以为是80端口被占用了的缘故，后来发现是第一次运行Apache控制台时，Apache会向Windows中添加一项叫Apache2.4的服务，打开服务属性发现“可执行文件路径”与目前Apache文件路径不一致，通过修改注册表 1计算机\\HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Apache2.4 的ImagePath即可修复错误。 注意修改Apache配置文件后需要重启Apache才能生效（左键控制台图标-&gt;restart）。 如果添加了php配置文件php.ini，则需要重启Apache才能使php.ini的修改生效。 参考https://www.bilibili.com/video/BV18x411H7qD","link":"/2021/08/06/0201.html"},{"title":"Python学习笔记","text":"vscode Python环境配置 参考：你学Python 虚拟环境 看这一篇就够了 - 知乎 (zhihu.com) 安装Python 下载网址：Download Python | Python.org 注意：不要更改默认的安装路径（C:\\Users\\wbx\\AppData\\Local\\Programs\\Python）！！！否则环境配置很麻烦！！！ 安装Python扩展插件 在vscode扩展中搜索python进行安装 创建虚拟环境 在 python3.3 之前，只能通过 virtualenv 创建虚拟环境，首先需要安装 virtualenv 123pip install virtualenv# 或python -m pip install virtualenv 安装完后，在当前目录下创建一个名为 myvenv 的虚拟环境: 1virtualenv --no-site-packages myvenv 参数 --no-site-packages 的意思是创建虚拟环境时，不复制主环境中安装的第三方包，也就是创建一个 “干净的” 虚拟环境 virtualenv 还有很多参数，用于不同的使用场景，例如: -p: 用于指定 Python 解析器，就是安装好的 Python 应用程序，默认为当前环境中的 Python –no-pip：不需要安装 pip，默认为安装 –clear：如果创建虚拟环境的目录已经有了其他虚拟环境，清楚重建 Python3.3 之后，可以用模块 venv 代替 virtualenv 工具，好处是不用单独安装，3.3 及之后的版本，都可以通过安装好的 Python 来创建虚拟环境: 1python -m venv myvenv 可以在当前目录创建一个名为 myvenv 的虚拟环境 venv 有些参数，不过相比 virtualenv 少了些，这里简单介绍几个： –without-pip: 不需要安装 pip，默认为安装 –clear：如果创建虚拟环境的目录已经有了其他虚拟环境，清楚重建 因为 venv 是依附于一个 Python 解析器创建的，所以不需要指定 Python 解释器版本 注意：使用之前创建好的虚拟环境前，要查看myvenv\\pyvenv.cfg文件，看解释器的版本是否一致，路径是否一致。若解释器版本不一致或者路径发生变化，则建议重装虚拟环境。 激活虚拟环境 在Windows下，用PowerShell运行myenv\\Scripts下的Activate.ps1即可（或者直接运行activate文件）： 1.\\myenv\\Scripts\\Activate.ps1 若出现“无法加载文件 ..\\myvenv\\Scripts\\Activate.ps1，因为在此系统上禁止运行脚本”的错误，则需要先在PowerShell中运行Set-ExecutionPolicy RemoteSigned。 字符串12345678910string = &quot; my name &quot;string.title() # 每个单词的首字母大写（临时）string.upper() # 全部大写（临时）string.lower() # 全部小写（临时）string.rstrip() # 删除右侧的空格（临时）string.lstrip() # 删除左侧的空格（临时）string.strip() # 删除两侧的空格（临时）str(123) # 数字转字符串 列表1234567891011121314151617181920212223242526272829303132333435363738394041list1 = ['a', 'b', 'c', 123]list1.append('e') # 增加一个元素（永久）list1.insert(0, 'v') # 在索引0处插入元素（其他元素右移）（永久）popped = list1.pop() # 弹出列表的最后一个元素（原列表中的元素会被删除）（永久）popped = list1.pop(1) # 弹出列表的第二个元素list1.remove('b') # 删除指定元素（只删除出现的第一个）（永久）list1.sort() # 按字母顺序排序（永久。仅支持字符串！）list1.sort(reverse=True) # 按字母逆序排序（永久）list1.sorted() # 按字母顺序排序（临时）list1.sorted(reverse=True) # 按字母逆序排序（临时）list1.reverse() # 反转列表排列顺序（永久）# 列表操作list1 = ['a', 'b', 'c', 123]print(list1[0]) # 返回第一个元素print(list1[-1]) # 返回最后一个元素print(list1[:3]) # 返回前四个元素所构成的列表print(list1[1:]) # 返回第二个到最后一个元素所构成的列表print(list1[-3:]) # 返回最后三个元素所构成的列表print(list1[:]) # 返回原列表副本list2 = list1 # list2和list1指向同一个列表list1[0] = 'A' # 将第一个元素修改为Adel list1[3] # 删除元素len(list1) # 列表长度min(numbers)max(numbers)sum(numbers)# 遍历列表：for语句for list1_ in list1: # 执行完后list_的值为list1[-1] passfor value in range(1,5): print(value) # 打印数字1~4numbers = [value**2 for value in range(1,5)] # 用“列表解析”法生成数字列表[1,4,9,16]numbers = list(range(1,5)) # 生成数字列表[1,2,3,4]numbers = list(range(1,5,2)) # 生成数字列表[1,3]，2为步长if 'a' in list1: # 判断元素'a'是否在列表中 passif list1: # 检查列表是否为空 print(&quot;list1 is not None.&quot;) 元组123# 元组# 元组和列表的操作类似# 元组元素不可修改，但元组变量可以重新赋值 字典12345678910111213141516171819202122232425rec1 = {'x': 20, 'y': 10}print(rec1.items()) # dict_items([('x', 20), ('y', 10)])print(rec1.keys()) # dict_keys(['x', 'y'])print(rec1.values()) # dict_values([20, 10])# 字典# 特点：动态、无顺序alien_0 = {'color': 'green', 'points': 5}print(alien_0['color'])alien_0['color'] = 'blue' # 修改字典中的值alien_0['x'] = 0 # 添加键值对del alien_0['points'] # 删除键值对（永久）# 遍历字典for key, value in alien_0.items(): # 遍历字典的键值对 print(&quot;key: &quot; + key) print(&quot;value: &quot; + value)for key in alien_0.keys(): # 遍历字典的键名 print(key)for key in sorted(alien_0.keys()): # 用sorted函数对键进行临时排序 print(key)for value in alien_0.values(): # 遍历字典的键值 print(value)for value in set(alien_0.values()): # 转换为集合（集合没有重复） print(value) if语句123456789101112131415# if语句# 多条件——且：用`and`连接；或：用`or`连接；可用小括号定义执行顺序# 真：True；假：Falseage = '23'if age == '23': print(&quot;age == '23'&quot;)if '3' in age: print(&quot;'3' in age&quot;)if '3' not in age: print(&quot;'3' not in age&quot;)elif '2' not in age: print(&quot;'2' not in age&quot;)else: pass while语句Python之禅12# 体会一下Python之禅&gt;&gt;&gt; import this 代码格式Python改进提案（Python Enhancement Proposal， PEP） 每级缩进都使用四个空格（可将输入的制表符转换为指定数量的空格） 每行不超过80字符，注释的行长都不超过72字符（可添加字符提示线） 要将程序的不同部分分开，可使用空行 基础语法 参考：https://www.w3cschool.cn/python3/python3-tutorial.html 编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码： 1# -*- coding: cp-1252 -*- 标识符 第一个字符必须是字母表中字母或下划线’_’。 标识符的其他的部分有字母、数字和下划线组成。 标识符对大小写敏感。 在 Python 3中，非 -ASCII 编码的标识符也是允许的了。 Python 保留字保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword module，可以输出当前版本的所有保留字： 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释Python 中单行注释以 # 开头，多行注释采用三对单引号（’’’）或者三对双引号（”””）将注释括起来。 缩进Python 最具特色的就是使用缩进来表示代码块。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。 标准数据类型Python 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 字符串 Python 中单引号和双引号使用完全相同。 使用三对引号(‘’’或”””)可以囊括一个多行字符串。 转义符 ‘' 自然字符串， 通过在字符串前加 r 或 R。 如 r”this is a line with \\n” 则\\n会显示，并不是换行。 Python 允许处理 unicode 字符串，加前缀 u 或 U， 如 u”this is an unicode string”。 字符串是不可变的。 按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量 [头下标: 尾下标: 步长] 1234word = '字符串'sentence = &quot;这是一个句子。&quot;paragraph = &quot;&quot;&quot;这是一个段落，可以由多行组成&quot;&quot;&quot; 实例： 1234567891011121314151617#!/usr/bin/python3 str='Runoob' print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始后的所有字符print(str[1:5:2]) # 输出从第二个开始到第五个且每隔两个的字符print(str * 2) # 输出字符串两次print(str + '你好') # 连接字符串 print('------------------------------') print('hello\\nrunoob') # 使用反斜杠(\\)+n转义特殊字符print(r'hello\\nrunoob') # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 这里的 r 指 raw，即 raw string，会自动将反斜杠转义，例如： 1234&gt;&gt;&gt; print('\\n') # 输出空行&gt;&gt;&gt; print(r'\\n') # 输出 \\n&gt;&gt;&gt;\\n 以上实例输出结果： 123456789101112RunoobRunooRnoonoobuoRunoobRunoobRunoob你好------------------------------hellorunoobhello\\nrunoob 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入执行下面的程序在按回车键后就会等待用户输入： 实例: 123#!/usr/bin/python3 input(&quot;\\n\\n按下 enter 键后退出。&quot;) 以上代码中 ，”\\n\\n”在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。 同一行显示多条语句Python 可以在同一行中使用多条语句，语句之间使用分号 (;) 分割，以下是一个简单的实例： 实例: 123#!/usr/bin/python3 import sys; x = 'runoob'; sys.stdout.write(x + '\\n') 使用脚本执行以上代码，输出结果为： 1runoob 使用交互式命令行执行，输出结果为： 123&gt;&gt;&gt; import sys; x = 'runoob'; sys.stdout.write(x + '\\n')runoob7 此处的 7 表示字符数。 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之代码组。 像 if、while、def 和 class 这样的复合语句，首行以关键字开始，以冒号 ( : ) 结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句 (clause)。 如下实例： 123456if expression : suiteelif expression : suite else : suite print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=””： 实例: 12345678910111213#!/usr/bin/python3 x=&quot;a&quot;y=&quot;b&quot;# 换行输出print( x )print( y ) print('---------')# 不换行输出print( x, end=&quot; &quot; )print( y, end=&quot; &quot; )print() 以上实例执行结果为： 1234ab---------a b import 与 from…import在 Python 用 import 或者 from…import 来导入相应的模块。 将整个模块 (somemodule) 导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 导入 sys 模块123456import sysprint('================Python import mode==========================')print ('命令行参数为:')for i in sys.argv: print (i)print ('\\n python 路径为',sys.path) 导入 sys 模块的 argv,path 成员1234from sys import argv,path # 导入特定的成员 print('================python from import===================================')print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 命令行参数很多程序可以执行一些操作来查看一些基本信息，Python 可以使用 -h 参数查看各参数帮助信息： 123456789$ python -husage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...Options and arguments (and corresponding environment variables):-c cmd : program passed in as string (terminates option list)-d : debug output from parser (also PYTHONDEBUG=x)-E : ignore environment variables (such as PYTHONPATH)-h : print this help message and exit[ etc. ] 文件/文件夹操作读取文件有以下三种方式 TIPS：VScode最好在powershell终端中运行python程序，不要在cmd中运行，否则不能输入且中文会乱码 1234567891011121314151617filename = 'testfile.txt'# 打印整个文件with open(filename, encoding='utf-8') as file_obj: print(file_obj.read())# 逐行读取文件并打印with open(filename, encoding='utf-8') as file_obj: for line in file_obj: print(line.rstrip())# 按行创建列表，然后打印with open(filename, encoding='utf-8') as file_obj: lines = file_obj.readlines()for line in lines: print(line.rstrip()) 其中，rstrip()函数是删除字符串右边的字符，默认为空格（实测发现会将换行符也删掉）。类似的函数还有lstrip()和strip()，分别是删除左侧的字符和两侧的字符。 写入文件12345678910111213filename = 'programming.txt'with open(filename, 'w') as file_obj: file_obj.write( &quot;I love programming,\\n&quot; &quot;and I love python,\\n&quot; &quot;which is great.&quot; )# 或者with open(filename, 'w') as file_obj: file_obj.write(&quot;I love programming,\\n&quot;) file_obj.write(&quot;and I love python,\\n&quot;) file_obj.write(&quot;which is great.&quot;) 打开文件的模式（默认只读）： 读取模式：r 写入模式：w（文件已存在时会在返回文件对象前清空文件） 附加模式：a 读取和写入模式：r+ 文件夹操作123456import osdef createDirectory(directory): if not os.path.exists(directory): os.makedirs(directory) return 1234567891011121314os.path.isabs() # 判断是否绝对路径os.path.exists() # 判断是否真实存在os.path.isdir() # 判断是否是个目录os.path.isfile() # 判断是否是个文件os.path.split() # 分隔目录和文件名/文件夹名os.path.splitdrive() # 分隔盘符(windows系统)os.path.splitext() # 分隔文件和扩展名 os.getcwd() # 获取当前工作目录os.chdir() # 改变工作目录os.listdir() # 列出目录下的文件os.mkdir() # 创建单个目录os.makedirs() # 创建多级目录 方法 说明 os.path.abspath(path) 返回绝对路径 os.path.basename(path) 返回文件名 os.path.commonprefix(list) 返回list(多个路径)中，所有path共有的最长的路径 os.path.dirname(path) 返回文件路径 os.path.exists(path) 如果路径 path 存在，返回 True；如果路径 path 不存在，返回 False。 os.path.lexists 路径存在则返回True,路径损坏也返回True os.path.expanduser(path) 把path中包含的”“和”user”转换成用户目录 os.path.expandvars(path) 根据环境变量的值替换path中包含的”$name”和”${name}” os.path.getatime(path) 返回最近访问时间（浮点型秒数） os.path.getmtime(path) 返回最近文件修改时间 os.path.getctime(path) 返回文件 path 创建时间 os.path.getsize(path) 返回文件大小，如果文件不存在就返回错误 os.path.isabs(path) 判断是否为绝对路径 os.path.isfile(path) 判断路径是否为文件 os.path.isdir(path) 判断路径是否为目录 os.path.islink(path) 判断路径是否为链接 os.path.ismount(path) 判断路径是否为挂载点 os.path.join(path1[, path2[, …]]) 把目录和文件名合成一个路径 os.path.normcase(path) 转换path的大小写和斜杠 os.path.normpath(path) 规范path字符串形式 os.path.realpath(path) 返回path的真实路径 os.path.relpath(path[, start]) 从start开始计算相对路径 os.path.samefile(path1, path2) 判断目录或文件是否相同 os.path.sameopenfile(fp1, fp2) 判断fp1和fp2是否指向同一文件 os.path.samestat(stat1, stat2) 判断stat tuple stat1和stat2是否指向同一个文件 os.path.split(path) 把路径分割成 dirname 和 basename，返回一个元组 os.path.splitdrive(path) 一般用在 windows 下，返回驱动器名和路径组成的元组 os.path.splitext(path) 分割路径，返回路径名和文件扩展名的元组 os.path.splitunc(path) 把路径分割为加载点与文件 os.path.walk(path, visit, arg) 遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数 os.path.supports_unicode_filenames 设置是否支持unicode路径名 问题python -m pip 和 pip 的区别以及在虚拟环境中的情况在能执行成功的情况下一般没有区别。实际有没有区别应该看Windows的环境变量PATH包含了哪些路径以及路径的顺序如何。在PowerShell中可通过命令 1$env:path 查看PATH变量。 如果在Windows的环境变量PATH中添加有python.exe所在的目录C:\\Users\\wbx\\AppData\\Local\\Programs\\Python\\Python37，则在PowerShell中能使用python开头的命令；同样，如果在Windows的环境变量PATH中添加有pip.exe所在的目录C:\\Users\\wbx\\AppData\\Local\\Programs\\Python\\Python37\\Scripts，则在PowerShell下能使用pip开头的命令。 在Python的虚拟环境下，python.exe和pip.exe都放在venv/Script目录下，激活后该路径会被临时添加到环境变量PATH的开头，因此这时候执行python或pip开头的命令的实质都是调用venv/Script目录下的可执行程序。 注意： venv/Script目录下的python.exe的作用应该是调用系统环境中的python.exe，但pip.exe应该是独立的。 若venv/Script目录下的pip.exe被删除，则激活虚拟环境并执行pip命令后，系统会在PATH变量中搜寻有pip.exe的目录并执行，因此虽然此时虚拟环境已经激活（表现为命令行当前路径前面有类似(venv)的标志），但实际执行的pip.exe却不是虚拟环境下的。 参考：理解Python虚拟环境 - 知乎 (zhihu.com) 虚拟环境的升级与迁移迁移方法见升级python版本和搭建环境 - 云+社区 - 腾讯云 (tencent.com)。 注意：虚拟环境是与解释器的版本关联的，因此假设Python从3.7.3升级到3.7.4，那么虚拟环境也应该重新搭建，否则会出现一些奇奇怪怪的问题。 参考 https://www.w3cschool.cn/python3/python3-tutorial.html 《Python编程：从入门到实践》","link":"/2021/08/06/0201.html"},{"title":"ROS 学习笔记","text":"常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182roscore # 启动rosps -ef | grep -i rosmaster # 查看roscore有没有在运行roswtf # 检查错误 rospack find [package_name] # 返回软件包的所在路径roscd [package] &amp;&amp; rosdep install [package] # 下载并安装ROS packages所需要的系统依赖项roscd [locationname[/subdir]] # 切换目录（cd）到某个软件包或者软件包集当中# 注意：roscd只能切换到那些路径已经包含在ROS_PACKAGE_PATH环境变量中的软件包echo $ROS_PACKAGE_PATH # 查看 ROS_PACKAGE_PATH 中包含的路径。# 输出结果：每个路径之间用冒号（:）分隔开来roscd log # 进入日志目录rosls [locationname[/subdir]] # 直接按软件包的名称执行 ls 命令（而不必输入绝对路径）# 脚本执行命令source &lt;dir&gt;/setup.*sh # 读取脚本中的命令，并在当前shell中执行（无需执行权限）. &lt;dir&gt;/setup.*sh # 同上sh &lt;dir&gt;/setup.*sh # 打开一个subshell，读取并执行脚本中的命令（无需执行权限）./&lt;dir&gt;/setup.*sh # 打开一个subshell，并执行脚本中的命令（需要有执行权限）catkin_makecatkin_make install # （可选）catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3] # 创建包# 节点rosnode list # 列出当前运行的节点rosnode info /node_name # 显示节点/node_name的信息rosnode ping /node_namerosnode kill /node_name # 杀死进程rosnode cleanup # 清除无效进程？rosrun [package_name] [node_name]# 例如 rosrun turtlesim turtlesim_noderosrun [package_name] [node_name] ————name:=&lt;customized_name&gt; # 运行并自定义节点名字rosrun rqt_graph rqt_graph # 用图形显示当前运行的节点和话题rosrun rqt_console rqt_console # 连接到了ROS的日志框架，以显示节点的输出信息rosrun rqt_logger_level rqt_logger_level # 允许我们在节点运行时改变输出信息的详细级别# 话题rostopic bw # display bandwidth used by topicrostopic delay # display delay of topic from timestamp in headerrostopic echo /topic_name # print messages to screenrostopic find # find topics by typerostopic hz # display publishing rate of topic rostopic info # print information about active topicrostopic list [-v] # list active topicsrostopic pub [topic] [msg_type] [args] # publish data to topic# 例：rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- # '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'rostopic type # print topic or field type# 话题类型（消息）rosmsg show [pkg/msg] # 查看消息的详细信息（数据结构）。可以不含包前缀来查找# 服务rosservice list # 输出活跃服务的信息rosservice call [service] [args] # 用给定的参数调用服务rosservice type [service] # 输出服务的类型rosservice find # 按服务的类型查找服务rosservice uri # 输出服务的ROSRPC uri# 服务类型rossrv show [pkg/srv] # 输出服务的详细信息（数据结构）。可以不含包前缀来查找# 参数服务器rosparam set [param_name] [value] # 设置参数rosparam get [param_name] # 获取参数rosparam get / # 获取参数服务器上所有参数的值rosparam load [file_name] [namespace] # 从文件中加载参数rosparam dump [file_name] [namespace] # 向文件中转储参数rosparam delete [param_name] # 删除参数rosparam list # 列出参数名roslaunch [package] [filename.launch] # roslaunch命令会自动查找经过的包并检测可用的启动文件rosed [package_name] [filename] # 直接通过软件包名编辑包中的文件（rosed默认的编辑器是vim）rosbag record -a # 记录所有话题消息（在当前目录）在一个bag文件中rosbag info &lt;your bagfile&gt; # 查看bag文件信息rosbag play &lt;your bagfile&gt; # 回放bag文件以再现系统运行过程rosbag record -O subset /turtle1/cmd_vel /turtle1/pose # 订阅两个话题，记录到subset.bag文件time rosbag play --immediate demo.bag --topics /topic1 /topic2 /topic3 /topicN 计算图计算图（Computation Graph）是一个由ROS进程组成的点对点网络，它们能够共同处理数据。ROS的基本计算图概念有节点（Nodes）、主节点（Master）、参数服务器（Parameter Server）、消息（Messages）、服务（Services）、话题（Topics）和袋（Bags），它们都以不同的方式向图（Graph）提供数据。 节点（Nodes）：节点是一个可执行文件，它可以通过ROS来与其他节点进行通信。 消息（Messages）：订阅或发布话题时所使用的ROS数据类型。 话题（Topics）：节点可以将消息发布到话题，或通过订阅话题来接收消息。 主节点（Master）：ROS的命名服务，例如帮助节点发现彼此。 rosout：在ROS中相当于stdout/stderr（标准输出/标准错误）。 roscore：主节点 + rosout + [参数服务器](http://wiki.ros.org/Parameter Server)（会在以后介绍）。 msg和srv msg（消息）：msg文件就是文本文件，用于描述ROS消息的字段。它们用于为不同编程语言编写的消息生成源代码。 srv（服务）：一个srv文件描述一个服务。它由两部分组成：请求（request）和响应（response）。 msg文件存放在软件包的msg目录下，srv文件则存放在srv目录下。 msg文件就是简单的文本文件，每行都有一个字段类型和字段名称。srv文件和msg文件一样，只是它们包含两个部分：请求和响应。这两部分用一条---线隔开。 msg和srv的一般步骤如果没做过上面的教程，请先修改下CMakeLists.txt： 1234# generate_messages(# DEPENDENCIES# # std_msgs # Or other packages containing msgs# ) 取消注释，然后添加任意你的消息用到的包含.msg文件的软件包（本例中为std_msgs），如下所示： 1234generate_messages( DEPENDENCIES std_msgs) 现在我们已经创建了一些新消息，所以需要重新make一下软件包： 12345# In your catkin workspace$ roscd beginner_tutorials$ cd ../..$ catkin_make$ cd - msg目录中的任何.msg文件都将生成所有支持语言的代码。C++消息的头文件将生成在~/catkin_ws/devel/include/beginner_tutorials/。Python脚本将创建在~/catkin_ws/devel/lib/python2.7/dist-packages/beginner_tutorials/msg。而Lisp文件则出现在~/catkin_ws/devel/share/common-lisp/ros/beginner_tutorials/msg/。 类似地，srv目录中的任何.srv文件都将生成支持语言的代码。对于C++，头文件将生成在消息的头文件的同一目录中。对于Python和Lisp，会在msg目录旁边的srv目录中。 编写简单的发布者和订阅者talker.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;#include &lt;sstream&gt;/** * This tutorial demonstrates simple sending of messages over the ROS system. */int main(int argc, char **argv){ /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, &quot;talker&quot;); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The advertise() function is how you tell ROS that you want to * publish on a given topic name. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. After this advertise() call is made, the master * node will notify anyone who is trying to subscribe to this topic name, * and they will in turn negotiate a peer-to-peer connection with this * node. advertise() returns a Publisher object which allows you to * publish messages on that topic through a call to publish(). Once * all copies of the returned Publisher object are destroyed, the topic * will be automatically unadvertised. * * The second parameter to advertise() is the size of the message queue * used for publishing messages. If messages are published more quickly * than we can send them, the number here specifies how many messages to * buffer up before throwing some away. */ ros::Publisher chatter_pub = n.advertise&lt;std_msgs::String&gt;(&quot;chatter&quot;, 1000); ros::Rate loop_rate(10); /** * A count of how many messages we have sent. This is used to create * a unique string for each message. */ int count = 0; while (ros::ok()) { /** * This is a message object. You stuff it with data, and then publish it. */ std_msgs::String msg; std::stringstream ss; ss &lt;&lt; &quot;hello world &quot; &lt;&lt; count; msg.data = ss.str(); ROS_INFO(&quot;%s&quot;, msg.data.c_str()); /** * The publish() function is how you send messages. The parameter * is the message object. The type of this object must agree with the type * given as a template parameter to the advertise&lt;&gt;() call, as was done * in the constructor above. */ chatter_pub.publish(msg); ros::spinOnce(); loop_rate.sleep(); ++count; } return 0;} 过程 初始化ROS系统 向主节点宣告我们将要在chatter话题上发布std_msgs/String类型的消息 以每秒10次的速率向chatter循环发布消息 listener.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &quot;ros/ros.h&quot;#include &quot;std_msgs/String.h&quot;/** * This tutorial demonstrates simple receipt of messages over the ROS system. */void chatterCallback(const std_msgs::String::ConstPtr&amp; msg){ ROS_INFO(&quot;I heard: [%s]&quot;, msg-&gt;data.c_str());}int main(int argc, char **argv){ /** * The ros::init() function needs to see argc and argv so that it can perform * any ROS arguments and name remapping that were provided at the command line. * For programmatic remappings you can use a different version of init() which takes * remappings directly, but for most command-line programs, passing argc and argv is * the easiest way to do it. The third argument to init() is the name of the node. * * You must call one of the versions of ros::init() before using any other * part of the ROS system. */ ros::init(argc, argv, &quot;listener&quot;); /** * NodeHandle is the main access point to communications with the ROS system. * The first NodeHandle constructed will fully initialize this node, and the last * NodeHandle destructed will close down the node. */ ros::NodeHandle n; /** * The subscribe() call is how you tell ROS that you want to receive messages * on a given topic. This invokes a call to the ROS * master node, which keeps a registry of who is publishing and who * is subscribing. Messages are passed to a callback function, here * called chatterCallback. subscribe() returns a Subscriber object that you * must hold on to until you want to unsubscribe. When all copies of the Subscriber * object go out of scope, this callback will automatically be unsubscribed from * this topic. * * The second parameter to the subscribe() function is the size of the message * queue. If messages are arriving faster than they are being processed, this * is the number of messages that will be buffered up before beginning to throw * away the oldest ones. */ ros::Subscriber sub = n.subscribe(&quot;chatter&quot;, 1000, chatterCallback); /** * ros::spin() will enter a loop, pumping callbacks. With this version, all * callbacks will be called from within this thread (the main one). ros::spin() * will exit when Ctrl-C is pressed, or the node is shutdown by the master. */ ros::spin(); return 0;} 过程 初始化ROS系统 订阅chatter话题 开始spin自循环，等待消息的到达 当消息到达后，调用chatterCallback()函数 CMakeLists.txt1234567891011121314151617181920212223242526cmake_minimum_required(VERSION 2.8.3)project(beginner_tutorials)## Find catkin and any catkin packagesfind_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs genmsg)## Declare ROS messages and servicesadd_message_files(FILES Num.msg)add_service_files(FILES AddTwoInts.srv)## Generate added messages and servicesgenerate_messages(DEPENDENCIES std_msgs)## Declare a catkin packagecatkin_package()## Build talker and listenerinclude_directories(include ${catkin_INCLUDE_DIRS})add_executable(talker src/talker.cpp)target_link_libraries(talker ${catkin_LIBRARIES})add_dependencies(talker beginner_tutorials_generate_messages_cpp)add_executable(listener src/listener.cpp)target_link_libraries(listener ${catkin_LIBRARIES})add_dependencies(listener beginner_tutorials_generate_messages_cpp) 编写简单的服务和客户端add_two_ints_server.cpp1234567891011121314151617181920212223#include &quot;ros/ros.h&quot;#include &quot;beginner_tutorials/AddTwoInts.h&quot;bool add(beginner_tutorials::AddTwoInts::Request &amp;req, beginner_tutorials::AddTwoInts::Response &amp;res){ res.sum = req.a + req.b; ROS_INFO(&quot;request: x=%ld, y=%ld&quot;, (long int)req.a, (long int)req.b); ROS_INFO(&quot;sending back response: [%ld]&quot;, (long int)res.sum); return true;}int main(int argc, char **argv){ ros::init(argc, argv, &quot;add_two_ints_server&quot;); ros::NodeHandle n; ros::ServiceServer service = n.advertiseService(&quot;add_two_ints&quot;, add); ROS_INFO(&quot;Ready to add two ints.&quot;); ros::spin(); return 0;} add_two_ints_client.cpp123456789101112131415161718192021222324252627282930#include &quot;ros/ros.h&quot;#include &quot;beginner_tutorials/AddTwoInts.h&quot;#include &lt;cstdlib&gt;int main(int argc, char **argv){ ros::init(argc, argv, &quot;add_two_ints_client&quot;); if (argc != 3) { ROS_INFO(&quot;usage: add_two_ints_client X Y&quot;); return 1; } ros::NodeHandle n; ros::ServiceClient client = n.serviceClient&lt;beginner_tutorials::AddTwoInts&gt;(&quot;add_two_ints&quot;); beginner_tutorials::AddTwoInts srv; srv.request.a = atoll(argv[1]); srv.request.b = atoll(argv[2]); if (client.call(srv)) // 如果没有服务器，不会阻塞，因此服务器要先开 { ROS_INFO(&quot;Sum: %ld&quot;, (long int)srv.response.sum); } else { ROS_ERROR(&quot;Failed to call service add_two_ints&quot;); return 1; } return 0;} CMakeLists.txt1234567add_executable(add_two_ints_server src/add_two_ints_server.cpp)target_link_libraries(add_two_ints_server ${catkin_LIBRARIES})add_dependencies(add_two_ints_server beginner_tutorials_gencpp)add_executable(add_two_ints_client src/add_two_ints_client.cpp)target_link_libraries(add_two_ints_client ${catkin_LIBRARIES})add_dependencies(add_two_ints_client beginner_tutorials_gencpp) 问题rosdeprosdep 安装运行rospack depends1 beginner_tutorials 后报错：[rospack] Error: no such package beginner_tutorials。原因是没有安装rosdep。这个包好像是可以方便解决软件包依赖问题的，我在安装后再apt install ros-noetic-desktop-full后提示会移除rosdep，再查官方文档，知道这是个额外的包。 解决：ubuntu应该安装python3-rosdep而不是python3-rosdep2 sudo rosdep init 报错与解决12345678910111213141516171819202122232425262728293031wbx@ubuntu:~$ rosdep initERROR: default sources list file already exists: /etc/ros/rosdep/sources.list.d/20-default.listPlease delete if you wish to re-initializewbx@ubuntu:~$ sudo rm /etc/ros/rosdep/sources.list.d/20-default.listwbx@ubuntu:~$ rosdep initERROR: cannot create /etc/ros/rosdep/sources.list.d/20-default.list: [Errno 13] Permission denied: '/etc/ros/rosdep/sources.list.d/20-default.list'wbx@ubuntu:~$ sudo rosdep initERROR: cannot download default sources list from:https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.listWebsite may be down.wbx@ubuntu:~$ sudo vim /etc/hostswbx@ubuntu:~$ cat /etc/hosts127.0.0.1 localhost127.0.1.1 ubuntu185.199.110.133 raw.githubusercontent.com # 去ipaddress.com上查询# The following lines are desirable for IPv6 capable hosts::1 ip6-localhost ip6-loopbackfe00::0 ip6-localnetff00::0 ip6-mcastprefixff02::1 ip6-allnodesff02::2 ip6-allrouterswbx@ubuntu:~$ rosdep initERROR: cannot create /etc/ros/rosdep/sources.list.d/20-default.list: [Errno 13] Permission denied: '/etc/ros/rosdep/sources.list.d/20-default.list'wbx@ubuntu:~$ sudo rosdep initWrote /etc/ros/rosdep/sources.list.d/20-default.listRecommended: please run rosdep update 到这里rosdep init就成功了 如果出现 website may be down 的错误（python2.7可能有这个问题），可能是证书出现问题。有以下方法： ```shellsudo apt-get install ca-certificates # 安装 ca-certificates 软件12342. ```shell sudo c_rehash /etc/ssl/certs sudo -E rosdep init rosdep updaterosdep update 报的错误有以下几个： ```ERROR: unable to process source 123- ``` urlopen error _ssl.c:1106: The handshake operation timed out 解释：握手操作超时 解决：配置 VPN ```urlopen error [Errno -3] Temporary failure in name resolution 123456 - 解释：域名解析出现暂时错误 - 解决：编辑 /etc/resolv.conf 文件，加入谷歌的 DNS 服务器；编辑 /etc/hosts 文件，删除 raw.githubusercontent.com 的相关配置 - ``` urlopen error [Errno 104] Connection reset by peer 解释：连接被监督（peer）重置（防爬虫？） 解决：编辑 /etc/resolv.conf 文件，加入谷歌的 DNS 服务器；编辑 /etc/hosts 文件，删除 raw.githubusercontent.com 的相关配置 ```urlopen error [Errno 111] Connection refused 123456 - 解释：连接被拒绝 - 解决：编辑 /etc/resolv.conf 文件，加入谷歌的 DNS 服务器 - ``` ERROR: error loading sources list ```The read operation timed out 1234567 - 解释：读取操作超时 - 解决：~~换成手机热点？~~将 `sources_list.py`、`gbpdistro_support.py`、`rep3.py` 三个文件的 DOWNLOAD_TIMEOUT 设置长一些，其值要大于预估的执行 `rosdep update` 命令的总时长。 - 建议：配置 VPN 来解决 - ``` urlopen error &lt;urlopen error timed out&gt; 总结： 编辑 /etc/resolv.conf 文件，加入谷歌的 DNS 服务器； 编辑 /etc/hosts 文件，删除 raw.githubusercontent.com 的相关配置； 配置 VPN。可以用 Lantern VPN。下载时用火狐浏览器插件 iGuge（搜索 igg）更快。 gazebo 打开模型时卡死 不要打开在线模型！！！ 关闭 VMware 的 3D 图形加速。 参考http://wiki.ros.org/cn/ROS/Tutorials/","link":"/2021/08/06/0201.html"},{"title":"OpenVLC 可行性测试报告","text":"项目位置：var/lib/cloud9 如果忘记了usb0的ip，则cmd arp -a 查看ip 或者输入beaglebone.local TX： 电脑usb：192.168.7.11 板子usb0：192.168.7.1 vlc0:192.168.0.1 RX： 电脑usb：192.168.7.12 板子usb0：192.168.7.2 vlc0:192.168.0.2 OpenVLC 简介OpenVLC 是一个由西班牙 IMDEA 网络研究所领导研究和开发工作的开源、灵活、低成本的可见光通信系统平台。OpenVLC 的灵活性体现在一个 OpenVLC 模块既可以充当发射器，也可以充当接收器。 OpenVLC 1.3 平台由搭载 AM3358 芯片（ARM A8 架构）的 BeagleBone Black（BBB）开发板以及 OpenVLC 扩展板组成，以 Linux（Debian 8及以上）为操作系统。 利用BBB中的可编程实时单元（Programmable Real Time Units，PRU），OpenVLC 传输频率可达到1MHz，能够在距离超过3米的传输层实现400kb/s的数据吞吐量。 平台搭建过程在 SD 卡中刷入系统镜像 首先需要一张容量至少 4GB 的 SD 卡，将其格式化。 下载 Debian 系统镜像并解压。可以选择 Debian 8 或以上的版本，由于 Debian 9 版本支持可视化界面，因此这里选择下载 Debian 9 版本。在后面的步骤，不同版本的系统配置方式略有不同。另外，系统需要从 Beagleboard 网站上下载，此网站上的Debian系统是为Beagleboard系列开发板定制的，与 Debian 官网上的系统不同。 下载链接：https://debian.beagleboard.org/images/bone-debian-9.12-imgtec-armhf-2020-04-06-4gb.img.xz 下载安装 Win32 Disk Imager 工具，用此工具将 bone-debian-9.12-imgtec-armhf-2020-04-06-4gb.img 镜像写入 SD 卡。 给 BBB 刷系统在BBB断电的情况下，将 SD 卡插入开发板中，接着，用 USB 线（或USB线和网线）连接电脑和BBB。 Beagleboard 官网发布的 Debian 系统分为两大类，分别为 “eMMC flasher” 和 “without flashing the eMMC”。 若下载的是系统是前者，则系统含有 eMMC flasher 工具，进入系统后（方法见三种与开发板通信的方式），执行以下命令即可将SD卡中的系统烧写入BBB的eMMC（Embedded Multi Media Card）： 12cd /opt/scripts/tools/eMMCsudo ./bbb-eMMC-flasher-eewiki-ext4.sh 若下载的系统是后者，则需要进入 SD 中的系统（方法见三种与开发板通信的方式），打开 uEnv.txt 文件： 1sudo nano /boot/uEnv.txt 将最后一行的 1#cmdline=init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh 取消注释。重启后（sudo reboot，或按RESET键，或断电再供电），系统才会自动写入开发板。 在将系统烧写进开发板的过程中，BBB的四个LED灯会以跑马灯的形式闪烁，待四个 LED 灯全部亮起或全部熄灭，或者出现提示“eMMC has been flashed”时，系统即烧写完成。 三种与开发板通信的方式： 方法一：打开 Windows 的“设备管理器”，查看新接入的BBB的端口号。使用 PuTTY（或其他软件）与 BBB 进行串口通信，波特率设置为115200。 这种方法只需要一根 USB 线，USB 线起到了供电和（串口）通信的作用。 方法二：用网线将 BBB 连接到电脑，USB 线用于供电，用 Windows 的命令行窗口的 ssh 命令： 1ssh debian@192.168.7.2 或者用软件 PuTTY（或其他软件），通过SSH连接IP 192.168.7.2。Debian系统的初始用户名为 debian，密码为 temppwd；超级用户 root 的密码为 root。 这种方法需要一根 USB 线和一根网线，分别用来给 BBB 供电和与 BBB 通信。 方法三（仅适用于 Debian 9 或以上版本）：打开浏览器，输入 192.168.7.2 即可进入 Cloud IDE 界面，无须输入用户名和密码。 这种方法只需要一根 USB 线，USB 线起到了供电和（网络）通信的作用。 设置系统 取消 HDMI 功能 由于 BBB 的 HDMI 占用了 PRU 的部分引脚，因此需要取消 HDMI 使能。编辑 uEnv.txt 文件： 1sudo nano /boot/uEnv.txt 若系统为 Debian 8，则取消此行的注释： 1#dtb=am335x-boneblack-emmc-overlay.dtb 若系统为 Debian 9 或以上，则取消以下两行的注释： 12#disable_uboot_overlay_video=1#disable_uboot_overlay_audio=1 重启 BBB 后，HDMI 便取消使能了。 安装 Linux 头文件库 首先将 BBB 连接到互联网（联网方法），接着更新软件列表： 1sudo apt-get update 然后安装 linux-headers： 1sudo apt-get install linux-headers-$(uname -r) 将源代码拷贝到开发板 源代码可放在 /home/debian 目录下。拷贝方法有以下几种： 方法一：通过 git 命令 12cd /home/Debiansudo git clone https://github.com/openvlc/OpenVLC 方法二：通过 scp 命令 先在 Github 上将源代码下载到主机，再通过以下命令将源代码文件夹传输到 BBB： 1scp -r ./OpenVLC-master debian@192.168.7.2:/home/debian 拷贝完源代码后，需要给代码文件赋予读写和执行权限，以方便后续操作： 1chmod -R 777 OpenVLC-master 联网方法 BBB 开发板有三个网卡：eth0，usb0 和 usb1，分别对应网线口、Mini-A USB 和 Type A USB 接口。测试表明无法只通过一条 USB 让 BBB 联网，可能是因为一条 USB 线无法同时传输网络数据和与主机的通信数据。因此这里采用“网线 + USB”的连接方案。 联网步骤如下： 主机采用串口与BBB通信，并将网卡网络分享给网线口网卡。 IP设置 这里BBB和主机都采用静态 IP，网关分别设为对方的IP。在 BBB 上须修改 /etc/network/interfaces 文件，具体设置如下（主机IP为 192.168.137.1，BBB 的 IP 为 192.168.137.2，其他 IP 类似）： 1234567auto eth0allow-hotplug eth0iface eth0 inet static address 192.168.137.2 network 192.168.137.0 netmask 255.255.255.0 gateway 192.168.137.1 DNS 服务器设置 DNS 服务器设置需要在 /etc/resolv.conf 文件中添加 DNS 服务器的 IP 地址，可直接设置为主机网线口网卡的 IP 地址，或谷歌 DNS 服务器等。可设置多个 DNS 服务器备用。 1234nameserver 192.168.137.1nameserver 8.8.8.8nameserver 114.114.114.114nameserver 119.29.29.29 重启网卡 1sudo /etc/init.d/networking restart 也可以先关闭再开启网卡： 12sudo ifdown eth0sudo ifup eth0 注意：BBB 重启后 IP 地址会重新随机分配（目前不知道为什么），不会跟 /etc/network/interfaces 文件中设置的一样，需要重启网卡才能保持一致。 全部操作完成后，执行 1ping baidu.com 以测试网络配置是否正确。 连接扩展板如图连接开发板和扩展板，扩展板用5V电源供电。 设置 TX/RX 安装 PRU 编译器 下载并安装 PRU 编译器。文件拷贝方法和运行方法前面已经提到。 下载链接：https://software-dl.ti.com/codegen/esd/cgt_public_sw/PRU/2.3.3/ti_cgt_pru_2.3.3_armlinuxa8hf_busybox_installer.sh 建立 PRU 编译器和链接器的符号链接 运行以下命令即可： 12345cd /usr/share/ti/cgt-prusudo mkdir bincd binsudo ln -s /usr/bin/clpru clprusudo ln -s /usr/bin/lnkpru lnkpru 添加 VLC 网卡驱动 发送器（TX）和接收器（RX）的 VLC 网卡的需要使用不同的 IP 地址，打开 Driver 文件夹下的 load_test.sh 脚本文件，将 TX 和 RX 的 VLC 网卡 IP 修改成不一样的值，同时也不要和其他网卡 IP 一样。可以将TX设为 192.168.0.1，RX 设为 192.168.0.2。 修改完毕后，运行 load_test.sh 脚本文件进行测试： 1sudo ./load_test.sh 此脚本会调用之前安装的 linux-headers 和 OpenVLC 的项目文件。运行完此脚本文件后，通过 ifconfig 命令可以查看网卡信息，会发现多了一项网卡驱动：vlc0。 启动 PRU 分别运行 PRU/TX 和 PRU/RX 文件夹下的 deploy.sh 脚本文件，验证代码的正确性以及测试 OpenVLC 模块是否能正常工作（大功率LED灯是否能发光，设备是否发热严重等）。 1sudo ./deploy.sh 测试数据吞吐量 使用 iperf 工具进行测试，TX 端执行命令： 1sudo iperf -c 192.168.0.2 -u -b 400k -l 800 -p 10001 -t 100 RX 端执行命令： 1sudo iperf -u -l 800 -s -i3 -B 192.168.0.2 -p 10001 实际实验过程与结果OpenVLC 平台搭建扩展板制作电路原理图 电路原理图链接：https://github.com/openvlc/OpenVLC/blob/master/Latest_Version/Hardware/Design_files/Schematics.SchDoc BOM清单 BOM清单链接：https://github.com/openvlc/OpenVLC/blob/master/Latest_Version/Hardware/Design_files/BOM.xlsx 其中部分元器件采用国产元器件替代。 数量 组件 电路图代号 值 封装 产品 1 DC-DC DC-DC TO-263-6 LM2585D2:E25SX-ADJ 1 Schottky D1 850mV @ 3A DO-214AC (SMA) SK310AR3GCT-ND 2 MGD MGD_C MGD_I SOT-23-6 LM5114BMF/NOPBCT 2 MOSFET MOSFET_C MOSFET_I TO-236-3 SQ2308CES-T1_GE3 1 OP AMP O 2 CIRCUITS 8-MSOP-EP LTC6269IMS8E 1 ADC ADC_PD 3MSPS 12bits SOT-23-6 ADS7883 1 Connector (big rectangle) PJ-102A 2 Headers (12x2 one of each side) 732-5303 1 Inductor L1 33µH D (8.70mm) x13.00mm RLB0914-330KL 1 LED HL 3000K 3.45mm x 3.45mm XHP35A-01-0000-0D0HC40E7CT-ND 1 Lense (on top of HL) 30°, 31° 16.1mm D FA10645_TINA-M 1 Heatsink (below HL) 1528-1698-ND 1 Photodiode PD 880nm 5ns 40° Radial 5mm D (T 1 3/4) QSD2030-ND 1 Cap C1 100uF Radial, encapsulado 493-1548 6 Cap C2 C5 C6_1 C6_2 C9 C11 0.1 uF 0603 1276-1258-1 1 Cap C3 0.33 uF 0603 490-3294-1 1 Cap C4 1500 uF Radial, Can 158AVG016MGBJ 1 Cap C7 1 uF 0603 1276-1942-1 1 Cap C8 0.01 uF 0603 1276-1921-1 1 Cap C10 0.5 pF 0603 1276-1818-1 2 Cap C12 C13 1000 pF 0603 490-8019-1 1 Res R1 3kOhm 0603 MCT0603-3.00K-CFCT 1 Res R2 12kOhm 0603 MCT0603-12.0K-CFCT 1 Res R3 1.5 kOhm 0603 P1.50KHCT-ND 5 Res R4_21 R4_22 R7 R8 R11 150Ohm 0603 RHM150DCT 1 Res R6 1kOhm 0603 RR08P1.0KDCT 2 Res R5 R10 75kOhm 0603 RR08P75.0KDCT 1 Res R9 10kOhm 0603 RR08P10.0KDCT 1 Res R4_11 1.8Ohm 1210 ERJ-P14J1R8U 1 Res R4_12 8.66Ohm 1206 CRCW12068R66FKEA 1 Power switch PS MIC94070YC6-TR 委托厂家制作电路板以及焊接部分元器件 PCB 设计图链接：https://github.com/openvlc/OpenVLC/blob/master/Latest_Version/Hardware/Design_files/PCB_Design.PcbDoc 焊接剩余元器件及简单测试插针式元器件的焊接较为容易，这里不赘述。贴片式元器件的焊接与测试过程如下： 将焊枪温度调整到 300 摄氏度左右，然后用焊枪在焊盘上涂抹适量松香。 接着，在焊枪尖部附着适量（根据焊盘大小而定）金属锡，然后使贴片所用焊盘都附着上一定量的锡，同时保证电路板各焊盘之外没有多余的锡。 用热风枪对准焊盘加热锡，待焊盘处的锡融化后，用镊子将贴片准确地放置于焊盘上，然后轻轻地用镊子在贴片上方压一压，使贴片贴合焊盘。 将热风枪温度调到 200 摄氏度左右，用热风枪吹除多余松香；或者在焊接完所有元器件后，将电路板浸泡在酒精中。 用胶枪将部分外露焊点包围固定。 焊接完所有元器件后，对照电路图，用万用表对电路板进行简单的测试，包括导通测试、阻值、容值测量等。 焊接完所有元器件后的成品图如下（LED 灯的散热片未装，准备后续补上）： 扩展板测试供电问题扩展板需要用 5V 电压（5.5mm 圆形接口）供电，而实验室常见的电源适配器都是 12V 的，不能直接接入。因此在测试阶段，我们剪掉了一个坏掉的适配器的 5.5mm 圆形接头，插入扩展板的圆形接口，用稳压源输出 5V 进行供电，解决了临时供电的问题。同时，我们也在淘宝上购买了两个 5V 2A 的电源适配器。 扩展板测试（用单片机）用 STM32 的 GPIO 输出 3.3V 电压，将电源开关芯片的 CT 输入（GPIO1_29）拉高，同时通过简单的程序控制两个 LM5114B 芯片（MGD_C和MGD_I）的两个VIN输入（P8_45和P8_46，亦即 GPIO2_6 和 GPIO2_27）的电平，观察不同输入组合下LED的亮度。 结果发现：在 P8_45 和 P8_46 都为高电平时，LED 最亮；P8_45 为高电平，P8_46 为低电平时，LED 的亮度稍微弱了一些；P8_45 为低电平，P8_46 为高电平时，LED 的亮度更弱；P8_45 和 P8_46 都为低电平时，LED 基本不亮，只发出微量的光。 通过分析电路原理图容易得知：由于 LED 的负极与 GND 之间并联了两条放大电路，两条并联电路分别由 P8_45 和 P8_46 来控制导通，且除了电阻 R4_11 和电阻 R4_12 的阻值不同外，其他部分都相同。由于 R4_11 为1.8Ω，而 R4_12 为 8.66Ω（电路原理图上为 13.6Ω，但 BOM 表上为 8.66Ω，这里我们选择了后者），因此 P8_46 相比 P8_45 对 LED 电流的控制作用较弱，即LED电流主要由 R4_11 所在的这一路决定。 在焊接完两个扩展板后，我们对其进行测试的实际过程中，其中一个电路板测试无误，而另外一个经过测试，发现有多处出现了焊接问题，包括电源开关芯片以及所连接的针脚处没焊牢，5.5mm 电源接口焊接有问题。另外还发现在给电路板通电后，MOS 管冒烟，在替换掉 MOS 管后，终于整个电路板测试正常。 组装将扩展板的排针插到 BBB 的对应位置上，完成后效果如图： OpenVLC 程序测试散热问题由于 LED 的散热片没安上，在测试时我们用小风扇来散热。若没有风扇散热，LED 通电后会大量发热，温度足以融化绝缘胶。 汇编 RX 源代码问题在测试时发现 RX 目录下的 pru1_rx.asm 文件存在没有将 P8_45 和 P8_46 都拉低的问题，这会导致 OpenVLC 模块在作为 TX 运行之后再转为RX运行时，会出现 LED 不灭的情况。通过在 pru1_rx.asm 文件的 START1 下添加将 P8_45 和 P8_46 电平拉低的语句即可在开启 RX 时关闭 LED。 123START1: CLR r30, r30.t0 CLR r30, r30.t1 测试结果TX 终端测试结果： RX 终端测试结果： 通过此次测试，我们验证了 TX 与 RX 进行可见光通信的可行性。 后续工作目标 将 LED 散热片装好。 利用 OpenVLC 平台实现视频的可见光传输。","link":"/2021/02/27/0000.html"},{"title":"电工笔记","text":"直流稳态电路电路的基本概念与基本定律电压电流参考方向实际方向与参考方向电流方向 电流方向是客观存在的：正电荷运动方向或者负电荷运动的反方向 电流的参考方向：任意 电流的正负：参考方向与实际方向一致时，电压为正，否则为负 电压方向 电压实际方向是规定的：高电位指向低电位。电源电动势方向由低电位指向高电位 电压的参考方向：任意 电压的正负：参考方向与实际方向一致时，电压为正，否则为负 参考方向表示双下标表示法 电压双下标：前下标为正极，高电位；后下表为负极，低电位。电压方向表示从高电位指向低电位 电流双下标：电流方向表示从前下标指向后下标位置 电压与电流单位安培 欧姆 欧姆定律欧姆定律定义欧姆定律：通常流过电阻的电流与电阻两端的电压成正比 欧姆定律表达式当电流和电压的参考方向一致时（关联方向）：$U=RI$ 当电流和电压的参考方向相反时（非关联方向）：$U=-RI$ 电源有载工作、开路、短路电源有载工作 电压与电流 电源端电压与电动势的关系：$U=E-R_0 I$ 功率与功率平衡 电源功率：$P_{\\rm E}=EI$ 内阻损耗：$\\Delta{P}=R_0 I^2$ 电源输出的功率：$P=UI$ 电源与负载的判别 电源：$U$ 与 $I$ 实际方向相反，$P&lt;0$，发出功率 负载：$U$ 与 $I$ 实际方向相同，$P&gt;0$，取用功率 额定值与实际值 电源的输出功率和电流决定于负载的大小 额定值：产品能够在给定的工作条件下正常运行而规定的正常允许值，实际值不一定等于额定值 电源开路 电源电流 $I=0$ 电源端电压 $U=U_0=E$ 电源输出功率 $P=0$ 电源短路 电源电流 $I=I_{\\rm S}=\\dfrac{E}{R_0}$ 电源端电压 $U=0$ 电源产生功率 $P_{\\rm E}=\\Delta P =R_0 I^2$ 电源输出功率 $P=0$ 基尔霍夫定律基本名词定义 支路：电路中的每一个分支 结点：电路中三条或三条以上的支路相连接的点称为结点 网孔：不含支路的回路 基尔霍夫电流定律任一瞬时，流入某一结点的电流之和应该等于该结点流出的电流之和 任一瞬时，一个结点上电流的代数和恒等于零 任一瞬时，通过任一闭合面的电流的代数和也恒等于零 注意：与欧姆定律类似，基尔霍夫电流定律符号与电流符号是独立的，即可以定义流入为正，也可以定义流出为正 基尔霍夫电压定律回路中任意一点出发，沿回路循行一周，电位降之和等于电位升之和 回路中任意一点出发，沿回路循行一周，各段电压的代数和恒等于零 可以推广至部分电路 电路的分析方法电阻串并联的等效变换电阻串联电阻并联等电位法 电阻星形联结与三角形联结的等效变换 当三个电阻都相等时，$R_{\\rm Y}=\\dfrac{1}{3} R_{\\Delta}$，$R_{\\Delta} =3R_{\\rm Y}$ 电源的两种模型及其等效变换电压源模型：理想电压源与电阻串联 电流源模型：立项电流源与电阻并联 电压源外特性曲线：$U=E-R_0I$ 电流源外特性曲线：$I_{\\rm S}=\\dfrac{U}{R_0}+I$ ​ $I_{\\rm S}$：电源短路电流 ​ $I$：负载电流 注意：等效变化只对外端电压、支路电流等效，对内阻功率、内阻电压降、内阻电流不等效 等效变换的推广：适用于任意理想电压源和电阻串联与理想电流源和电阻串联电路的等效 注意：理想电压源与理想电流源之间是不能等效的 支路电流法适用范围：不能通过电阻串并联等效变换简化的电路 内容：对所有结点应用基尔霍夫电流定律，对所有网孔应用基尔霍夫电压定律 要求：未知数为支路电路，支路电流法独立方程数等于电流未知的支路数 验算：对未利用的回路，应用基尔霍夫电压定律；或者利用电源释放功率等于电阻消耗功率 结点电压法适用范围：只有两结点的电路 内容：对包含待求支路的所有回路应用基尔霍夫电压定律，或对所有支路应用欧姆定律，对其中一结点应用基尔霍夫电流定律 支路无电流源，且只有两个节点时的公式：$U=\\dfrac{\\sum{\\frac{E}{R}}}{\\sum{\\frac{1}{R}}}$ 叠加定理适用范围：线性电路 内容：任一条支路中的电流，都可以看作是由电路中各个电源分别作用时，在此支路上产生的电流的代数和 应用：将多电源电路中每一个电源产生的电流分别计算，计算时，将其他电流源开路，电压源短路，内阻保留 注意：线性电路中，电流、电压都可以使用叠加定理计算，但非线性指标（如功率）不可以使用叠加定理计算 戴维宁定理与诺顿定理使用范围：线性电路 内容：电源模型的推广，将任意复杂的有源二端线性网络，用一个理想电压源与内阻串联的电源或理想电流源与内阻并联的电源等效 应用： 等效理想电压源电动势 $E$，将线性网络的二端开路，端口电压即为等效理想电压源电动势 $E$（戴维宁定理） 等效理想电流源电流 $I_{\\rm S}$，将线性网络的二端短路，短路电流即为等效理想电流源电流 $I_{\\rm S}$（诺顿定理） 等效电源内阻 $R_0$，将二端网络的理想电压源短路，理想电流源开路，端口间的等效电阻即为内阻 $R_0$ 受控电源电路的分析受控电源的定义：电压源的电压和电流源的电流是受电路中其他部分的电流或者电压控制的电源 注意：计算过程与其他线性电路一致，但受控电源的参考方向需要与控制量的参考方向对应；应用叠加定理时，受控电源应保留；如按照独立电源处理，保留受控量 非线性电阻电路的分析线性电阻的定义：电阻两端的电压与流过的电流成正比，这说明电阻是一个常数，不随电压或电流变动 非线性电阻的定义：电阻不是一个常数，而是随着电压或电流变动，这种电阻称为非线性电阻 静态电阻的定义：工作点 Q 的电压 $U$ 与电流 $I$ 之比 动态电阻的定义：工作点 Q 的电压微变量 $\\Delta U$ 与电流微变量 $\\Delta I$ 之比的极限 非线性电阻电路解法：将非线性元件隔离，其余部分作为一个有源二端网络，非线性元件的伏安特性曲线与二端网络的伏安特性曲线的交点，即为非线性元件的端电压与通过电流 直流暂态电路电路的暂态分析电阻、电感、电容元件 电阻 电阻元件的参数 $R=\\dfrac{u}{i}$ 称为电阻，具有对电流起阻碍作用的物理性质 电感 电感元件的参数 $L=\\dfrac{\\varPhi}{i}$，电感是储能元件。磁链 $\\varPhi =N\\phi=Li$ 电感元件中的磁通或电流发生变化时，感应电动势 $e_{L}=-\\dfrac{d\\Phi}{dt}=-L\\dfrac{di}{dt}=-u$ 电容 电容元件的参数 $C=\\dfrac{q}{u}$ 称为电容，，电容是储能元件。$q=Cu$ 电容元件上电荷量 $q$ 或者电压 $u$ 发生变化时，电路电流 $i=\\dfrac{dq}{dt}=C\\dfrac{du}{dt}$ 功率 电阻元件：$\\int_{0}^{t}uidt=\\int_{0}^{t}Ri^2dt$ 电感元件：$\\int_{0}^{t}uidt=\\int_{0}^{t}Lidi=\\dfrac{1}{2}Li^2$ 电容元件：$\\int_{0}^{t}uidt=\\int_{0}^{t}Cudu=\\dfrac{1}{2} Cu^2$ 线性关系 $R$ 的 $u$ 和 $i$，$L$ 的 $\\phi$ 和 $i$，$C$ 的 $q$ 和 $u$ 都是线性关系 储能元件与换路定则换路定则适用范围：存在储能元件的电路，发生换路的瞬间 内容：从 $t=0^{-}$ 到 $t=0^{+}$ 瞬间，电感元件中的电流和电容元件上的电压不能跃变 应用：先求得换路前瞬间 $t=0^{-}$ 电感元件的电流和电容元件上的电压，进而由换路后瞬间 $t=0^{+}$ 电感元件的电流和电容元件上的电压求出其他电路参数 RC 电路的响应暂态电路分析法：求解电路的微分方程 $i=C\\dfrac{du_{C}}{dt}$ 按初始条件分类 零状态响应 定义：换路前电容元件未储存能量，在此状态下由电源激励所产生的电路的响应 实质：电容元件的充电过程 零输入响应 定义：无电源激励，输入信号为零，在此状态下，由电容元件的初始状态所产生的电路的响应 实质：电容元件的放电过程 全响应 定义：指电源激励和电容元件的初始状态均不为零时电路的响应，是零状态响应与零输入响应的叠加 计算（以 RC 电路为例） 方法一：叠加定理 方法二：求解全响应电路微分方程 $RC\\dfrac{du_{C}}{dt}+u_{C}=U$，方程的解 $u_{C}=U+(U_0-U)e^{-\\frac{t}{RC}}$ 时间常数 $\\tau=RC$，$\\tau$ 越大，放电越慢，充电越慢 一阶线性电路暂态分析的三要素法 一阶线性电路：只含有一个储能元件或可等效为一个储能元件的线性电路，它的微分方程都是一阶常系数线性微分方程 三要素法 微分方程的解：$f(t)=f(\\infin)+Ae^{-\\frac{t}{\\tau}}$ 若初始值为 $f(0^{+})$，则 $A=f(0^+)-f(\\infin)$ 求得三要素 $f(\\infin)$、$f(0^+)$、$\\tau$，则可以直接写出电路响应 微分电路与积分电路 RC 微分电路 构成：RC 串联，输出端为电阻两端，使用矩形脉冲激励，时间常数 $\\tau \\ll t_{\\rm p}$ 特点：输出尖脉冲信号，这是对输入的矩形脉冲微分的结果 用途：一般用于触发信号 RC 积分电路 构成：RC 串联，输出端为电容两端，使用矩形脉冲激励，时间常数 $\\tau \\gg t_{\\rm p}$ 特点：输出锯齿波信号，这是对输入的矩形脉冲积分的结果 用途：一般用作扫描信号 RL 电路的响应 零状态响应 电路微分方程：$U=Ri+L\\dfrac{di}{dt}$ 初始条件：$i(0^-)=i(0^+)=0$ 微分方程的解：$i=\\dfrac{U}{R}-\\dfrac{U}{R}e^{-\\frac{R}{L}t}$ 电路的时间常数：$\\tau=\\dfrac{L}{R}$ 零状态响应 电路微分方程：$Ri+L\\dfrac{di}{dt}=0$ 初始条件：$i(0^+)=I_0$ 微分方程的解：$i=I_0 e^{-\\frac{R}{L}t}$ 电路的时间常数：$\\tau=\\dfrac{L}{R}$ 全响应 电路微分方程：$U=Ri+L\\dfrac{di}{dt}$ 初始条件：$i(0^-)=I_0$ 微分方程的解：$i=\\dfrac{U}{R}+(I_0-\\dfrac{U}{R})e^{-\\frac{R}{L}t}$ 电路的时间常数：$\\tau=\\dfrac{L}{R}$ 正弦交流电路正弦电压与电流正弦电压和电流是按照正弦规律周期性变化的 正弦量的特征表现在变化的快慢、大小及初始值三个方面 周期：正弦量变化一次所需的时间 频率：每秒内变化的次数，$f=\\dfrac{1}{T}$ 角频率：单位时间内变化的弧度数，$\\omega=\\dfrac{2\\pi}{T}=2\\pi f$ 瞬时值：正弦量在任一瞬时的值 幅值：瞬时值中最大的值 有效值：一个周期电流通过电阻在一个周期内产生的热量，和另一个直流电流通过同样大小的电阻在相等的时间内产生的热量相等，周期电流的有效值的数值就等于直流电流 初相位：$t=0$ 时的相位角称为初相位或者初相位角相位差与相位的超前、落后 正弦量得以广泛应用的原因 方便利用变压器将正弦电压升高或降低 对于正弦量的加、减、积分、微分的计算结果仍为同频率的正弦量，使电路各部分波形相同 正弦量变化平滑，正常情况下不会引起过电压 正弦量的相量表示法相量：表示正弦量的复数 相量的代数式、指数式、极坐标式的换算 相量的超前与落后，逆时针为向前，顺时针为向后 单一参数的交流电路 电阻元件的交流电路 电阻的计算：电压与电流的有效值相除，或电压与电流的幅值相除 瞬时功率 平均功率 电感元件的交流电路 瞬时电压与瞬时电流的关系：$u=L\\dfrac{di}{dt}$ 若$i=I_{\\rm m} \\sin{\\omega t}$，则 $u=U_{\\rm m} \\sin(\\omega t + 90^{\\circ})$ 下标 m 表示幅值 相位上，电流落后电压 $90^{\\circ}$ 电压幅值与电流幅值的关系：$U_{\\rm m}=\\omega L I_{\\rm m}$ 感抗：$X_{L}=\\omega L=2\\pi fL$，电感元件电路中，$\\omega L$ 具有对交流电路起阻碍作用的物理性质 用相量表示电压与电流的关系：$\\dot{U}=jX_{L}\\dot{I}=j\\omega L\\dot{I}$ 瞬时功率：$p=ui=UI\\sin{2\\omega t}$ 无功功率：往返于电源与储能元件之间的功率，用于衡量电源与储能元件间的能量互换的规模 电容元件的交流电路 瞬时电压与瞬时电流之间的关系：$i=C\\dfrac{du}{dt}$ 若$u=U_{\\rm m} \\sin{\\omega t}$，则 $i=I_{\\rm m} \\sin(\\omega t + 90^{\\circ})$ 相位上，电压落后电流 $90^{\\circ}$ 电流幅值与电压幅值的关系：$I_{\\rm m}=\\omega CU_{\\rm m}$，或 $U_{\\rm m}=\\dfrac{1}{\\omega C}I_{\\rm m}$ 容抗：$X_{C}=\\dfrac{1}{\\omega C}=\\dfrac{1}{2\\pi fC}$，电容电路中容抗具有对交流电路起阻碍作用的物理性质 用相量表示电压与电流的关系：$\\dot{U}=-jX_{C}\\dot{I}=\\dfrac{\\dot{I}}{j\\omega C}$（有负号：因为电流超前） 瞬时功率：$p=ui=UI\\sin{2\\omega t}$ 无功功率：$Q=-UI=-X_{C}I^{2}$ 注意：电容性无功功率取负值，电感性无功功率取正值 电阻、电感与电容元件串联的交流电路电压瞬时值与电流瞬时值的关系：$u=u_{R}+u_{L}+u_{C}=Ri+L\\dfrac{di}{dt}+\\dfrac{1}{C}\\int idt$ 相量表示：$\\dot{U}=\\dot{U}{R}+\\dot{U}{L}+\\dot{U}{C}=R\\dot{I}+j X{L} \\dot{I}-jX_{C}\\dot{I}=[R+j(X_{L}-X_{C})]\\dot{I}$ 阻抗：$Z=R+j(X_{L}-X_{C})=\\sqrt{R^{2}+(X_{L}-X_{C})^{2}} \\exp(j\\arctan{\\frac{X_{L}-X_{C}}{R}})=|Z|e^{j\\varphi}$ 其中：$|Z|$ 为阻抗模，$\\varphi$ 为阻抗幅角，即电压与电流之间的相位差。 $u=U_{\\rm m}\\sin(\\omega t+\\varphi)$，$i=I_{\\rm m}\\sin{\\omega t}$ 对于电感性电路，阻抗幅角为正（电压超前）；对于电容性电路，阻抗幅角为负（电流超前）。 瞬时功率：$p=ui=U_{\\rm m}I_{\\rm m}\\sin(\\omega t+\\varphi)\\sin{\\omega t}=UI\\cos\\varphi -UI\\cos(2\\omega t+\\varphi)$ 平均功率：$P=\\dfrac{1}{T}\\int_{0}^{T}pdt=UI\\cos{\\varphi}=U_{R}I=I^{2}R$ 无功功率：$Q=U_{L}I-U_{C}I=UI\\sin{\\varphi}$ 视在功率：$S=UI=|Z|I^{2}$ 变压器容量：$S_{N}=U_{N}I_{N}$，N 表示额定 各功率的关系：$S=\\sqrt{P^2+Q^2}$ 串联交流电路的计算 相量的极坐标式计算 相量的代数式计算 相量的图解法 阻抗的串联与并联 阻抗的串联 $Z=Z_1+Z_2$ 注意：$|Z|\\ne|Z_1|+|Z_2|$ 阻抗并联 $\\dfrac{1}{Z}=\\dfrac{1}{Z_1}+\\dfrac{1}{Z_2}$ 注意：感抗取正号，容抗取负号 交流电路的频率特性频率特性：响应与频率之间的关系 时域分析：电压与电流都是时间函数，在时间领域内对电路进行分析 频域分析：在频率领域对电路进行分析 滤波电路 低通滤波电路：具有使低频信号较易通过而抑制高频率信号的作用的电路。（电容输出） 传递函数（转移函数）：电路输出电压与输入电压之间的比值 $T(j\\omega)=\\dfrac{1}{\\sqrt{1+(\\omega RC)^2}}\\ang[-\\arctan(\\omega RC)]=\\dfrac{1}{1+j\\dfrac{\\omega}{\\omega_0}}=\\dfrac{1}{\\sqrt{1+(\\dfrac{\\omega}{\\omega_0})^2}}\\ang(-\\arctan\\dfrac{\\omega}{\\omega_0})$ 通频带：频率范围 $0&lt;\\omega\\le \\omega_0$，$\\omega_0$ 为截止频率 当频率小于截止频率时，输出幅值基本不变 当频率大于截止频率时，输出幅值明显减小 高通滤波电路：具有使高频信号较易通过而抑制低频率信号的作用的电路。（电阻输出） $T(j\\omega)=\\dfrac{1}{\\sqrt{1+(\\dfrac{1}{\\omega RC})^2}}\\ang[-\\arctan(\\dfrac{1}{\\omega RC})]=\\dfrac{1}{1-j\\dfrac{\\omega_0}{\\omega}}=\\dfrac{1}{\\sqrt{1+(\\dfrac{\\omega_0}{\\omega})^2}}\\ang(-\\arctan\\dfrac{\\omega_0}{\\omega})$ 通频带：频率范围 $\\omega\\ge \\omega_0$，$\\omega_0$ 为截止频率 当频率小于截止频率时，输出幅值明显减小 当频率大于截止频率时，输出幅值基本不变 带通滤波电路：具有使通频带内信号较易通过而抑制通频带外频率信号的作用的电路 通频带：输出幅值等于最大值的 70.7% 处频率的上下限之间的宽度 谐振电路谐振现象：电路两端的电压与其中电流同相 串联谐振：串联电路中，电源电压与电路中的电流同相 串联谐振条件：$X_{L}=X_{C}$，即$2\\pi fL=\\dfrac{1}{2\\pi fC}$ 谐振频率：$f_0=\\dfrac{1}{2\\pi \\sqrt{LC}}$ 串联谐振时，阻抗模等于电阻 $R$，电路对电源呈电阻性，电源电压等于电阻两端电压 品质因数 $Q$：$Q=\\dfrac{U_{C}}{U}=\\dfrac{U_{L}}{U}=\\dfrac{X_{C}}{R}=\\dfrac{X_{L}}{R}=\\dfrac{1}{\\omega_0 CR}=\\dfrac{\\omega_0 L}{R}$ 并联谐振：并联电路中，电源电压与电路中的电流同相 并联谐振条件：$X_{L}=X_{C}$，即 $2\\pi fL=\\dfrac{1}{2\\pi fC}$ 谐振频率：$f_0=\\dfrac{1}{2\\pi \\sqrt{LC}}$ 并联谐振时，电流达到最小值，电路对电源呈电阻性，支路电流近于相等，远大于干路电流 品质因数 $Q$：$Q=\\dfrac{I_1}{I_0}=\\dfrac{1}{\\omega_0 CR}=\\dfrac{\\omega_0 L}{R}$，表示谐振时，支路电流是干路电流的 $Q$ 倍 功率因数的提高功率因数：平均功率 $P=UI\\cos{\\varphi}$ 式中的 $\\cos{\\varphi}$ 功率因数的意义：当功率因数不为 1 时，出现无功功率，发点设备的容量不能充分利用，增加电路和发电机绕组的损耗 提高功率因数的手段：与电感性负载并联静电电容器 提高功率因数的原理：并联电容器之后，减少了负载与电源之间的能量交换，电感性负载所需的无功功率由电容器供给，充分利用了发电机容量 注意：功率因数不能提高到1，一般提高到0.9即可，是为了防止并联谐振 非正弦周期电压与电流一个非正弦周期函数，只要满足狄里赫利条件都可以展开为傅里叶三角级数：$$f(\\omega t)=A_0+\\sum_{\\rm k=1}^{\\infin} A_{\\rm km}\\sin(k\\omega t+\\psi_{\\rm k})$$其中， ​ $A_0$ 是不随时间而变的常数，称为恒定分量或直流分量 ​ $A_{\\rm 1m}\\sin(\\omega t+\\psi_{\\rm k})$ 的频率与非正弦周期函数的频率相同，称为基波或一次谐波 ​ 其余各项的频率为周期函数的频率的整数倍，称为高次谐波 三相交流电路三相电压三相对称正弦电压：频率相同、复制相等、相位互差 $120^{\\circ}$ 的正弦电压$$u_1=U_{\\rm m}\\sin{\\omega t} \\u_2=U_{\\rm m}\\sin(\\omega t-120^{\\circ}) \\u_3=U_{\\rm m}\\sin(\\omega t+120^{\\circ})$$相序：三相交流电压出现正幅值（或相应零值）的顺序 中性点（零点）：三个末端连在一起的连接点 星形联结：三个末端连在一起的连接方法 中性线（零线）：从中性点引出的导线 相线（端线）：从始端引出的导线 相电压：每相始端与末端间的电压，亦即相线与中性线间的电压 线电压：任意两端间的电压，亦即两相线间的电压 线电压与相电压的相位关系：线电压超前相电压 $30^{\\circ}$ 线电压与相电压有效值的关系：线电压等于 $\\sqrt{3}$ 倍的相电压 负载星形联结的三相电路相电流：每相负载中的电流 线电流：每根相线中的电流 负载星形联结时，相电流等于线电流 负载星形联结的计算方法： 确定各相电压 根据各相负载，计算各相电流的有效值、相位差 应用基尔霍夫电流定律计算中心线电流 负载对称：各相阻抗相等，或阻抗模和相位角相等。负载对称时，负载相电流相等，中心线电流为 0 负载三角形联结的三相电路负载三角形联结时，电源线电压等于负载相电压 负载对称时，线电流也是对称的，比相电流滞后 $30^{\\circ}$ 负载对称时，，线电流等于 $\\sqrt{3}$ 倍的相电流 负载星形联结的计算方法： 确定各相电压 根据各相负载，计算各相电流的有效值、相位差 应用基尔霍夫电流定律计算中心线电流 三相功率负载对称时，三相总功率（有效功率）：$P=3 P_{P}=3 U_{P} I_{P} \\cos \\varphi=\\sqrt{3} U_{L} I_{L} \\cos \\varphi$ 三相无功功率：$Q=3 U_{P} I_{P} \\sin \\varphi=\\sqrt{3} U_{L} I_{L} \\sin \\varphi$ 三相视在功率：$S=3 U_{P} I_{P}=\\sqrt{3} U_{L} I_{L}$ 交流电动机三相异步电动机的构造三相异步电动机分为定子、转子 定子包括 机座、铁心、定子绕组 转子包括 若是笼型异步电机：转子铁心、转子绕组 若是绕线转子异步电机：滑环、转子铁心、转子绕组 三相异步电动机的转动原理电机转动的条件：旋转的磁场，转子跟着磁场转动 旋转磁场：三相电流产生的磁场叠加，随电流交变在空间不断旋转 旋转磁场的极数：旋转磁场的极数=每相绕组在空间串联的线圈数 旋转磁场的转速：$n_0=\\dfrac{60f_1}{p}$ 电动机的转动原理：旋转磁场在导条中产生感应电动势，闭合导条中产生感生电流，导条在电磁力（安培力）转矩作用下，产生旋转 转差率 转差率产生的原因：转子电流与转矩产生的必要条件是磁通切割转子导条，也就是旋转磁场与转子转速不一致 转差率表示转子转速 $n$ 与磁场转速 $n_0$ 相差的程度 $s=\\dfrac{n_0-n}{n_0}$ *三相异步电动机的电路分析 定子电路 转子电路 转子频率 转子电动势 转子感抗 转子电流 转子功率因数 三相异步电动机的转矩与机械特性 转矩公式$$T=\\frac{P_{\\varphi}}{\\frac{2 \\pi n_{0}}{60}}=K_{T} \\varPhi I_{2} \\cos \\varphi_{2}$$ $$ T=K \\frac{s R_{2} U_{1}^{2}}{R_{2}^{2}+\\left(s X_{20}\\right)^{2}}$$ 机械特性曲线 $T=f(s)$ 曲线与 $n=f(T)$ 曲线 转矩：$T=9550\\dfrac{P_2}{n}$，注意功率是电机轴的输出功率 额定转矩：$T_{\\rm N}=9550\\dfrac{P_{\\rm 2N}}{n_{\\rm N}}$ 转矩变化过程：负载转矩变大时，转速下降，力矩增大 最大转矩：$T_{\\rm max}=K\\dfrac{U_{1}^{2}}{2X_{20}}$ 最大转矩时的转差率：$s_{\\rm m}=\\dfrac{R_2}{X_{20}}$ 过载系数：$\\lambda=\\dfrac{T_{\\rm max}}{T_{\\rm N}}$ 起动转矩：电动机刚起动时的转矩，$T_{s t}=K \\dfrac{R_{2} U_{1}^{2}}{R_{2}^{2}+X_{20}^{2}}$ $T_{st}$ 与 $U_1^2$ 及 $R_2$ 有关，$T_{st}$ 与 $U_1^2$ 成正比，当 $R_2=X_{20}$ 时，$T_{st}$ 取极值，$T_{st}=T_{\\rm max}$ 三相异步电动机的起动 起动性能 起动电流 起动转矩 起动方法 直接起动 降压起动：起动时降低加在电动机定子绕组上的电压，以减小起动电流 星-三角换接起动 自耦降压起动 三相异步电动机的调速 变频调速 恒转矩调速 恒功率调速 变极调速：改变磁极对数，更改转子转速，调速有级 变转差率调速：转子电路中接入一个调速电阻，增大调速电阻，转差率增大，转速下降，最大转矩不变 三相异步电动机的制动电机制动：电机转矩与转子的转动方向相反 能耗制动 切断三相电源的同时，接通直流电源 反接制动 将接到电源的三根导线的任意一根反接，使磁场反向旋转 发电反馈制动 当转子的转速超过旋转磁场的转速时，转矩也是制动 三相异步电动机的铭牌数据 型号 接法 星形接法 三角形接法 （线）电压 （线）电流 功率和效率 额定运行时，轴上输出的机械功率","link":"/2021/08/06/0201.html"},{"title":"Shell 脚本命令学习","text":"参考：菜鸟教程 兄弟连 Linux 教程 Shell 简介Shell 类型 Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） Korn Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） Linux操作系统缺省的shell是Bourne Again shell，它是Bourne shell的扩展，简称Bash，与Bourne shell完全向后兼容，并且在Bourne shell的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多C shell和Korn shell中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。 查看当前的shell： 1echo $SHELL 第一个 shell 脚本用vim打开新建文档test.sh： 1vim test.sh 输入以下内容： 12#! /bin/bash # “#!”是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。sh和bash都可以。echo &quot;Hello World!&quot; # 向窗口输出文本 进入命令模式，:wq保存退出后，执行（以sh解释器为例，bash解释器同理） 1sh ./test.sh 或 1sh test.sh 或直接指定解释器运行 1/bin/sh test.sh 用这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。 sh 和 bash 命令的区别 引用链接：Linux中的Shell bash和sh区别 sh跟bash的区别是：sh开启了POSIX模式，而bash没有。sh 遵循POSIX规范：“当某行代码出错时，不继续往下解释”。bash 就算出错，也会继续向下执行。 POSIX表示可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）。POSIX标准意在期望获得源代码级别的软件可移植性。换句话说，为一个POSIX兼容的操作系统编写的程序，应该可以在任何其它的POSIX操作系统上编译执行。 简单说，sh是bash的一种特殊的模式，sh就是开启了POSIX标准的bash，/bin/sh相当于/bin/bash --posix。 在Linux系统上/bin/sh往往是指向/bin/bash的符号链接，即 1ln -s /bin/bash /bin/sh Shell 注释单行注释以#开头的行就是注释，会被解释器忽略。 多行注释12345:&lt;&lt;Symbol注释内容...注释内容...注释内容...Symbol 其中Symbol可以替换成任意字符或字符串。 Shell 命令history 命令1history [OPTION] [FILE] 123[OPTIONS]-w ：把缓存中的历史命令写入历史命令保存文件，默认为 ~/.bash_history。默认保存 1000 条，最大保存条数在 /etc/profile 文件中定义 -c ：清空历史命令 123!n # 重复执行第 n 条命令。可重复执行的命令为 ~/.bash_history 中的命令再附加上还没有保存的历史命令!! # 重复执行上一个命令!com # 重复执行最近一次开头为 com 的命令 alias 命令1alias 命令别名='命令原名' eg： 1alias # 查看所有命令别名 命令执行顺序： 执行用绝对路径或相对路径执行的命令 执行命令别名 执行 bash 内部命令 执行按照 $PATH 环境变量定义的目录查找顺序找到的第一个命令 让别名永久生效：写入 user/.bashrc 或 root/.bashrc 文件 help 命令1help [-dms] [pattern ...] 选项 作用 -d output short description for each topic -m display usage in pseudo-manpage format -s output only a short usage synopsis for each topic matching PATTERN Shell 命令一览 引用链接：详解shell中source、sh、bash、./执行脚本的区别 Shell命令 作用 : 空，永远返回为true . 从当前shell中执行操作 break 退出for、while、until或case语句 cd 改变到当前目录 continue 执行循环的下一步 echo 反馈信息到标准输出 eval 读取参数，执行结果命令 exec 执行命令，但不在当前shell exit 退出当前shell export 导出变量，使当前shell可利用它（导出成全局变量） pwd 显示当前目录 read 从标准输入读取一行文本 readonly 使变量只读 return 退出函数并带有返回值 set 控制各种参数到标准输出的显示 shift 命令行参数向左偏移一个 test 评估条件表达式 times 显示shell运行过程的用户和系统时间 trap 当捕获信号时运行指定命令 ulimit 显示或设置shell资源 umask 显示或设置缺省文件创建模式 unset 从shell内存中删除变量或函数 wait 等待直到子进程运行完毕 echo 命令选项 可选项 作用 -n 不加换行符 -e 使能对反斜杠转义符的解释 -E 禁止对反斜杠转义符的解释 字符转义执行命令 1help echo 即可看到所有能转义的字符 能转义的字符 转义后的作用 \\a alert (bell) \\b suppress further output \\e escape character \\E escape character \\f form feed \\n new line \\r carriage return \\t horizontal tab \\v vertical tab \\\\ backslash \\0nnn the character whose ASCII code is NNN (octal). NNN can be 0 to 3 octal digits. \\xHH the eight-bit character whose value is HH (hexadecimal). HH can be one or two hex digits. \\uHHHH the Unicode character whose value is the hexadecimal value HHHH. HHHH can be one to four hex digits. \\UHHHHHHHH the Unicode character whose value is the hexadecimal value HHHHHHHH. HHHHHHHH can be one to eight hex digits. 显示结果定向至文件1echo &quot;It is a test&quot; &gt; myfile 显示命令执行结果1echo `date` 输出结果（当前时间）： 1Mon 25 Jan 2021 05:22:36 PM CST printf 命令printf 命令模仿 C 程序库（library）里的 printf() 程序。 printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。 printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \\n。 printf 命令的语法： 1printf format-string [arguments...] 参数说明： format-string: 为格式控制字符串 arguments: 为参数列表 例子： 12345#!/bin/bashprintf &quot;%-10s %-8s %-4s\\n&quot; 姓名 性别 体重kg printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭靖 男 66.1234printf &quot;%-10s %-8s %-4.2f\\n&quot; 杨过 男 48.6543printf &quot;%-10s %-8s %-4.2f\\n&quot; 郭芙 女 47.9876 1234567891011121314151617181920#!/bin/bash# format-string为双引号printf &quot;%d %s\\n&quot; 1 &quot;abc&quot;# 单引号与双引号效果一样printf '%d %s\\n' 1 &quot;abc&quot;# 没有引号也可以输出printf %s abcdef# 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用printf %s abc defprintf &quot;%s\\n&quot; abc defprintf &quot;%s %s %s\\n&quot; a b c d e f g h i j# 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替printf &quot;%s and %d \\n&quot; test 命令数值测试12345678num1=100num2=100if test $num1 -eq $num2then echo '两个数相等！'else echo '两个数不相等！'fi 字符串测试12345678num1=&quot;ru1noob&quot;num2=&quot;runoob&quot;if test $num1 = $num2then echo '两个字符串相等!'else echo '两个字符串不相等!'fi 文件测试1234567cd /binif test -e ./bashthen echo '文件已存在!'else echo '文件不存在!'fi Shell 常用快捷键1234567891011ctrl+a ： 光标移动到命令行开头ctrl+e ： 光标移动到命令行结尾ctrl+c ： 强制终止当前命令ctrl+l ： 剪切光标之前的内容ctrl+k ： 剪切光标之后的内容ctrl+y ： 粘贴ctrl+l或ctrl+k剪切的内容ctrl+r ： 搜索历史命令ctrl+d ： 关闭当前终端ctrl+z ： 暂停并放入后台ctrl+s ： 暂停屏幕输出ctrl+q ： 恢复屏幕输出 Shell 变量变量命名规则 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 中间不能有空格，可以使用下划线（_）。 不能使用标点符号。 不能使用bash里的关键字（可用help命令查看保留关键字）。 变量定义显式定义1your_name=&quot;runoob.com&quot; 注意：等号左右都不能有空格！ 隐式定义1for file in `ls /etc` 或者 1for file in $(ls /etc) 以上语句将 /etc 下目录的文件名循环出来。 变量使用123your_name=&quot;wbx&quot;echo $your_nameecho ${your_name} 变量可以重新定义 1234your_name=&quot;tom&quot;echo $your_nameyour_name=&quot;alibaba&quot;echo $your_name 变量类型 按作用域可分为 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 按能否重新定义，可分为 可变变量 一般定义的为可变变量 只读变量 用readonly命令可将变量定义为只读变量。如下shell脚本执行会报错。 1234#!/bin/shmyUrl=&quot;https://www.google.com&quot;readonly myUrlmyUrl=&quot;https://www.baidu.com&quot; 变量删除1unset variable_name 注意：unset 命令不能删除只读变量。 Shell 数据类型字符串字符串定义可以用单引号，也可以用双引号，也可以不用引号。 字符串变量定义单引号法最简单的例子： 1str='this is a string' 下面在例子中观察单引号的用法： 123456789101112#!/bin/shstr='string'str1='This is a $str.'str2='This is a '$str'.'# str3='This is a \\'$str\\'.' # 这句会报错str4='This is a &quot;$str&quot;.'str5='This is a \\&quot;$str\\&quot;.'echo &quot;1: $str1&quot;echo &quot;2: $str2&quot;# echo &quot;3: $str3&quot;echo &quot;4: $str4&quot;echo &quot;5: $str5&quot; 输出 12341: This is a $str.2: This is a string.4: This is a &quot;$str&quot;.5: This is a \\&quot;$str\\&quot;. 下面会报错 1234#!/bin/shstr='string'str3='This is a \\'$str\\''echo $str3 单引号的一些特点： 单引号中要输出变量的话，不能直接放变量（$name），要用单引号括起来，否则会被当成字符输出 单引号中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。即单引号中不能输出单引号！ 单引号中的双引号就是一个普通的字符，不需要转义直接输出 双引号法123456789101112#!/bin/shstr='string'str1=&quot;This is a $str.&quot;str2=&quot;This is a &quot;$str&quot;.&quot;str3=&quot;This is a \\&quot;$str\\&quot;.&quot;str4=&quot;This is a '$str'.&quot;str5=&quot;This is a \\'$str\\'.&quot;echo &quot;1: $str1&quot;echo &quot;2: $str2&quot;echo &quot;3: $str3&quot;echo &quot;4: $str4&quot;echo &quot;5: $str5&quot; 输出 123451: This is a string.2: This is a string.3: This is a &quot;string&quot;.4: This is a 'string'.5: This is a \\'string\\''. 双引号的一些特点 双引号里面可以放变量，变量可加双引号，也可不加双引号，效果都一样 双引号中输出双引号需要用转义符 双引号中的单引号只是个普通的字符，不需要转义直接输出 总结 字符串定义时，不管是单引号还是双引号，在有变量时，可一律加引号（单引号里面就加单引号，双引号里面就加双引号） 单引号里面不能输出单独的一个单引号，双引号里面输出双引号时要用转义符 单引号里面的双引号以及双引号里面的单引号都视为普通字符 平时用双引号即可，功能比单引号多 字符串拼接见字符串变量定义一节。 字符串长度获取12string=&quot;abcd&quot;echo ${#string} # 输出为4 子字符串获取创建文件test.sh： 123#! /bin/bashstring=&quot;abcdefg&quot;echo ${string:1:4} # 输出bcde 注意：解释器的选择要正确，否则会出现Bad substitution的错误。 这里用发现bash test.sh或/bin/bash test.sh能成功运行，sh test.sh或/bin/sh test.sh都会报错。另外，bash --posix test.sh 或/bin/bash --posix test.sh却能成功运行。 因此我推测：直接用命令和指定解释器路径来执行脚本是等价的，但sh与bash --posix不等价。 查找字符串12string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 注意： 以上脚本中 ` 是反引号，而不是单引号 **’**，不要看错了哦。 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。 类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。 数组变量定义在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。例： 1array_name=(value0 value1 value2 value3) 或单独定义数组的各个分量： 123array_name[0]=value0array_name[1]=value1array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。 数组读取1valuen=${array_name[n]} 使用 @ 符号可以获取数组中的所有元素，例如： 1echo ${array_name[@]} 数组长度获取获取数组长度的方法与获取字符串长度的方法相同，例如： 1234# 取得数组元素的个数length=${#array_name[@]}# 或者length=${#array_name[*]} 12# 取得数组单个元素的长度lengthn=${#array_name[n]} Shell 参数传递我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。 n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……0默认为执行的脚本文件名（包含文件路径）。 例：新建文件test.sh： 12345#!/bin/bashecho &quot;执行的文件名：$0&quot;echo &quot;第一个参数为：$1&quot;echo &quot;第二个参数为：$2&quot;echo &quot;第三个参数为：$3&quot; 1sh test.sh abc 123 5f5 输出： 1234执行的文件名：test.sh第一个参数为：abc第二个参数为：123第三个参数为：5f5 另外，还有几个特殊字符用来处理参数： 参数处理 说明 $# 传递到脚本的参数个数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $* 以一个单字符串的形式显示所有向脚本传递的参数。 如果是$*用&quot;括起来的情况，则会以$1 $2 … $n的形式输出所有参数。 $@ 以一个字符串组的形式显示所有向脚本传递的参数。不加引号则与$*相同。 如果是$@用&quot;括起来的情况、则会以$1 $2 … $n的形式输出所有参数。用for循环可以看出二者的区别。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 演示$*与$@的区别： 12345678910#!/bin/bashecho &quot;-- \\$* 演示 ---&quot;for i in &quot;$*&quot;; do echo $idoneecho &quot;-- \\$@ 演示 ---&quot;for i in &quot;$@&quot;; do echo $idone 1sh test.sh 1 2 3 输出结果： 123456-- $* 演示 ---1 2 3-- $@ 演示 ---123 Shell 运算符算数运算符例： 123#!/bin/bashval=`expr 2 + 2`echo &quot;两数之和为：$val&quot; 注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 算数运算符 说明 举例 + 加法 expr $a + $b - 减法 expr $a - $b \\* 乘法 expr $a \\* $b / 除法 expr $b / $a % 取余 expr $b % $a = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 注意： 条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。 乘号*前边必须加反斜杠\\才能实现乘法运算。 关系运算符 运算符 助记 说明 举例 -eq equal 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] -ne unequal 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] -gt greater 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] -lt less 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] -ge greater equal 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] -le less equal 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 布尔运算符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 逻辑运算符 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false || 逻辑的 OR `[[ $a -lt 100 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] -n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n &quot;$a&quot; ] $ 检测字符串是否为空，不为空返回 true。 [ $a ] 文件测试运算符 操作符 助记 说明 举例 -b block 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] -c char 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] -d directory 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] -g SGID 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] -k Sticky 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] -p pipe 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] -u SUID 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] -r read 检测文件是否可读，如果是，则返回 true。 [ -r $file ] -w write 检测文件是否可写，如果是，则返回 true。 [ -w $file ] -x execute 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] -s (sky) 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] -e exist 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 操作符 说明 举例 -S 判断某文件是否 socket。 [ -S $file ] -L 检测文件是否存在并且是一个符号链接。 [ -L $file] Shell 流程控制条件判断if 条件判断格式： 123456789if condition1then command1 elif condition2then command2else command3 # 注意若写了else，则这里不能为空fi # fi就是if反过来写，也可以理解为finish 或写成一行： 1if condition; then command; fi 例子： 123456789101112131415a=10b=20if [ $a == $b ]then echo &quot;a 等于 b&quot;elif [ $a -gt $b ]then echo &quot;a 大于 b&quot;elif [ $a -lt $b ]then echo &quot;a 小于 b&quot;else echo &quot;没有符合的条件&quot;fi 注意：这里用bash，用sh会报错。 case 条件判断语法： 1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac # 就是case反过来写 例： 123456789101112131415echo '输入 1 到 4 之间的数字:'echo '你输入的数字为:'read aNumcase $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;;esac 循环for 循环1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone 或写成一行： 1for var in item1 item2 ... itemN; do command1; command...; done; 例： 1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done 1234for str in 'This is a string'do echo $strdone while 循环格式： 1234while conditiondo commanddone 例： 1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let &quot;int++&quot;done 无限循环有三种写法： 1234while :do commanddone 1234while truedo commanddone 1for (( ; ; )) until 循环语法： 1234until conditiondo commanddone 例： 123456789#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done break 命令例子： 12345678910111213#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字:&quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot; break ;; esacdone continue 命令例子： 1234567891011121314#!/bin/bashwhile :do echo -n &quot;输入 1 到 5 之间的数字: &quot; read aNum case $aNum in 1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot; ;; *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot; continue echo &quot;游戏结束&quot; # 该语句永远不会被执行 ;; esacdone 123456789101112#!/bin/shsite=&quot;runoob&quot;case &quot;$site&quot; in &quot;runoob&quot;) echo &quot;菜鸟教程&quot; ;; &quot;google&quot;) echo &quot;Google 搜索&quot; ;; &quot;taobao&quot;) echo &quot;淘宝网&quot; ;;esac Shell 函数语法： 1234567[ function ] funname [()] # []表示可写可不写，但这里不能二者都不写{ action; [ return int ]} 说明： 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 return语句如果不加，将以最后一条命令的运行结果，作为返回值。 return后跟数值n（0~255）。 例： 12345678#!/bin/bashdemoFun(){ echo &quot;这是我的第一个 shell 函数!&quot;}echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 12345678910111213#!/bin/bashfunWithReturn(){ echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))}funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 带参数的函数示例： 1234567891011121314#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithParam(){ echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 ${10} !&quot; echo &quot;第十一个参数为 ${11} !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;}funWithParam 1 2 3 4 5 6 7 8 9 34 73 注意：$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 Shell 输入/输出重定向大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件： 标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。 标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。 标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。 默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。 如果希望 stderr 重定向到 file，可以这样写： 1$ command 2&gt;file 如果希望 stderr 追加到 file 文件末尾，可以这样写： 1$ command 2&gt;&gt;file 重定向命令列表如下： 命令 说明 command &gt; file 将输出重定向到 file。 command &lt; file 将输入重定向到 file。 command &gt;&gt; file 将输出以追加的方式重定向到 file。 n &gt; file 将文件描述符为 n 的文件重定向到 file。 n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n &gt;&amp; m 将输出文件 m 和 n 合并。 n &lt;&amp; m 将输入文件 m 和 n 合并。 &lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 例： 123# 统计 file 文件的行数wc -l file # 输出 2 filewc -l &lt; file # 输出 2 下面这个例子，执行command1，从文件infile读取内容，然后将输出写入到outfile中：（说明执行顺序是从左到右的） 1command1 &lt; infile &gt; outfile Here DocumentHere Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。 它的基本的形式如下： 123command &lt;&lt; delimiter documentdelimiter 它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。delimiter可以替换成其他字符。 注意： 结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。 开始的delimiter前后的空格会被忽略掉。 例： 123456# 计算行数wc -l &lt;&lt; EOF 欢迎来到 菜鸟教程 www.runoob.comEOF 1234567#!/bin/bash# 打印内容cat &lt;&lt; EOF欢迎来到菜鸟教程www.runoob.comEOF /dev/null 文件如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null： 1command &gt; /dev/null /dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。 如果希望屏蔽 stdout 和 stderr，可以这样写： 1command &gt; /dev/null 2&gt;&amp;1 注意： 0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。 这里的 2 和 &gt; 之间不可以有空格，2&gt; 是一体的时候才表示错误输出。 Shell 文件包含和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。 Shell 文件包含的语法格式如下： 123. filename # 注意点号(.)和文件名中间有一空格# 或source filename 例子： 创建两个 shell 脚本文件。 test1.sh 代码如下： 123#!/bin/bashurl=&quot;http://www.runoob.com&quot; test2.sh 代码如下： 123456789#!/bin/bash#使用 . 号来引用test1.sh 文件. ./test1.sh# 或者使用以下包含文件代码# source ./test1.shecho &quot;菜鸟教程官网地址：$url&quot; 接下来，我们为 test2.sh 添加可执行权限并执行： 12chmod +x test2.sh ./test2.sh 注：被包含的文件 test1.sh 不需要可执行权限。 其他问题source(.)、sh 和 ./ 的区别 参考：https://blog.csdn.net/wangyangkobe/article/details/6595143 https://www.cnblogs.com/pcat/p/5467188.html source命令：source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。 功能： 使Shell读入指定的Shell程序文件并依次执行文件中的所有语句 source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。 用法： 123source filename# 或. filename source命令（从 C Shell 而来）是bash shell的内置命令；点命令(.)，就是个点符号（从Bourne Shell而来）是source的另一名称。 source filename 与 sh filename 及 ./filename 执行脚本的区别在那里呢？ 当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别的。./filename是因为当前目录没有在PATH中，所以”.”是用来表示当前目录的。 sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export。 source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。 1、source 1source a.sh 在当前shell内去读取、执行a.sh，而a.sh不需要有”执行权限“ source命令可以简写为”.” 1. a.sh 注意：中间是有空格的。 2、sh/bash 12sh a.shbash a.sh 都是打开一个subshell去读取、执行a.sh，而a.sh不需要有”执行权限“ 通常在subshell里运行的脚本里设置变量，不会影响到父shell的。 3、./ 1234./a.sh# bash: ./a.sh: 权限不够chmod +x a.sh./a.sh 打开一个subshell去执行a.sh，a.sh需要有”执行权限“ 可以用chmod +x添加执行权限 另外，使用./来执行的文件里有alias语句的话，shell并不会把alias别名扩展成对应的命令，要解决的话，得使用shopt命令来开启alias扩展选项 1shopt -s expand_aliases","link":"/2021/08/06/0201.html"},{"title":"大学物理笔记","text":"力学机械运动 质点 运动的绝对性 运动的相对性 时刻 时间 位置矢量 运动函数：r(t)=x(t)i+y(t)j 轨迹方程：y=f(x) 瞬时速度、瞬时速率 绝对速度、相对速度、牵连速度：v=vr+v0 加速度 圆周运动加速度 牛顿运动定律牛顿第一定律（惯性定律） 质量 牛顿第二定律：F=ma 运动学正问题 运动学反问题 牛顿第三定律（反作用力） 作用力和反作用力的特点： 同时存在、同时消失 作用在不同物体上 属于同一性质的力 万有引力 惯性参考系 力学中常见的力弹性力：F=-kx 摩擦力 静摩擦力 动摩擦力 粘滞阻力 大小主要取决于固体或流体的速度 大小也和固体的形状、流体的性质有关 非惯性参考系、系统的动能定理 、机械能守恒定律、能量守恒定律第一宇宙速度：$mg=m \\dfrac{v^{2}}{r_{e}}$，7.9km/s 第二宇宙速度：$\\dfrac{1}{2} mv^{2} - G \\dfrac{mM}{r_{e}} = 0$，11.2km/s（机械能=0） 第三宇宙速度：16.7km/s 功 内力、外力 保守力：力所做的功只与与始末位置有关，而与路径无关 系统的动能定理：一切外力对系统所做的功与系统内各物体间一切内力所做的功之代数和等于该系统的动能之增量。 系统的机械能守恒定律：如果一个系统的所有外力和非保守性内力都不做功，则系统的机械能总是保持一恒量。 冲量与动量、质点的动量定理、系统的角动量守恒定律动量（momentum）：$\\vec{p}=m\\vec{v}$ 冲量（impulse）：$\\vec{I}=\\int_{t_1}^{t_2} \\vec{F}dt$ 系统的动量定理：$\\sum \\vec{F_外} =\\dfrac{d}{dt} \\sum \\vec{p}$ 系统动量守恒定律 记忆： 因为 冲量=动量 所以 $d \\vec{I}=d \\vec{p}$ 又因为 $d \\vec{I}=\\vec{F}dt$ 所以 $\\vec{F}dt=d \\vec{p}=m\\vec{v}$ 所以 $\\vec{F}=\\dfrac{d\\vec{p}}{dt}=m\\dfrac{d\\vec{v}}{dt}=m\\vec{a}$ 质心 质心运动定理：$\\sum \\vec{F_{外}}=M \\vec{a_{c}}$ 碰撞的前后，可认为系统总动量保持不变 但动能可能有损失： 弹性碰撞：动能完全没有损失 非弹性碰撞 完全非弹性碰撞 角动量：$\\vec{L}=\\vec{r} \\times m\\vec{v}$ 力矩：$\\vec{M}=\\vec{r}\\times \\vec{F}$ 冲量矩：$\\int_{t_1}^{t_2} \\vec{M} dt$ 系统的角动量定理（动量矩定理）：$\\sum \\vec{M}=\\dfrac{d}{dt} \\sum \\vec{L}$。（对某一点而言） 系统的角动量守恒定律（对某一点而言） 刚体刚体：形状和大小不变 平动 转动 刚体的转动惯量：$J=\\iiint_{V} \\vec{r}^{2}dm$ 刚体绕定轴转动的动能：$E_{\\rm k}=\\dfrac{1}{2} J\\omega^{2}$ 力臂 力矩的功：$dA=Md\\theta$ 功率：$P=M\\omega$ 刚体定轴转动的动能定理：$A=\\dfrac{1}{2} J\\omega_{2}^{2}-\\dfrac{1}{2} J\\omega_{1}^{2}$。（对比动能定理） 刚体的定轴转动定理：$\\vec{M} =J\\vec{\\alpha}$。（对比牛顿第二定律） 冲量矩：$\\vec{M}dt$ 刚体对转轴的角动量：$J\\omega$ 刚体定轴转动的角动量定理：$\\int_{t_1}^{t_2}Mdt=J\\omega_2-J\\omega_1$ 刚体定轴转动的角动量守恒定律 常见物体对不同转轴的转动惯量 相对论狭义相对论基本原理： 相对性原理：在所有惯性系中，物理定律都具有同样的表达形式 光速不变原理：在所有惯性系中，测得真空中的光速都等于 $c$ 伽利略变换设 K 系和 K’ 系都为惯性参考系，K’ 相对 K 在 x 轴方向有速度 $u$，则基于绝对时空观的伽利略变换如下 $$\\left.\\begin{array}{lc}x^{\\prime}=x-u t \\y^{\\prime}=y \\z^{\\prime}=z \\t^{\\prime}=t\\end{array}\\right} \\quad \\text { 或 } \\left.\\quad \\begin{array}{rl}&amp; x=x^{\\prime}+u t \\&amp; y=y^{\\prime} \\&amp; z=z^{\\prime} \\&amp; t=t^{\\prime}\\end{array}\\right}$$ 洛伦兹变换分子类似伽利略变换，洛伦兹变换如下 $x=\\dfrac{x’+ut’}{\\sqrt{1-(u/c)^2}}$ $t=\\dfrac{t’+(u/c^2)x’}{\\sqrt{1-(u/c)^2}}$ 或$$\\left.\\begin{array}{l}x^{\\prime}=\\dfrac{x-u t}{\\sqrt{1-(u / c)^{2}}} \\y^{\\prime}=y \\z^{\\prime}=z \\t^{\\prime}=\\dfrac{t-ux / c^{2} }{\\sqrt{1-(u / c)^{2}}}\\end{array}\\right}$$ 记忆： x的分子和伽利略变换公式一样 所有的分母很有规律，而分子和x和t都有关 分子是加法还是减法取决于轴的方向，可以根据伽利略变换公式来推导 洛伦兹速度变换公式$$\\left.\\left.\\begin{array}{l}v_{x}^{\\prime}=\\frac{v_{x}-u}{1-\\left(u / c^{2}\\right) v_{x}} \\v_{y}^{\\prime}=\\frac{\\sqrt{1-(u / c)^{2}} v_{y}}{1-\\left(u / c^{2}\\right) v_{x}} \\v_{z}^{\\prime}=\\frac{\\sqrt{1-(u / c)^{2} v_{z}}}{1-\\left(u / c^{2}\\right) v_{x}}\\end{array}\\right}{\\quad 或 \\quad}\\begin{array}{r}v_{x}=\\frac{v_{x}^{\\prime}+u}{1+\\left(u / c^{2}\\right) v_{x}^{\\prime}} \\\\text v_{y}=\\frac{\\sqrt{1-(u / c)^{2}} v_{y}^{\\prime}}{1+\\left(u / c^{2}\\right) v_{x}^{\\prime}} \\v_{z}=\\frac{\\sqrt{1-(u / c)^{2} v_{z}^{\\prime}}}{1+\\left(u / c^{2}\\right) v_{x}^{\\prime}}\\end{array}\\right}$$ 相对论的时空观同时的相对性：$\\Delta t=t_2-t_1=\\dfrac{(x_2’-x_1’)u/c^2}{\\sqrt{1-(u/c)^2}}$，（$t_1’=t_2’$ 时） 尺缩效应：$L=L_0’\\sqrt{1-\\dfrac{u^2}{c^2}}$，（$t_1=t_2$，即同时测量两端） 动钟变慢：$\\Delta t’=\\dfrac{\\Delta t}{\\sqrt{1-(u/c)^2}}$ 以上三个式子很容易通过洛伦兹变换推导得到 记忆：根据效应的名称来判断 $\\sqrt{1-(u/c)^2}$ 应该放分子还是分母，然后再根据量纲添加 $u/c^2$ 等。事件发生的先后顺序根据光速不变原理判断。 狭义相对论的动力学基础运动物体的 质量：$m=\\dfrac{m_0}{\\sqrt{1-(u/c)^2}}$ 动量：$\\vec{p}=m\\vec{v}=\\dfrac{m_0}{\\sqrt{1-(u/c)^2}}\\vec{v}$ 运动方程：$\\vec{F}=\\dfrac{d\\vec{p}}{dt}=\\dfrac{d}{dt}(\\dfrac{m_0}{\\sqrt{1-(u/c)^2}}\\vec{v})$ 动能：$E_{\\rm k}=\\frac{1}{2} m_{0} v^{2}$ 静能：$E_0=m_0c^2$ 总能量：$E=mc^2$（质能方程） 三者的关系：$E=E_{0}+E_{\\mathrm{k}}$ 能量与动量的关系：$v^2=\\dfrac{p^2c^4}{E^2}$，或 $E^2=E_0^2 + (pc)^2$ 光子：以光速运动的粒子 光子能量与动量的关系：$E=pc$（光子没有静能） 电磁学电荷 库伦定律正电荷：丝绸摩擦过的玻璃棒 负电荷 电荷守恒定律：一个孤立系统的总电荷（即系统中所有正、负电荷之代数和）在任何物理过程中始终保持不变。 电荷不变性原理：在不同的惯性系中观测物体所带电荷的多少是相同的。 不变量：在特定坐标变化下不改变的量 守恒量：不随时间变化的量 点电荷：带电体之间的距离远大于它们自身的几何线度时，带电体之间的相互作用力受带电体大小、形状、电荷分布的影响可以忽略不计，这时可以把带电体视为点电荷。 电荷元可以看成点电荷 真空中的库伦定律：$\\vec{F}=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{q_0q}{r^2}\\vec{e}_{r}$（注意只在点电荷条件成立时才成立）。 其中 $\\varepsilon_0$：真空电容率（真空介电常数） 记忆：epsilon-&gt;electricity，跟磁导率mu区分 静电力叠加原理 电场 电场强度静电场：静止电荷所激发出的电场 电场强度 $\\vec{E}$：电场中任一点的电场强度在量值上等于一个单位正电荷在该点所受到的电场力，电场强度的正方向规定为正电荷在该点所受电场力的方向。$$\\vec{E}=\\dfrac{\\vec{F}}{q}=\\dfrac{1}{4\\pi \\varepsilon_0}\\dfrac{q}{r^2}\\vec{e}{r}$$连续情况下：$$\\boldsymbol{E}=\\iiint{V} \\mathrm{~d} \\boldsymbol{E}=\\iiint_{V} \\frac{1}{4 \\pi \\varepsilon_{0}} \\frac{\\mathrm{d} q}{r^{2}} \\boldsymbol{e}_{r}$$电场：在电荷周围存在着一种特殊形态的物质，称为电场 静电力叠加原理：每个点电荷所受的总静电力，等于其他点电荷单独存在时，作用于该点电荷上的静电力之矢量和 试探电荷：用于判断电场的存在与否和电场强弱的电荷 场源电荷：激发电场的电荷 均匀电场（匀强电场）：电场中各点的电场强度的大小和方向都相同 电场强度叠加原理：电场中某点的总电场强度等于各个点电荷单独存在时，在该点的电场强度之矢量和 电偶极子 电矩（电偶极矩）：$\\vec{p}_{\\rm e}=q\\vec{l}$，其中 $\\vec{l}$ 为从 $-q$ 指向 $+q$ 的矢量 电偶极子在电场中所受力偶矩为$$\\vec{M}=\\vec{p}_{\\rm e}\\times \\vec{E}$$ 电（场强度）通量 真空中的高斯定理电场线，电场线越密，电场强度越大 电场强度 $\\vec{E}$ 大小的定义：在电场中任一点附近，通过该处垂直于电场强度 $\\vec{E}$ 方向的单位面积的电场线条数等于该点电场强度的大小，即 $E=\\dfrac{\\Delta N}{\\Delta S_{\\perp}}$ 电（场强度）通量：$\\varPhi_e=\\iint_S\\vec{E}\\cdot d\\vec{S}$ （真空中静电场的）高斯定理：$$\\varPhi_{\\rm e}=\\oiint \\vec{E}\\cdot d\\vec{S}=\\dfrac{1}{\\varepsilon_0} \\sum q_内​$$ 用途：求电场强度 如果选取的闭合曲面是球面，球体内电荷关于球面中心对称分布，则有 $E\\cdot 4\\pi r^2=\\dfrac{1}{\\varepsilon_0} \\sum q_内$ 电势 静电场的环路定理（静电场的）环路定理：静电场中电场强度 $E$ 的环流恒为0，即$$\\oint \\vec{E} \\cdot d\\vec{l}=0$$因此静电力做功与路径无关 高斯定理–&gt;静电场是有源场 环路定理–&gt;静电场是无旋场（不闭合），所以是有势场、保守力场 电场中某点电势能的量值： 单位正电荷放在该点时所具有的电势能 单位正电荷从该点经过任意路径到无穷远处时静电力做的功 $$W_{a}=q_{0} \\int_{a}^{\\infty} \\boldsymbol{E} \\cdot \\mathrm{d} \\boldsymbol{l}$$ 电势：$$U=\\int_r^{\\infin}\\vec{E}\\cdot d\\vec{l}$$ （真空中）点电荷的电势：$V_{\\rm a}=\\dfrac{q}{4\\pi\\varepsilon_0 r}$ 连续分布电荷中任意一点的电势：$$V_{a}=\\frac{1}{4 \\pi \\varepsilon_{0}} \\iiint_{\\tau} \\frac{\\rho \\mathrm{d} \\tau}{r}, \\quad V_{a}=\\frac{1}{4 \\pi \\varepsilon_{0}} \\iint_{s} \\frac{\\sigma \\mathrm{d} S}{r}, \\quad V_{a}=\\frac{1}{4 \\pi \\varepsilon_{0}} \\int \\frac{\\lambda \\mathrm{d} l}{r}$$ 电势差：$U_{ab}=V_a-V_b$ 等势面 电场强度与电势的微分关系$l$ 方向上：$E_l=-\\dfrac{\\partial V}{\\partial l}$ $$E=-\\nabla{U}=-{\\rm grad},U$$ 静电场中的金属导体静电感应：导体因受到外电场作用而发生的电荷重新分布的现象 感应电荷：导体上因静电感应而出现的电荷 静电平衡状态：导体上没有电荷做定向运动的状态 导体处于静电平衡状态的条件： 导体内部任何一点的电场强度都为0 靠近导体表面附近任何一点的电场强度方向都垂直于该点处的表面 静电平衡时，导体内各点与导体表面上各点的电势都相等，整个导体是一个等势体，导体表面是一个等势面。 导体的电势：处于静电平衡状态下，导体所具有的电势 由高斯定理可得，静电平衡时，导体表面外附近的电场强度$$E=\\dfrac{\\sigma}{\\varepsilon_0}$$其中，$\\sigma$ 为导体表面的电荷面密度 静电屏蔽：放在导体空腔中的物体因空腔导体屏蔽了外电场，而不会受到任何外电场的影响 静电场中的电介质电介质（绝缘体）：电阻率很高，导电能力极差的物质 极化：在外电场的作用下电介质出现极化电荷的现象，称为电介质的极化 无极分子的极化：位移极化 有极分子的极化：取向极化 有极分子：分子正负电荷的中心不重合，即电矩 $p_{\\rm e}\\ne 0$ 有电介质时的总电场强度$$E=E_0-E’$$ $$E=\\frac{E_{0}}{\\varepsilon_{\\mathrm{r}}}$$ 介电常数（电容率）：$\\varepsilon=\\varepsilon_0 \\varepsilon_r$，$C=\\varepsilon_{\\rm r}C_0$ 其中，$E$ 为电介质中的电场，$E’$ 为电介质极化后的附加电场（反向），$E_0$ 为外电场 规定电位移矢量：（由曲面内外的自由电荷和束缚电荷共同决定）$$\\vec{D}=\\varepsilon \\vec{E}$$ 记忆：这个电位移的概念有点类似光的干涉中光程的概念 电位移通量：$\\oiint \\vec{D} \\cdot d\\vec{S}$，仅与曲面内的自由电荷有关 注意：电场线和电位移线不一样，电位移线是由自由正电荷发出的，与电介质无关；而电场线是由自由正电荷或束缚正电荷发出的。 （有电介质时的）高斯定理：（在变化的磁场中仍成立）$$\\oiint \\vec{D}\\cdot d\\vec{S}=\\sum q_{内（自由）}$$（无限大均匀电介质中的）库伦定律：$\\vec{F}=\\dfrac{1}{4\\pi \\varepsilon} \\dfrac{q_1 q_2}{r^2} \\vec{e_r}$ 极化效应会削弱空间原有的电场强度，故 $\\varepsilon_r &gt;1$ 电容和电容器（孤立导体的）电容 $C$：导体所带电荷 $q$ 与相应电势 $V$ 之比，即 $C=\\dfrac{q}{V}$ 电容单位：${\\rm F}$，$1{\\rm pF}=10^{-12} {\\rm F}$ （电容器的）电容 $C$：电容器一个极板所带电荷和两极板电势差之比 平行板电容器电容 $C=\\dfrac{\\varepsilon S}{d}$ 球形电容器电容 $C=\\dfrac{q}{V_a -V_b}=\\dfrac{q}{\\frac{q}{4\\pi \\varepsilon} (\\frac{1}{R_a}-\\frac{1}{R_b})}=\\dfrac{4\\pi \\varepsilon R_a R_b}{R_b - R_a}$ 电容器串联 $\\dfrac{1}{C}=\\dfrac{1}{C_1}+\\dfrac{1}{C_2}$，串联总电容降低，但耐压程度提高（因为每个电容器上分配的电压小于总电压） 电容器并联 $C=C_1+C_2$，串联总电容提高，但耐压程度不变（因为每个电容器上的电压没有变化，等于总电压） 静电场的能量电场能量密度 $w_e$：电场中单位体积内的能量，$w_{\\rm e}=\\dfrac{DE}{2}=\\dfrac{\\varepsilon E^2}{2}$ 静电场能量：$W_{\\rm e}=\\iiint w_{\\rm e}dV$ 电流电流：大量电荷的定向移动 形成电流的条件： 可移动的电荷 维持电荷做定向移动的电场 直流电（恒定电流）：不随时间而改变的电流 稳恒电场：形成恒定电流的电场 欧姆定律：当一段均匀金属导体AB通有恒定电流，而且温度不变时，电流与其两端电压成正比，与导体两端电阻成反比。$I=\\dfrac{U}{R}$，$R=\\rho \\dfrac{l}{s}$ 电流密度：$\\vec{j}=\\gamma \\vec{E}$，电导率 $\\gamma=1/\\rho$ 焦耳定律：$Q=I^2Rt$ 电源：能够提供非静电力，而把其他形式的能量转化为电能的装置 电动势：非静电力将正电荷从负极移到正极所消耗的功与正电荷电荷量的比值，它反映的是电源将其他形式的能量转化为电能的能力 运动电荷激发磁场 磁感应强度（$B$）：描述磁场各点强弱与方向的物理量$$B=\\dfrac{F_{\\rm max}}{|q|v}$$当电荷运动方向与磁场方向垂直时，受力最大为 $F_{\\rm max}$ 一切磁现象的本源是电流 真空中磁场的毕奥萨伐尔定律：（一般用来计算某点的电磁感应强度） 宏观载流导线：$d\\vec{B}=\\dfrac{\\mu_{0}}{4 \\pi} \\dfrac{I \\mathrm{d} l \\sin (\\mathrm{d} l, \\boldsymbol{r})}{r^{2}}=\\dfrac{\\mu_0}{4\\pi} \\dfrac{Id\\vec{l}\\times \\vec{r}}{r^3}$ 运动电荷的磁场：$\\vec{B}=\\dfrac{\\mu_{0}}{4 \\pi} \\dfrac{qv \\sin (\\boldsymbol{v}, \\boldsymbol{r})}{r^{2}}=\\dfrac{\\mu_0}{4\\pi} \\dfrac{q\\vec{v}\\times\\vec{r}}{r^3}$ 其中 $\\mu_0$ 为真空磁导率 磁感应线磁感应线 右手螺旋法则判定 直电流 圆电流 所激发的磁场中磁感应线的方向 磁感应强度 $B$ 大小的定义：在数值上等于通过某点上垂直于 $B$ 矢量的单位面积的磁感应线条数（称为磁感应线密度） 磁通量：$\\varPhi_{\\mathrm{m}}=\\iint_{S} B \\cos \\theta \\mathrm{d} S=\\iint_{S} \\boldsymbol{B} \\cdot \\mathrm{d} \\boldsymbol{S}$，单位：韦伯（${\\rm Wb}$） 下标 m 是磁场 magnetic 的首字母 真空磁场的高斯定理：通过任意闭合曲面的总磁通量为0。（磁场是无源场）$$\\oiint_{S} \\boldsymbol{B} \\cdot \\mathrm{d} \\boldsymbol{S}=0$$真空磁场的安培环路定理：在磁场中，磁感应强度沿任何闭合路径的环流，等于这个闭合路径所围绕的各个电流之代数和的 $\\mu_0$ 倍。（磁场是非保守力场、无势场）$$\\oint_{l} \\boldsymbol{B} \\cdot \\mathrm{d} l=\\mu_{0} \\sum_{i} I_{i}$$由于磁感应强度的环流一般不为0，所以磁场是非保守力场或无势场 磁场对载流导线的作用：安培定律$$d\\vec{F}=Id\\vec{l}\\times \\vec{B}$$ 方向：右手螺旋法则或左手定则 均匀磁场载流线圈所受力矩$$\\vec{M}=NI\\vec{S}\\times\\vec{B}=\\vec{p}_{\\rm m}\\times \\vec{B}$$ 其中 $\\vec{p}_{\\mathrm{m}}=N I \\vec{S}$ 为载流线圈的磁矩。 载流线圈的正法线方向：通过右手螺旋法则确定 形成一个印象：磁场的作用总是使载流线圈的正法线方向扭到磁场的方向上来 磁场对运动电荷的作用力：洛伦兹力洛伦兹力：点电荷在磁场中运动时所受到的磁场的作用力。$$\\vec{F}_{\\rm m}=q\\vec{v}\\times\\vec{B}$$ 记忆：磁场B在最后面，都用右手螺旋法则 洛伦兹力永远不做功 汤姆逊实验：通过加速电场和偏转磁场来测定电子比荷 $e/m$ 质谱仪：原理和上面类似 霍尔效应：载流子同时受到电场和磁场的作用后达到平衡，电场方向出现电势差 磁介质有磁介质时的磁场：$B=B_0+B’$ 相对磁导率（$\\mu_{\\rm r}$） 弱磁物质：$B’\\ll B_0$ 顺磁质：$B&gt;B_0$ 逆磁质：$B&lt;B_0$ 强磁物质（铁磁质）：$B’\\gg B_0$ 软磁材料：矫顽力较小，易于磁化和退磁 硬磁材料：矫顽力很大 无限大均匀磁介质中的毕奥-萨伐尔定律：$$d\\vec{B}=\\dfrac{\\mu_{0}\\mu_{\\rm r}}{4 \\pi} \\dfrac{I \\mathrm{d} l \\sin (\\mathrm{d} l, \\boldsymbol{r})}{r^{2}}=\\dfrac{\\mu}{4\\pi} \\dfrac{Id\\vec{l}\\times \\vec{r}}{r^3}$$ 磁介质的性质方程：$$\\vec{B}=\\mu \\vec{H}$$$\\vec{H}$ 为磁场强度矢量 和电介质中区别：$\\vec{D}=\\varepsilon\\vec{E}$ 注意： 在弱磁物质中 $\\mu$ 为常数，但在强磁物质（铁磁质）中，$\\mu$ 不是恒量，$B$ 值总是落后于 $H$ 值的变化，具有磁滞特性。 铁磁质加温到居里点会变成顺磁质。 以上两点可用磁畴理论来解释。 有磁介质时的磁场安培环路定理：$$\\oint_l \\vec{H}\\cdot d\\vec{l}=\\sum_{\\rm i内} I_{\\rm i}$$ 作用：磁介质有对称性时求 $\\vec{H}$，然后求 $\\vec{B}$ 电磁感应电磁感应现象：闭合导体回路中的磁通量随时间发生改变时，回路中就出现电流 楞次定律：闭合回路中感应电流的流向，总是企图使感应电流本身所产生的通过回路面积的磁通量，去抵消或者补偿引起感应电流的磁通量的改变。（来拒去留） 法拉第电磁感应定律：感应电动势：$$\\mathscr{E}=-\\dfrac{d(N\\varPhi_{\\rm m})}{dt}=-\\dfrac{d\\varPsi}{dt}$$ 动生电动势：$\\mathscr{E}=\\int_{l}\\vec{E}{动生}\\cdot d\\vec{l}=\\int{l}(\\vec{v}\\times\\vec{B})\\cdot d\\vec{l}$ 根源：洛伦兹力（一种非静电力） 也可假想有一固定线框，用法拉第电磁感应定律来计算 感生电动势：$\\mathscr{E}=\\oint_{l} \\vec{E}{感生}\\cdot d\\vec{l}=-\\iint{S} \\dfrac{\\part \\vec{B}}{\\part t}\\cdot d\\vec{S}$ 根源：变化磁场产生的感生电场（涡旋电场） 自感电动势：由于回路中的电流所引起的磁通量变化而在回路自身中激起的电动势 $\\varPsi_{\\rm m}=Li$，$L$ 为自感，单位为亨利（$H$） $\\mathscr{E}_{L}=-L \\dfrac{\\mathrm{d} i}{\\mathrm{~d} t}$ 互感电动势：两个载流回路互相激起的感应电动势 $\\left.\\begin{array}{l}\\varPsi_{\\mathrm{m} 21}=M i_{1} \\ \\varPsi_{\\mathrm{m} 12}=M i_{2}\\end{array}\\right}$，$M$ 为互感 $\\mathscr{E}{21}=-\\dfrac{\\mathrm{d} \\varPsi{\\mathrm{m} 21}}{\\mathrm{d} t}=-M \\dfrac{\\mathrm{d} i_{1}}{\\mathrm{d} t}$，$\\mathscr{E}{12}=-\\dfrac{\\mathrm{d} \\varPsi{\\mathrm{m} 12}}{\\mathrm{d} t}=-M \\dfrac{\\mathrm{d} i_{2}}{\\mathrm{d} t}$ $M=k\\sqrt{L_1L_2}$，耦合系数 $k$ 满足 $0\\le k \\le 1$ 感生电场的环流不为 0，故为非保守力场，其电场线闭合 磁场的能量磁场能量体密度$$w_{\\mathrm{m}}=\\frac{W_{\\mathrm{m}}}{\\tau}=\\frac{B^{2}}{2 \\mu}=\\frac{1}{2} B H=\\frac{\\mu}{2} H^{2}$$总磁场能量$$W_{\\mathrm{m}}=\\dfrac{1}{2}LI^2=\\iiint_{\\mathrm{V}} \\frac{B^{2}}{2 \\mu} \\mathrm{d} \\tau$$ 注意只在磁介质中积分 可用来算自感 $L$ 位移电流电位移通量：$$\\varPhi_{\\mathrm{e}}=\\iint_{S} D \\cdot \\mathrm{d} S$$位移电流：$$I_{\\mathrm{d}}=\\frac{\\mathrm{d} \\varPhi_{\\mathrm{e}}}{\\mathrm{d} t}$$根据安培环路定理，有$$\\oint_{l} \\boldsymbol{H}^{(2)} \\cdot \\mathrm{d} \\boldsymbol{l}=\\iint_{S} \\frac{\\partial \\boldsymbol{D}}{\\partial t} \\cdot \\mathrm{d} \\boldsymbol{S} = \\sum I_{\\rm d}$$ 麦克斯韦方程组$$\\begin{array}{c}\\oiint_{S} D \\cdot \\mathrm{d} \\boldsymbol{S}=\\sum_{i} q_{i} \\quad &amp;({\\text 静电场高斯定理-电场的性质：有源})\\\\oint_{l} \\boldsymbol{E} \\cdot \\mathrm{d} \\boldsymbol{l}=-\\iint_{S} \\dfrac{\\partial \\boldsymbol{B}}{\\partial t} \\cdot \\mathrm{d} \\boldsymbol{S} \\quad &amp;({\\text 法拉第电磁感应定律-变化的磁场产生涡旋电场})\\\\oiint_{S} \\boldsymbol{B} \\cdot \\mathrm{d} \\boldsymbol{S}=0 \\quad &amp;({\\text 磁场高斯定理-磁场的性质：无源})\\\\oint_{l} \\boldsymbol{H} \\cdot \\mathrm{d} \\boldsymbol{l}=\\sum_{i} I_{i}+\\iint_{S} \\dfrac{\\partial \\boldsymbol{D}}{\\partial t} \\cdot \\mathrm{d} S \\quad &amp;({\\text 安培环路定理-电流和变化的电场产生涡旋磁场})\\end{array}$$ 记忆： 两个高斯定理（球面积分），两个环路定理（环路积分，一个是磁生电，一个是电&lt;电流和位移电流&gt;生磁） $E$ 对应 $B$，$D$ 对应 $H$ 物质方程$$\\begin{array}{l}D=\\varepsilon E \\B=\\mu H \\j=\\gamma E\\end{array}$$ 其中， $\\varepsilon$：电容率 $\\mu$：磁导率 $\\gamma$：电导率 总结记住 麦克斯韦方程组：电场、磁场的性质；电场和磁场的关系 库仑定律：电场对静电荷的作用力 安培定律：磁场对电流的作用力 洛伦兹定律：磁场对运动电荷的作用力 毕奥萨伐尔定律：电流/运动电荷激发磁场的强度 振动 波简谐运动 简谐运动的定义 运动规律满足$$\\frac{\\mathrm{d}^{2} x}{\\mathrm{~d} t^{2}}+\\omega^{2} x=0$$的振动，称为简谐运动 简谐运动的表达式 $$\\begin{array}{l}x=A \\cos (\\omega t+\\varphi) \\v=\\dfrac{\\mathrm{d} x}{\\mathrm{d} t}=-\\omega A \\sin (\\omega t+\\varphi) \\a=\\dfrac{\\mathrm{d} v}{\\mathrm{d} t}=-\\omega^{2} A \\cos (\\omega t+\\varphi)\\end{array}$$ 振幅和初相$$\\begin{array}{l}A=\\sqrt{x_{0}^{2}+\\left(\\dfrac{v_{0}}{\\omega}\\right)^{2}} \\\\varphi=\\arctan \\left(-\\dfrac{v_{0}}{\\omega x_{0}}\\right)\\end{array}$$ 简谐运动的能量$$E=\\dfrac{1}{2}kA^2=\\dfrac{1}{2}m\\omega^2A^2$$ 简谐运动的合成 拍两个同方向、同频率简谐运动的合成 旋转矢量图 合振动的振动表达式$$x=A \\cos (\\omega t+\\varphi)$$其中$$A=\\sqrt{A_{1}^{2}+A_{2}^{2}+2 A_{1} A_{2} \\cos \\left(\\varphi_{2}-\\varphi_{1}\\right)}$$$$\\tan \\varphi=\\frac{A_{1} \\sin \\varphi_{1}+A_{2} \\sin \\varphi_{2}}{A_{1} \\cos \\varphi_{1}+A_{2} \\cos \\varphi_{2}}$$ 两个同方向、不同频率简谐运动的合成 拍$$\\begin{aligned}x &amp;=A \\cos \\left(\\omega_{1} t+\\varphi\\right)+A \\cos \\left(\\omega_{2} t+\\varphi\\right) \\&amp;=2 A \\cos \\left(\\frac{\\omega_{2}-\\omega_{1}}{2} t\\right) \\cos \\left(\\frac{\\omega_{2}+\\omega_{1}}{2} t+\\varphi\\right)\\end{aligned}$$ 两个互相垂直、同频率的简谐运动的合成 合振动的振动表达式 $$\\frac{x^{2}}{A_{1}^{2}}+\\frac{y^{2}}{A_{2}^{2}}-\\frac{2 x y}{A_{1} A_{2}} \\cos \\left(\\varphi_{2}-\\varphi_{1}\\right)=\\sin ^{2}\\left(\\varphi_{2}-\\varphi_{1}\\right)$$ 图形 椭圆或直线 两个互相垂直、不同频率的简谐运动的合成 李萨如图形 阻尼振动 振动表达式$$\\frac{\\mathrm{d}^{2} x}{\\mathrm{d} t^{2}}+2 \\beta \\frac{\\mathrm{d} x}{\\mathrm{d} t}+\\omega_{0}^{2} x=0$$其中 $\\omega_{0}^{2}=\\dfrac{k}{m}$，$2 \\beta=\\dfrac{\\gamma}{m}$ 微分方程的解 当阻尼较小，即 $\\beta^2&lt;\\omega_0^2$ 时$$x(t)=A \\mathrm{e}^{-\\beta t} \\cos (\\omega t+\\varphi)$$ 当阻尼较大，即 $\\beta^2&gt;\\omega_0^2$ 时$$x(t)=c_{1} \\mathrm{e}^{-\\left(\\beta-\\sqrt{\\beta^{2}-\\omega_{0}^{2}}\\right) t}+c_{2} \\mathrm{e}^{-\\left(\\beta+\\sqrt{\\beta^{2}-\\omega_{0}^{2}}\\right) t}$$ 当 $\\beta=\\omega_0$ 时$$x(t)=(c_1+c_2x) {\\mathrm e}^{-\\beta t}$$ 受迫振动 振动表达式$$\\frac{\\mathrm{d}^{2} x}{\\mathrm{d} t^{2}}+2 \\beta \\frac{\\mathrm{d} x}{\\mathrm{d} t}+\\omega_{0}^{2} x=h \\cos p t$$其中，$\\omega_{0}^{2}=\\dfrac{k}{m}$，$2 \\beta=\\dfrac{\\gamma}{m} $，$h=\\dfrac{H}{m}$ 方程的解（$\\beta^2&lt;\\omega_0^2$）$$x=A \\mathrm{e}^{-\\beta t} \\cos (\\omega t+\\varphi)+B \\cos \\left(p t+\\varphi_{\\mathrm{p}}\\right)$$其中，$B=\\dfrac{h}{\\sqrt{\\left(\\omega_{0}^{2}-p^{2}\\right)^{2}+4 \\beta^{2} p^{2}}}$，$\\varphi_{\\mathrm{p}}=\\arctan \\dfrac{-2 \\beta p}{\\omega_{0}^{2}-p^{2}}$ 共振角频率$$\\omega_{\\mathrm{r}}=\\sqrt{\\omega_{0}^{2}-2 \\beta^{2}}$$共振振幅$$B_{\\mathrm{r}}=\\frac{h}{2 \\beta \\sqrt{\\omega_{0}^{2}-\\beta^{2}}}$$ 机械波 机械波产生的条件： 要有作机械振动的物体（波源） 要有能够传播这种机械振动的弹性介质 波动过程就是振动相位的传播过程 波的类型 横波：质元振动方向与传播方向相垂直 横波传播时，介质要发生切向形变，液体和气体不能承受切变，因此只有固体能传播横波 纵波：质元振动方向与传播方向相一致 波的特征量：波速、波频、波长 三者之间的关系 $$u=\\nu \\lambda$$ 波速的计算 固态介质中 横波：$u=\\sqrt{\\dfrac{G}{\\rho}}$，或 $u=\\sqrt{\\dfrac{T}{\\mu}}$（在拉紧的细绳中） 纵波：$u=\\sqrt{\\dfrac{E}{\\rho}}$（近似） 其中，$G$：切变模量；$E$：弹性模量；$\\mu$：质量线密度；$\\rho$：密度 液体和气体中 纵波：$u=\\sqrt{\\dfrac{B}{\\rho}}$ 其中，$B$：体积模量 平面简谐波 波函数（波动表达式）$$y=A \\cos \\left[\\omega\\left(t-\\frac{x}{u}\\right)+\\varphi\\right]$$ $$y=A \\cos \\left[2 \\pi\\left(\\frac{t}{T}-\\frac{x}{\\lambda}\\right)+\\varphi\\right]$$ $$y=A \\cos \\left[2 \\pi\\left(\\nu t-\\frac{x}{\\lambda}\\right)+\\varphi\\right]$$ 波具有时间和空间上的周期性 平面简谐波的波函数定量地表达了行波的传播情况 平面波的波动方程（平面简谐波的微分方程）$$\\frac{\\partial^{2} y}{\\partial x^{2}}=\\frac{1}{u^{2}} \\frac{\\partial^{2} y}{\\partial t^{2}}$$ 能量密度$$w=\\frac{\\mathrm{d} E}{\\mathrm{~d} V}=\\rho A^{2} \\omega^{2} \\sin ^{2} \\omega\\left(t-\\frac{x}{u}\\right)$$ 平均能量密度$$\\bar{w}=\\frac{1}{T} \\int_{0}^{T} \\rho A^{2} \\omega^{2} \\sin ^{2} \\omega\\left(t-\\frac{x}{u}\\right) \\mathrm{d} t=\\frac{1}{2} \\rho A^{2} \\omega^{2}$$ 注意：波动中质元所拥有的能量与质点作简谐运动所拥有的能量不同：作简写运动的质点 是孤立系统，机械能守恒，$E_{\\rm k}$、$E_{\\rm p}$ 变化步调相反；而波动中的介质质元是非孤立系统，机械能不守恒，$E_{\\rm k}$、$E_{\\rm p}$ 变化步调相同。 能流密度（波印廷矢量、波的强度）：单位时间内通过垂直于波传播方向的单位面积上的平均能流$${\\boldsymbol I}=\\frac{1}{2} \\rho A^{2} \\omega^{2} \\boldsymbol{u}$$ 声波的能流密4度为声强，光的能流密度为光强。 波的衍射、反射和折射 惠更斯原理：介质中任意波面上的各点，都可以看做是发射子波的波源，其后任意时刻，这些子波相应的波前的包迹就是新的波前。 波的衍射（或绕射）现象：波在传播过程中遇到障碍物时，波线发生弯曲并能绕过障碍物边缘的现象。 $d/\\lambda$ 越大，衍射现象越显著。 波的反射定律：反射角等于入射角，且入射角、法线和反射线在同一平面内。 波的折射定律：入射角的正弦与折射角的正弦之比等于第一种介质与第二种介质中的波速之比，即为一恒量，此恒量 $n_{21}$ 称为第二介质对第一介质的相对折射率；入射线、折射线和分界面法线在同一平面内。$$\\frac{\\sin i}{\\sin r}=\\frac{u_{1}}{u_{2}}=n_{21}=\\frac{n_2}{n_1}$$其中，$n_1$ 和 $n_2$ 为介质的绝对折射率（简称折射率）。 波的干涉 波的叠加原理：由于波具有传播的独立性，当几列波在介质中同时传播到空间某一区域内，该区域内任一点处质元的振动，为各列波单独存在时在该点所引起质元振动的位移之矢量和。 波的干涉现象：若两个波源，满足频率相同、振动方向相同、相位相同（或相位差恒定）的条件，则它们所发出的波在介质中相遇而叠加时，在相遇处的质元便同时参与这两个具有恒定相位差的同频率、同方向的振动。对两列波相遇区域内的各质元来说，其相位差不尽相同，因而这两列波在介质中相遇时，就出现某些点处的质元振动始终加强，而另一些点处的质元振动始终减弱的现象。这种现象称为波的干涉现象。 上述条件称为相干条件，满足相干条件的两个波源称为相干波源，由相干波源发出的波称为相干波。 合振幅 $A$ 最大和最小的条件$$\\delta=r_{1}-r_{2}=\\left{\\begin{array}{ll}\\pm k \\lambda, &amp; A=A_{1}+A_{2} \\\\pm(2 k+1) \\dfrac{\\lambda}{2}, &amp; A=\\left|A_{1}-A_{2}\\right|\\end{array}\\right.$$ 驻波：如果两列相干波振幅相同，在同一直线上沿相反方向传播，那么会形成一种特殊的干涉现象，即驻波。 驻波函数$$y=\\left(2 A \\cos \\frac{2 \\pi x}{\\lambda}\\right) \\cos \\omega t$$ 波腹和波节的位置$$x_{腹}=\\frac{k \\lambda}{2},\\quadx_{节}=\\frac{2 k+1}{4} \\lambda \\quad(k=0,\\pm 1,\\pm 2, \\cdots)$$ 驻波的能流密度$${\\boldsymbol I}=0$$ 半波损失：反射波有 $\\pi$ 的相位突变 条件：波从波疏介质传到波密介质（$\\rho u$ 较大的介质） 若波从波密介质传到波疏介质，则没有相位跃变，反射处为波腹 真题笔记","link":"/2021/08/06/0201.html"}],"tags":[{"name":"TODO","slug":"TODO","link":"/tags/TODO/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"ROS","slug":"ROS","link":"/tags/ROS/"},{"name":"机械臂","slug":"机械臂","link":"/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/"},{"name":"SLAM","slug":"SLAM","link":"/tags/SLAM/"},{"name":"电脑故障","slug":"电脑故障","link":"/tags/%E7%94%B5%E8%84%91%E6%95%85%E9%9A%9C/"},{"name":"课程","slug":"课程","link":"/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"VLC","slug":"VLC","link":"/tags/VLC/"},{"name":"Beaglebone","slug":"Beaglebone","link":"/tags/Beaglebone/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"}],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"HTML","slug":"HTML","link":"/categories/HTML/"},{"name":"Latex","slug":"Latex","link":"/categories/Latex/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"ROS","slug":"ROS","link":"/categories/ROS/"},{"name":"SLAM","slug":"SLAM","link":"/categories/SLAM/"},{"name":"电脑故障","slug":"电脑故障","link":"/categories/%E7%94%B5%E8%84%91%E6%95%85%E9%9A%9C/"},{"name":"VLC","slug":"VLC","link":"/categories/VLC/"},{"name":"课程","slug":"课程","link":"/categories/%E8%AF%BE%E7%A8%8B/"}]}