{"pages":[],"posts":[{"title":"基于Hexo、Icarus和GitHub_Pages搭建个人博客","text":"方案选择代码高亮工具 Jekyll自带的 Pygments Rouge（Jekyll默认） Highlight JS 兼容 Rouge 与 Pygments。 SyntaxHighlighter Prismjs Jekyll 并不能直接支持他，需要下载prism.rb插件来使用。下载后拷贝到项目_plugins文件夹中。 图片管理方案picgo+github即可 Hexo主题用了Icarus主题 搭建步骤安装Node.js和GitHexo是作为一个node包存在的。Node.js含包管理器npm。 Download | Node.js (nodejs.org) Git - Downloads (git-scm.com) 安装Hexo模块 全局安装（推荐） 用PowerShell在任意路径下运行 1npm install -g hexo-cli 全局安装路径可以用npm root -g命令查看，一般在C:\\Users\\Username\\AppData\\Roaming\\npm\\node_modules。安装完成后即可在任意路径下使用hexo &lt;command&gt;形式的命令。 局部安装 新建一个MyBlog文件夹，用PowerShell在MyBlog文件夹路径下运行 1npm install hexo 安装路径为当前路径下的node_modules文件夹。安装完成后需要用npx hexo &lt;command&gt;形式执行hexo相关命令（npx会找到hexo程序包的位置）。 注意：如果采用局部安装方式，则所有hexo命令都要加上npx前缀，下面不再赘述。 初始化Hexo博客框架 若Hexo是全局安装的 新建一个MyBlog文件夹，在该文件夹路径下用PowerShell或Git Bash运行 1hexo init 或不创建文件夹，直接运行 1hexo init MyBlog hexo init MyBlog命令相当于执行了两步： git clone https://github.com/hexojs/hexo-starter.git MyBlog cd MyBlog &amp;&amp; npm install &amp;&amp; cd .. 若Hexo是局部安装的 那么这时候已经有MyBlog文件夹，且该文件夹非空，目录结构如下： 123- MyBlog/ - node_modules/ - package-lock.json 由于hexo init命令只能在空文件夹下运行，因此直接在MyBlog下运行npx hexo init会报错。因此需要自行拉取博客框架并安装所需Node模块： 12345cd MyBloggit initgit remote add origin https://github.com/hexojs/hexo-starter.gitgit pull origin masternpm install 以上操作完成后，MyBlog的目录结构如下： 12345678910111213- MyBlog/ - .github/ - node_modules/ - scaffolds/ - source/ - _posts/ - hello-world.md - themes/ - .gitignore - _config.landscape.yml - _config.yml - package.json - package-lock.json 博客源文件放在_posts目录下，第三方主题文件在themes目录下。在MyBlog路径下运行 12hexo g # 等价于 hexo generate，生成HTML文件hexo s # 等价于 hexo deploy，启动本地服务器 然后用浏览器访问http://localhost:4000/，即可进行博客部署测试和效果预览（此时默认使用Hexo的landscape主题）。 安装和配置Icarus博客主题首先拉取icarus主题文件。在theme路径下运行 1git clone git://github.com/ppoffice/hexo-theme-icarus.git icarus 然后切换主题。打开MyBlog路径下的_config.yml文件，将主题修改为icarus（注意要与主题文件夹名一致），如下： 1theme: icarus 查看icarus文件夹下的package.json文件可发现Icarus需要几个额外的Node依赖，因此需要补充安装。可以在MyBlog路径下随便运行一个Hexo命令，比如直接运行hexo，然后复制报错信息中的安装依赖的提示并运行，以安装Icarus所需依赖。安装完成后再运行hexo测试有没有报错再进行下一步。 安装提示类似于npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.13.0 inferno@^7.3.3 inferno-create-element@^7.3.3，版本号可能不同。 实际上fsevents包是Darwin系统的，并不需要安装。但按上面操作也不会有什么问题，因为系统会自动忽略。 在安装完Icarus所需的依赖并运行任意Hexo命令后，MyBlog文件夹下会出现_config.icarus.yml配置文件，具体的配置方法见Icarus用户指南 - 主题配置，这里不赘述。 最后在本地测试安装（和配置）Icarus主题后的效果： 123hexo cleanhexo ghexo s 将博客部署到Github Pages新建代码仓库在Github上新建一个代码仓库，注意仓库名称须为username.github.io，且在 Setting -&gt; Pages 中选择博客要部署到的分支和文件夹，比如分别为master和根目录/。主题不需要选择，那个是给Jekyll框架用的。 部署博客 安装 hexo-deployer-git. 在_config.yml中添加如下配置： 12345deploy: type: git repo: https://github.com/&lt;username&gt;/&lt;project&gt; # 例如 https://github.com/hexojs/hexojs.github.io branch: master 运行hexo clean &amp;&amp; hexo deploy。 查看&lt;username&gt;.github.io上的网页是否部署成功。 可能需要魔法才能访问。 参考 文档 | Hexo Icarus (ppoffice.github.io)","link":"/2021/08/06/2225.html"},{"title":"Git学习笔记","text":"参考：廖雪峰的官方网站 Quick Start常用命令帮助1234git -h # 简略的帮助git 命令 -hgit --help # 详细的帮助（HTML文档）git 命令 --help 得到仓库12git init # 初始化空文件夹为仓库git clone 仓库地址 安全命令123git status # 查看当前工作区、暂存区和提交区的状态git loggit reflog 流程12345678910111213# 正向流程git add &lt;file&gt; # 工作区 -&gt; 暂存区git commit -m &lt;message&gt; # 暂存区 -&gt; 提交区# 反向流程git checkout &lt;file&gt; # 工作区 &lt;- 暂存区，等价于 `git restore --staged .`git checkout &lt;branch&gt; &lt;file&gt; # (工作区 &amp; 暂存区) &lt;- 提交区git reset &lt;branch&gt; &lt;file&gt; # 暂存区 &lt;- 提交区# 删除git rm &lt;file&gt; # 从工作区删除文件（工作区中的Untracked的文件不能用此命令删除；暂存区中该文件有状态需要加-f选项强制删除）git rm --cached &lt;file&gt; # 从暂存区删除文件git clean # 从工作区删除Untracked的文件，加选项-n查看会删除哪些文件 注意： 删除文件夹中的最后一个文件的时候，文件夹也会被删除 文件路径或说明信息中若没有空格，则不需要加引号 文件路径为 . 时，表示当前路径 文件路径也可以为文件夹路径，只要加选项 -r 即可递归地操作该文件夹下的内容 分支123456789git branch # 查看所有分支git branch &lt;branch&gt; # 创建分支git switch &lt;branch&gt; # 切换分支，或 git checkout &lt;branch&gt;git switch -c &lt;branch&gt; # 创建并切换分支，或 git checkout -b &lt;branch&gt;git merge &lt;branch&gt; # 合并指定分支到当前（HEAD）分支git branch -d &lt;branch&gt; # 删除分支 HEAD 和 master 都是指针，HEAD 指向的是指向当前分支/节点的指针。 远程123git push # 提交区 -&gt; 远程git pull # 工作区 &lt;- 远程git fetch # 提交区 &lt;- 远程 标签123456git tag # 查看所有标签git tag &lt;tagname&gt; &lt;key-id&gt; # 给某个提交的版本打标签git tag -a &lt;tagname&gt; -m &lt;message&gt; &lt;key-id&gt; # 创建有注释（annotate）的标签git tag -d &lt;tagname&gt; # 删除标签git show &lt;tagname&gt; # 查看指定标签的版本信息 注意：标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。 文件状态工作区文件（跟暂存区文件比较）的状态（Git Bash 中默认是红色）： Untracked - 未追踪，新增文件的状态 Modified - 已修改 Deleted - 已删除 Renamed - 已重命名 暂存区文件（跟提交区文件比较）的状态（Git Bash 中默认是绿色）： New file - 新增文件 Modified - 已修改 Deleted - 已删除 .gitignore 文件 注意： .gitignore 没有文件拓展名 注释不能放在语句的后面！ 在添加 .gitignore 文件之前已经在暂存区中（即已追踪）的文件的修改不会被忽略。将暂存区中的所有 PDF 文件移除可使用 git rm --cached *.pdf 命令 例 1234567# 注释# 这里没有忽略*.py*.py[cod].*# 例外!.gitignore Git简介Git的特点 Git是一种分布式版本控制系统（区别于集中式）。 在Git的版本管理中，文件的创建、修改、删除都被Git处理为“修改”。Git管理的是修改，而非文件。 Git上手安装 Git首先从Git官网下载安装包，安装完成后，打开Git Bash，输入 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 这是每次提交（commit）会使用的信息。用下面的命令可以查看当前所有配置信息 1git config -l 创建版本库 首先创建并进入文件夹 12mkdir learngitcd learngit 通过git init命令把这个目录变成Git可以管理的仓库 1git init 添加文件 将文件（假如叫*.txt）放到文件夹下，然后在该文件夹下执行 1git add *.txt 也可以同时添加多个文件或分多次添加多个文件。 提交文件，并添加更新内容的说明 1git commit -m &quot;I wrote a file named *.txt&quot; 时光机穿梭更新文档修改完文档后，重复“添加文件”小节中的步骤即可更新修改内容到版本库。 另外，使用命令git status可以查看版本库的暂存区的当前状态，命令git diff可以查看修改的内容。 版本找回每次执行git commit都会提交一个新的版本，使用git log可以查看最近的三个版本记录，git log --pretty=oneline可以简化输出。 回退到上一个版本： 1git reset --hard HEAD^ 回退到上上个版本： 1git reset --hard HEAD^^ 回退100个版本： 1git reset --hard HEAD~100 上面的例子说明HEAD（其实是一个指针）就是当前版本。 也可直接跳到指定版本： 1git reset --hard id 其中 id 可以使用命令 git log 查看（id 没必要写全，写前几位就行，但也不能太少）。 切换到老版本后，git log 将看不到新的版本。若要切换回新版本，可用 git reflog 命令查看每一次版本更换记录，找到新版本的 id。 工作区、暂存区和主存区工作区中的文件就是在文件资源管理器中实际能看到的文件。 如图，git add命令会将工作区（Working Directory）的文件添加到版本库的暂存区/缓存区（stage）处，而git commit命令会将暂存区的文件添加到主存区/提交区（master）处（姑且这么叫吧）。 这个图的 checkout 不太对，最好添加上指向 stage 的箭头 另外可以发现，在一般情况下，工作区和主存区的文件树都是相对完整的，而暂存区只有部分文件。 版本丢弃 这个图是对的 丢弃工作区的改动1git checkout [--] &lt;file&gt; checkout 是检查的意思，所以 git checkout 系列命令的意思是把（暂存区或提交区的）文件拿到工作区和暂存区，以进行检查、修改。 当执行 git checkout .（或者 git checkout &lt;file&gt;）命令时，会用暂存区的全部（或指定）文件替换工作区的全部（或指定）文件。这个操作很危险，会清除工作区全部（或指定）文件中未添加到暂存区的改动。 丢弃暂存区的改动123git reset HEAD [--] &lt;file&gt;# 或git rm --cached [--] &lt;file&gt; 命令 git reset HEAD &lt;file&gt; 会用 HEAD 指向的分支中的指定文件 &lt;file&gt; 替换暂存区中的指定文件 &lt;file&gt;（而不改变工作区）。 命令 git rm --cached &lt;file&gt; 把文件的修改信息从暂存区删除（而不改变工作区）。 如果暂存库的修改内容已经用 git commit 命令提交到本地版本库了，可以参考版本找回一节回退版本；若推送到了远程库则无法回退。 丢弃工作区和暂存区的改动使用 git checkout HEAD .（或者 git checkout HEAD &lt;file&gt;）命令时，会用 HEAD 指向的分支中的全部（或指定）文件替换暂存区和以及工作区中的全部（或指定）文件。只替换部分文件时，其他文件不影响。这个命令也是极具危险性的，因为会清除工作区和暂存区中全部（或指定）文件中未提交的改动。 1git checkout &lt;branch&gt; [--] &lt;file&gt; 当执行 git checkout HEAD .（或者 git checkout HEAD &lt;file&gt;）命令时，会用 HEAD 指向的 master 分支中的全部（或指定）文件替换暂存区和以及工作区中的全部（或指定）文件。只替换部分文件时，其他文件不影响。这个命令也是极具危险性的，因为会清除工作区和暂存区中全部（或指定）文件中未提交的改动。 文件删除问题Git 速度慢方法一123456git clone https://github.com/cpselvis/geektime-webpack-course.git# 改为git clone https://github.com.cnpmjs.org/cpselvis/geektime-webpack-course.git# cnpmjs：company npm/js 方法二https 改成 git，即 1git clone git://github.com/cpselvis/geektime-webpack-course.git 方法三配置ssh key（方法网上找），完了之后 1git clone git@github.com/cpselvis/geektime-webpack-course.git 配置 GitHub SSH12# 根据字符串生成SSH公钥和私钥（rsa算法）ssh-keygen -t rsa –C &quot;xxx@xxx.com&quot; 复制公钥，在 GitHub 的 Setting 的 SSH and GPG keys 中粘贴公钥。 Git Bash 中文显示为 Unicode1git config --global core.quotepath false","link":"/2021/08/06/0200.html"},{"title":"MySQL学习笔记","text":"参考：https://www.bilibili.com/video/BV12b411K7Zu 前言数据库的好处保存数据的容器： 内存 数组 集合 …… 文件 数据库 好处： 数据持久 可以实现结构化查询，方便查询和管理 数据库的相关概念 DB：database，数据库 DBMS：Database Management System，数据库管理系统 常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer SQL：Structure Query Language，结构化查询语言 SQL的优点： 几乎所有DBMS都支持SQL 简单易学 可以进行复杂和高级的数据库操作 数据库存储数据的特点 将数据放到表中，表再放到库中 表名具有唯一性 表具有一些特性，类似Java中的“类” 表由列组成，也称为“字段”，类似Java中的“属性” 表中的数据是按行存储的，每一行类似Java中的“对象” MySQL 的安装与使用MySQL的优点： 成本低：源代码开源 性能高 简单，体积小 DBMS分为两类： 基于共享文件系统 基于客户机（服务器） MySQL： 社区版（免费） 企业版（收费） 用5.5版本就行了，第三位版本最新即可，如5.5.62 配置程序位置：C:\\Program Files\\MySQL\\MySQL Server 5.5\\bin\\MySQLInstanceConfig.exe 这里将服务名设为 MySQL0815 配置文件：my.ini MySQL 配置 下面两个分别是事务型和非事务型。 这里服务名可以改为任意名字 启动与停止 MySQL 服务数据库是以系统服务的形式运行的。层级关系为：数据库服务 -&gt; 数据库（多个） -&gt; 表（多个） -&gt; 栏（多个）。因此使用数据库服务需要： 启动数据库服务（如果设置了开机自启就不用） 方法一：计算机管理 -&gt; 服务 -&gt; MySQL 方法二：命令行提示符中 12net stop MySQL0815net start mysql0815 不用区分大小写 连接（登录）到数据库服务 登录与退出 MySQL 服务登录 方法一（只限root用户）：开始 -&gt; MySQL 5.5 Command Line Client -&gt; 输入密码 方法二（任意用户，推荐）：命令行提示符 12345678mysql -h localhost -P 3306 -u root -p# 然后输入密码，或去掉选项后的空格mysql -hlocalhost -P3306 -uroot -p# 密码也可以显式输入（假设密码是0406）mysql -hlocalhost -P3306 -uroot -p0406# 注意：密码和`-p`之间一定不能有空格# 本地端也可以简写成mysql -uroot -p 退出Ctrl+c 或输入命令 exit MySQL 常见命令与函数常见命令 注意：命令后要加分号！ 12345678910111213141516171819show databases; # 查看当前所有数据库use 库名; # 打开指定的库select database(); # 查看当前数据库show tables; # 查看当前库的所有表show tables from 库名; # 查看其它库的所有表create table 表名( # 创建表 列名 列类型, 列名 列类型, ...)desc 表名; # 查看表结构select * from 表名; # 查看表内容select version(); # 查看服务器的版本# 或在命令行提示符中输入`mysql --version`或`mysql -V`# 执行SQL脚本（注意目录不能有空格，且不需要加引号）source 文件名 常见函数12345# 常见函数select version();select concat(字段, 字段, ...) from 表名;select isnull(字段) from 表名;select ifnull(字段, 值) from 表名; MySQL 语法规范 不区分大小写，但建议关键字大写，表名、列名小写（用如 SQLyog 等可视化界面操作可以自动格式化） 每条命令用分号结尾（也可以用 \\g 结尾） 每条命令根据需要，可以进行缩进、换行 注释 单行注释：# 注释文字 或 -- 注释文字（后者一定要有空格） 多行注释：/* 注释文字 */ DQL（Data Query Language）查询基本语法： 1select 查询列表 from 表名; 特点： 查询列表可以是：表中的字段、常量值、表达式、函数 查询的结果是一个虚拟的表格（临时显示） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239USE myemployees;# --------------------------------------# 一、基础查询# 1.查询表中的单个字段SELECT last_name FROM employees;# 2.查询表中的所有字段SELECT last_name,salary,email FROM employees;# 3.查询表中的所有字段# 法一：双击字段，会自动填入，且带着重号SELECT`employee_id`,`first_name`,`last_name`,`email`,`phone_number`,`job_id`,`salary`,`commission_pct`,`manager_id`,`department_id`,`hiredate` FROM `employees`;/* 技巧：F12格式化 *//* 着重号的作用：表示字符串为字段而非关键字 */SELECT `name` FROM employees;# 法二：用`*`SELECT * FROM employees;# 4.查询常量值SELECT 100;SELECT 'john';# 5.查询表达式SELECT 100*98;SELECT 100%98;# 6.查询函数SELECT VERSION();# 7.起别名/* 作用：1.便于理解2.区分重名字段*/# 法一：SELECT 100%98 AS 结果;SELECT last_name AS 姓, first_name AS 名 FROM employees;# 法二：SELECT last_name 姓, first_name 名 FROM employees;# 案例：别名中有特殊字符或为关键字时SELECT salary AS &quot;out put&quot; FROM employees;# 8.去重# 案例：查询员工表中涉及到的所有的部门编号SELECT DISTINCT department_id FROM employees;/* destinct 翻译为不同的 */# 9.`+`的作用：运算符# 案例：查询员工名和姓连接成一个字段，并显示为姓名SELECT last_name+first_name AS 姓名 FROM employees; # 结果与预期不符SELECT 100+90;SELECT '100'+90;SELECT 'john'+90;SELECT NULL+10; # 加数中有null则结果为nullSELECT CONCAT('a','b','c') AS 结果;SELECT CONCAT(last_name,' ',first_name) AS 姓名 FROM employees;/* ifnull函数的作用 */SELECT IFNULL(commission_pct, 0) AS 奖金率, commission_pct FROM employees;# -----------------------------------# 二、条件查询/*语法： select 查询列表（字段） from 表名 where 筛选条件;分类：1.按条件表达式筛选（条件运算符：&gt; &lt; &gt;= &lt;= = !=或&lt;&gt;）2.按逻辑表达式筛选（逻辑运算符：&amp;&amp;或and ||或or !或not）3.模糊查询 like between and in is null*/# 1.按条件表达式筛选# 案例1：查询工资大于12000的员工信息SELECT *FROM employeesWHERE salary&gt;12000;# 案例2：查询部门编号不等于90号的员工名和部门编号SELECT last_name, department_idFROM employeesWHERE department_id&lt;&gt;90; # 2.按逻辑表达式筛选# 案例1：查询工资在10000到20000之间的员工名、工资以及奖金SELECT `last_name`, `salary`, `commission_pct`FROM `employees`WHERE `salary`&gt;=10000 AND `salary`&lt;=20000; # 案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息SELECT *FROM employeesWHERE NOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000; # 3.模糊查询/*likebetween andinis null*/# 3.1 like# 案例1：查询员工名中包含字符a的员工信息SELECT *FROM employeesWHERE last_name LIKE &quot;%a%&quot;; # %是通配符/*通配符：%：任意多个字符，包含0个字符_：任意单个字符*/# 案例2：查询员工名中第三个字符为e，第五个字符为a的员工名和工资SELECT last_name, salaryFROM emloyeesWHERE last_name LIKE &quot;__e_a%&quot;; # 案例3：查询员工名中第二个字符为_的员工名SELECT last_nameFROM employeesWHERE last_name LIKE &quot;_\\_%&quot;; # 用\\转义# 或SELECT last_nameFROM employeesWHERE last_name LIKE &quot;_$_%&quot; ESCAPE '$'; # 用escape关键字实现任意字符转义# 3.2 between and# 案例：查询员工编号在100到120之间的员工信息SELECT *FROM employeesWHERE employee_id BETWEEN 100 AND 120; # 包含端点，不能颠倒# 3.3 in# 案例：查询工种编号是IT_PROG、AD_VP或AD_PRES的员工的员工名和工种编号SELECT last_name, job_idFROM employeesWHERE job_id IN('IT_PROG', 'AD_VP', 'AD_PRES');/*注意：1.不支持通配符2.数据类型要一致或者兼容*/# 3.4 is null# 案例1：查询没有奖金的员工名和奖金率SELECT last_name, commission_pctFROM employeesWHERE commission_pct IS NULL; # =或&lt;&gt;不能用于判断null值# 或者用“安全等于” &lt;=&gt;SELECT last_name, commission_pctFROM employeesWHERE commission_pct &lt;=&gt; NULL;# 案例2：查询工资为12000的员工名SELECT last_nameFROM employeesWHERE salary &lt;=&gt; 12000; # 综合案例：查询员工号为172的员工的姓名、部门号和年薪SELECT last_name, department_id, salary*12*(1+IFNULL(commission_pct,0)) AS 年薪FROM employeesWHERE employee_id = 172; # 三、排序查询/*语法： select 查询列表（字段） from 表 DML（Data Manipulation Language）DDL（Data Definition Language）TCL（Transaction Control Language）可视化工具SQLyog体验不错，唯一的缺点是很多快捷键需要专业版才能支持。 VS code 插件安装 MySQL 和 MySQL Syntax 两个插件。其中 MySQL 同名的有两个，cweijan 的最近有更新，另一个代码仓库 issue 很多都没有处理。最后两个都试了一下，体验都不是很好。 DBeaver社区版免费。但是一开始用需要做一些设置。 连接数据库 与 SQLyog 不同，DBeaver 需要配置每个脚本所连接的数据库，否则脚本无法执行。DBeaver 的项目结构如下： 正确的做法是：每个项目都要设置至少一个连接（Connections），项目文件夹下新建一个 Scripts 文件夹，用来放脚本，右键脚本（可多选），选择 associate with data source，然后选择 Connections 中的其中一个数据源进行连接。连接之后脚本名左边会出现连接到的数据库服务的名称（如 &lt;localhost&gt; Script）。 编码调整：解决脚本中文乱码问题 编辑 -&gt; 设置编码 -&gt; 缺省（从容器继承）。默认就是这样设置的，所以一般这里不要动。 这个「容器」是什么概念我也不懂，可能是类似「窗口」的意思，因为 DBeaver 中主页面竟然就有三个设置按钮： 每个设置按钮都似乎对应按钮所在的窗口。三个设置是独立的，而且都能设置文本文件的编码格式…… 然后点击「项目」窗口的设置按钮，选择「资源」，在「文本文件编码」栏中选择「其他」，然后选择脚本文件的编码格式。 字体调整 Windows 10 下选择「使用系统字体」即可，比默认的好看一些。","link":"/2021/08/13/1410.html"},{"title":"LaTeX学习笔记","text":"环境配置 注意：项目不能放在中文路径下！ 编译过程1234(xe/pdf)latex main.tex # 表示使用 latex, pdflatex 或 xelatex 编译，下同bibtex main.aux(xe/pdf)latex main.tex(xe/pdf)latex main.tex 无新的引用时可只用(xe/pdf)latex编译一次。 VS Code安装 LaTex Workshop 插件。在命令面板中输入 LaTeX Workshop 就可以看到所有的命令，在命令旁边就可以看到快捷键。 Ctrl + Alt + B：编译Ctrl + Alt + C：清除 auxiliary 文件Ctrl + Alt + J：定位跳转到光标所在位置对应的 PDF 文件位置Ctrl + Alt + V：打开 PDF 预览 文件类型12345678tex - tex文件是最常见的latex文件，也是平时编写文章的文件cls - cls文件是latex的格式文件，规定了tex源文件的排版格局，称为类文件（class），一般使用\\documentclass{}导入sty - sty文件是宏包文件（package），一般使用\\usepackage{}导入bst - bst文件是参考文件的格式文件，一般使用\\bibliographystyle{}导入bib - bib文件是参考文献的库，一般使用\\bibliography{}导入dtx - 包含类或宏包及其说明文件的文件，需用同名.ins文件或docstrip工具分解。 bst - bib style hitszthesis.cls和hitszthesis.cfg可由hitszthesis.ins和hitszthesis.dtx生成 Classes are .cls files; packages are stored in .sty files. They are very similar, the main difference being that you can load only one class per document. LaTeX 自学方法命令与文档查询12345texdoc ifthentexdef --helptexdef vskiptexdef -s vskip # 展示源代码latexdef textwidth 网站 CTAN: the Comprehensive TeX Archive Network TUG: TeX Users Group LaTeX Community TeX Stack Exchange 参考文献条目例 .tex 文件 12345678\\documentclass{article}\\bibliographystyle{plain}\\begin{document}\\section{Some words}Some excellent books, for example, \\cite{citation1}and \\cite{citation2} \\ldots\\bibliography{books}\\end{document} .bib 文件 123456789@article{Alice13,title = {Demostration of bibliography items},author = {Alice Axford and Bob Birkin and Charlie Copper and Danny Dannford},year = {2013},month = {Mar},journal = {Journal of \\TeX perts},volume = {36},number = {7},pages = {114-120}} BibTeX条目类型@article期刊杂志的论文必要域: author, title, journal, year.可选域: volume, number, pages, month, note. volume是卷号，number是期号（有些格式为issue） @book公开出版的图书必要域: author/editor, title, publisher, year.可选域: volume/number, series, address, edition, month, note. @booklet无出版商或作者的图书必要域: title.可选域: author, howpublished, address, month, year, note. @conference等价于 inproceedings必要域: author, title, booktitle, year.可选域: editor, volume/number, series, pages, address, month, organization, publisher, note. @inbook书籍的一部分章节必要域: author/editor, title, chapter and/or pages, publisher, year.可选域: volume/number, series, type, address, edition, month, note. @incollection书籍中带独立标题的章节必要域: author, title, booktitle, publisher, year.可选域: editor, volume/number, series, type, chapter, pages, address, edition, month, note. @inproceedings会议论文集中的一篇必要域: author, title, booktitle, year.可选域: editor, volume/number, series, pages, address, month, organization, publisher, note. @manual技术文档必要域: title.可选域: author, organization, address, edition, month, year, note. @mastersthesis硕士论文必要域: author, title, school, year.可选域: type, address, month, note. @misc其他必要域: none可选域: author, title, howpublished, month, year, note. 123456@misc{光明网2020, author = {光明网}, title = {南山区再获“国字号”绿色荣誉}, howpublished = {\\url{https://m.gmw.cn/2020-10/19/content_1301689251.htm}}, year = {2020}} 注意要 \\usepackage{url} @phdthesis博士论文必要域: author, title, year, school.可选域: address, month, keywords, note. @proceedings会议论文集必要域: title, year.可选域: editor, volume/number, series, address, month, organization, publisher, note. @techreport教育，商业机构的技术报告必要域: author, title, institution, year.可选域: type, number, address, month, note. @unpublished未出版的论文，图书必要域: author, title, note.可选域: month, year. 公式相关技巧公式大小调整12345678910111213141516\\dfrac{}{} % 在行内使用行间大小显示分式，d和t是什么意思？\\tfrac{}{} % 在行间使用行内大小显示分式\\displaystyle{\\frac{}{}}% 分式高度变高之后，有时需要调整相邻公式行之间的间距\\begin{equation}\\label{eq:f} \\left\\{ \\begin{array}{c} \\displaystyle{f_{\\text{x}}=\\frac{f}{s_{\\text{x}}}}\\\\[8pt] % &lt;--这里可以调整间距 \\displaystyle{f_{\\text{y}}=\\frac{f}{s_{\\text{y}}}}\\\\ \\end{array} \\right.\\end{equation}\\left\\{ \\right. % 多行大左括号\\left\\. \\right\\} % 多行大右括号 希腊字母记忆$$\\phi \\quad \\Phi \\quad \\varphi \\quad \\varPhi$$ 1\\phi \\Phi \\varphi \\varPhi % 注意这四个的区别，P大写说明字母大写，var是variable，用来表示变量 公式换行与等号对齐123456\\begin{equation} \\begin{aligned} a &amp;= b+c\\\\ &amp;= c+b \\end{aligned}\\end{equation} 其他技巧对齐与间距12345678910111213\\vskip 0pt % 立即转为竖直模式\\hskip 0pt % 立即转为水平模式\\vfill % 在当前段落后竖直填充无限空间，使用多个可以使得元素均布排列\\hfill % 在当前段落后水平填充无限空间，使用多个可以使得元素均布排列\\vspace{\\fill} % 在当前行后面竖直填充无限空间\\hspace{\\fill} % 在当前行后面水平填充无限空间\\vspace{1ex} % 行尾竖直空1个x的距离\\hspace{1em} % 水平空1个M的距离\\hspace{\\stretch{1}} % 水平留出一倍的距离（需要多处使用） 浮动体空白太多用\\clearpage命令进行调整。（放在图片前面，这样图片和后面的文字就会变成一页） 盒子12345678910111213141516% 水平盒子（不能换行）\\mbox{…}\\makebox[⟨width⟩][⟨align⟩]{…}% 带框的水平盒子\\fbox{…}\\framebox[⟨width⟩][⟨align⟩]{…}% 垂直盒子\\parbox[⟨align⟩][⟨height⟩][⟨inner-align⟩]{⟨width⟩}{…} % 段落盒子\\begin{minipage}[⟨align⟩][⟨height⟩][⟨inner-align⟩]{⟨width⟩} … % 迷你页\\end{minipage}% 实心盒子，可以用来画线，\\hrule 可以画一条水平横线\\rule[⟨raise⟩]{⟨width⟩}{⟨height⟩} ⟨align⟩：对齐方式，可选居中 c（默认值）、左对齐 l、右对齐 r 和分散对齐 s 生成目录和 pdf 书签12\\usepackage[breaklinks,colorlinks,linkcolor=black,citecolor=black,urlcolor=black]{hyperref}\\tableofcontent 页眉显示章节名LaTeX 自定义宏包与文档类TeX 控制序列（Control Sequence）分为两种： 控制词：如 \\input 等，后面需要接非字母（数字不是字母。一般接空格，而且后面的所有空格会被忽略） 控制符号：如 \\' 等，后面无要求（比如接空格就会打印一个空格） TeX 控制序列约900个，还可以分为： 原始控制序列（大约300个）：不能再分解为低级控制序列 基本控制序列（大约600个） 可以用 \\show\\cs（cs 是任意控制序列）来打印控制序列的定义，看看控制序列是属于原始控制序列还是更高级的基本控制序列。 宏包括命令和环境两种。命令就是类似\\hspace{}、\\par这种，环境就是类似 123\\begin{equation} 1+1=2\\end{equation} Plain TeX 格式定义命令1234567%% 参数必选\\def&lt;命令及参数&gt;{&lt;定义&gt;} % 参数用#1、#2等表示，需要手动加括号，也可以不加括号。下同\\gdef&lt;命令及参数&gt;{&lt;定义&gt;} % 相当于\\global\\def\\edef&lt;命令及参数&gt;{&lt;定义&gt;} % 编译时会将命令完全展开\\xdef&lt;命令及参数&gt;{&lt;定义&gt;} % 相当于\\global\\edef\\let&lt;宏2&gt;=&lt;宏1&gt; % 定义一个新的宏（宏2）并将已有的宏1的定义赋值给它。赋值后二者无任何关联 例： 12345678910\\documentclass{article}\\def\\testsentence{Test sentence.}\\def\\Emph#1{\\textbf{#1}}\\begin{document} \\testsentence \\Emph{Big}\\end{document} 条件判断12345678910111213141516%% 条件判断\\if &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\fi % 比较两个字符是否相同\\if &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi % 下面同理\\ifx &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi % 比较两个变量是否相同\\ifnum &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi% 用来判断常整数或计数器（\\value{&lt;计数器&gt;}）\\ifdim &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi% 用来判断长度变量\\ifodd &lt;条件表达式&gt; &lt;条件为真时执行的内容&gt;\\else &lt;条件为假时执行的内容&gt;\\fi% 用来判断整数是否为奇数% 条件判断符号有“=”、“&gt;”和“&lt;”\\ifcase&lt;变量&gt; &lt;0的内容&gt; \\or&lt;1的内容&gt; \\or&lt;2的内容&gt; ... \\else&lt;其他数字的内容&gt;\\fi% 辅助命令\\relax % 什么都不做。可用作分隔符\\end % 结束符，同\\dump 变量如果时计数器的话要用 \\value{&lt;计数器&gt;} 的形式。 例子： 1234\\def\\first{abc}\\def\\second{abc}\\ifx\\first\\second OK!\\else false \\fi % ok\\if\\first\\second OK!\\else false \\fi % false \\newif定义布尔变量以实现 if-else 结构 12345678910111213\\newif&lt;变量&gt; % 定义一个布尔型变量，默认初始化为false。注意这个&lt;变量&gt;一定要以`\\if`开头% 或\\newif&lt;变量&gt; &lt;初始化值&gt;% 例：\\newif\\if@twocolumn% 等价于\\newif\\if@twocolumn \\@twocolumnfalse% 定义后就可以在不同地方用`\\@twoclumntrue`或`\\@twocolumnfalse`命令来给\\if@twocolumn赋值，而且可以用\\if@twocolumn \\relax % 真时执行\\else \\relax % 假时执行\\fi 在宏包或文档类中带有 @ 的命令（常见如 \\⟨pkg⟩@⟨cmd⟩ ）表示宏包或文档类的内部命令，@ 被当作字母来处理。但在 .tex 文件中需要用 \\catcode 命令将 @ 的类别码由 “其他” 转为 “字母” 才能使用或定义带有 @ 的命令，但不建议这么用。 计数器123456789% 计数器赋值\\count0=1% 计数器值+1\\advance\\count0 by 1% 显示计数器的值\\number\\count0\\the\\count0 注意：TeX 把当前的页码放在寄存器 \\count0 中，如果是局部定义和改变该值不会影响全局的页码，但是在全局中修改则需要注意。 (Xe)LaTeX 格式定义命令1234567\\newcommand{\\⟨name⟩}[⟨num⟩]{⟨definition⟩} % 定义新命令\\renewcommand{\\⟨name⟩}[⟨num⟩]{⟨definition⟩} % 如果命令已存在，则覆盖原定义\\providecommand{\\⟨name⟩}[⟨num⟩]{⟨definition⟩} % 如果命令已存在，则本定义无效\\newenvironment{⟨name⟩}[⟨num⟩]{⟨before⟩}{⟨after⟩} % 定义新环境\\rewenvironment{⟨name⟩}[⟨num⟩]{⟨before⟩}{⟨after⟩} % 如果环境已存在，则覆盖原定义\\provideenvironment{⟨name⟩}[⟨num⟩]{⟨before⟩}{⟨after⟩} % 如果环境已存在，则本定义无效 注意： 指定了默认值后的参数即为可选参数（最多一个，且为 #1）。 调用可选参数时用方括号；调用必选参数时用大括号。 条件判断一般使用 ifthen 或 xifthen 宏包 12\\ifthenelse{⟨test⟩}{⟨then clause⟩}{⟨else clause⟩}\\whiledo{}{} 详情见文档： 12texdoc ifthen # 见ifthen文档texdoc xifthen # 见xifthen文档 定义计数器12345678910111213141516\\newcounter{mycounter} % 创建计数器\\newcounter{quiz}[section] % 创建计数器并指定其父计数器\\stepcounter{mycounter} % 自增，并将所有下级计数器归零\\setcounter{mycounter}{0} % 给计数器赋值\\setcounter{mycounter}{\\value{mycounter2}}\\addtocounter{mycounter}{-2} % 给计数器的值增加一个数\\themycounter % 计数器输出\\arabic{mycounter} % 阿拉伯数字输出（默认），与上面\\themycounter等价\\alph{mycounter} % 小写字母输出\\Alph{mycounter} % 大写字母输出\\roman{mycounter} % 小写罗马数字输出\\Roman{mycounter} % 大写罗马数字输出\\fnsymbol{mycounter} % 用特殊符号（依次为 ∗ † ‡ § ¶ ‖ ∗∗ †† ‡‡）输出，fancy~ 定义与设置长度1234567\\newlength\\mylength\\setlength{\\mylength}{1cm}\\addtolength{\\mylength}{1cm + 1mm - 1pt}% 显示\\the\\mylength % 带单位\\number\\mylength % 只显示数字 模板宏包（.sty）模板1234567891011\\ProvidesPackage{⟨package name⟩}[⟨info⟩] % ⟨package name⟩ 需要和宏包的文件名一致。\\RequirePackage[⟨options⟩]{⟨package name⟩}[⟨date⟩] % 依赖的其他宏包\\DeclareOption{⟨option⟩}{⟨commands⟩} % 声明选项\\ProcessOptions % 使全部选项生效\\ExecuteOptions{⟨option list⟩} % 使部分选项生效\\AtEndOfPackage{⟨commands⟩} % 在宏包的结尾添加命令\\AtBeginDocument{⟨commands⟩} % 在document环境开头执行命令\\AtEndDocument{⟨commands⟩} % 在document环境末尾执行命令 ⟨info⟩ 指定宏包的信息，格式为 YYYY/MM/DD infomation。 ⟨date⟩ 指定要引入的宏包的最旧版本，格式为 YYYY/MM/DD。 文档类（.cls）模板1234567891011\\ProvidesClass{⟨class name⟩}[⟨info⟩] % {⟨class name⟩} 也需要和文档类的文件名一致\\LoadClass[⟨options⟩]{⟨package name⟩}[⟨date⟩] % 加载其他文档类\\DeclareOption{⟨option⟩}{⟨commands⟩} % 声明选项\\ProcessOptions % 使全部选项生效\\ExecuteOptions{⟨option list⟩} % 使部分选项生效\\AtEndOfClass{⟨commands⟩} % 在文档类的结尾添加命令\\AtBeginDocument{⟨commands⟩} % 在document环境开头执行命令\\AtEndDocument{⟨commands⟩} % 在document环境末尾执行命令 部分 LaTeX 命令的参数是所谓活动参数（moving argument），在活动参数中使用一些命令会造成错误，这称为脆弱命令（fragile command）。脆弱命令是指那些使用特殊展开方式的命令，所有带有可选参数的命令都是脆弱的。 可在脆弱命令前使用 \\protect，或用 LaTeX2e提供的 \\DeclareRobustCommand 命令来延迟命令的展开。 辅助宏包keyval123\\define@key{⟨选项族⟩}{⟨选项⟩}[⟨默认值⟩]{⟨代码⟩}% 在所定义的代码中用#1指代选项的值。\\setkeys{⟨选项族⟩}{⟨键值对⟩} 使用 自己编写的宏包或文档类使用起来就和其他宏包一样，通常可以把它与TX源文件放在同一目录编译。 对于单独由宏定义构成的宏包或文档类，只需要把文件放在TDS目录树的 /tex/latex/yourname/ 目录下，然后运行 texhash 命令刷新文件名数据库，即可安装到 TeX 发行版中。 Bug编译报错I can’t find file `”e:/….tex”‘.原因：项目路径有中文。 LaTeX Error: Environment CJKfilltwosides undefined.将项目中所有 CJKfntef 关键字都换成 xeCJKfntef 即可 插入图片的路径不能为中文，不能有空格。 Missing number, treated as zero.\\begin{minipage}后面没有加参数 Paragraph ended before \\Gin@ii was complete.\\includegraphics[width=\\textwidth]{{CR-02.png}多写了一个{。。。 无错误提示但无法编译通过编译时不能用PDF阅读器打开PDF，关掉再编译即可。 编译警告Text page 7 contains only floats.这是一个警告，意思是生成的PDF的第7页只有浮动体。 Font shape `U/rsfs/m/n’ in size &lt;15.05624&gt; not available (Font) size &lt;14.4&gt; substituted.mathrsfs 宏包（数学花体宏包）的 BUG：使用了未定义的字体大小 其他VSCode LaTeX 插件初始化错误：ltex-ls did not print expected version information to stdout.错误原因：之前通过新增注册表（HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Command Processor 下的 autorun，数值数据为 chcp 65001），将 cmd 控制台的字符集改为了 UTF-8 导致该错误。 解决方法：删除上述注册表。 参考 lshort-zh-cn-6.02 hitszthesis LaTeX入门-刘海洋 LaTeX2e完全学习手册-胡伟 The Texbook","link":"/2021/08/06/0144.html"},{"title":"Linux常用命令及相关问题","text":"Linux 常用命令准确地说应该是 Linux shell 常用命令 最常用的命令12345678910111213141516171819202122232425262728293031323334353637383940414243cd .. # 返回上一级目录cd # 返回根目录cd directory_name # 进入文件夹cd - # 返回上一次目录cd ~ # 普通用户进入 /home/&lt;user&gt; 文件夹，root 进入 /root 文件夹pwd # 显示当前目录ls # 显示当前文件夹下的文件和文件夹ls -a # 显示当前文件夹下的文件和文件夹，包括隐藏文件ls -l # 显示长信息，包括文件权限，修改时间等ls -i # 显示inode（物理索引）信息ls abc* # 列出以abc开头为文件名的所有文件rm # 删除mv # 移动cp # 拷贝mkdir directory_name # 创建文件夹mkdir -p dir1/dir2 # 递归创建文件夹touch filename # 创建文件./filename # 运行当前文件夹下的filename文件。如果不加“./”，则系统会到PATH宏下找文件？reboot # 重启su # 进入root模式（密码：root，也有可能初始没设置）exit # 如果是在root模式下，则会退出root；如果是普通用户模式下，则会退出系统sudo command_name #以root权限执行命令clear # 清屏reset # 应该是重启终端# 或者 ctrl+l 也可以清屏# ctrl+u 清除当前光标位置前面的输入apt installapt remove # 注意：慎用 apt-get autoremoveexport [-fnp][变量名称]=[变量设置值] # export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。env # 查看当前shell的所有环境变量whereis &lt;pkg_name&gt;which &lt;pkg_name&gt; # 可以用来查看命令实际运行的绝对路径lsof -i:ipv46_files # 查找网络文件的pidkill -9 pid # 杀死进程 管道常用命令 参考：https://www.jianshu.com/p/9c0c2b57cb73 顺序执行多条命令 1command1;command2;command3; 有条件的执行多条命令 1command1 &amp;&amp; command2 || command3 &amp;&amp;：如果前一条命令执行成功则执行下一条命令||：与&amp;&amp;命令相反，执行不成功时执行这个命令 $?：存储上一次命令的返回结果 12$ which git &gt; /dev/null &amp;&amp; git --help // 如果存在git命令，执行git --help命令$ echo $? 管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式将前面每一个进程的正确输出（stdout）直接作为下一个进程的输入（stdin）。 eg： 12ls -l /etc | more # 分页打印 /etc 下的文件，按q退出netstat -an | grep &quot;ESTABLISHED&quot; # 查看当前建立连接的用户 选取命令cut123456cut -d '分隔字符' -f field // 用于分隔字符cut -c 字符范围[参数说明]-d : 后面接分隔字符,通常与 -f 一起使用-f : 根据-d 将信息分隔成数段，-f 后接数字 表示取出第几段-c : 以字符为单位取出固定字符区间的信息 grep功能：按行过滤 123456789101112131415grep [OPTION]... PATTERNS [FILE]...[OPTION]-a ：将binary文件以text文件的方式查找数据-w ：全字匹配-v ：反向搜索-l ：只打印含有关键词的文件的名称-L ：只打印不含有关键词的文件的名称-n ：显示行数-c ：统计多少行-A ：列出后面的邻行-B ：列出前面的邻行-C ：列出前后的邻行-E ：扩展正则表达式-e ：正则表达式 eg： 12345678910111213grep -i 'hello world' menu.h main.c # 查找，忽略大小写grep '^leo' /etc/passwd # 搜索 /etc/passwd 文件中开头是 leo 的行grep 'bash$' /etc/passwd # 搜索 /etc/passwd 文件中行尾是 bash 的行grep -E '^root|bash$' passwd # 多条件查找：passwd中以root开头或以bash结尾的行grep -l '123' *.[ch] # 在当前目录下的所有 .c 或 .h 文件中找指定字符串，若找到则其打印文件名cat /etc/dnsmasq.conf | grep -e '^[^#]' # 寻找文件的非注释行find . -name ’*.[ch]’ | xargs grep -l thingfind . -name ’*.[ch]’ -print0 | xargs -r -0 grep -l thing # 比上面更加安全的写法grep -l sprintf ‘find $HOME -name ’*.c’ -print‘ # 等价于下面的命令。find $HOME -name ’*.c’ -print | xargs grep -l sprintf # 寻找含有sprintf的.c文件 排序：sort1234567891011sort [OPTION]... [FILE]...[OPTION]-f ：忽略大小写的差异，例如A 与a 视为编码相同-b ：忽略最前面的空格部分-M ：以月份的名字来排序，例如JAN, DEC 等等的排序方法-n ：使用『纯数字』进行排序默认是以文字型态来排序的)-r ：反向排序-u ：过滤掉相同的行，类似uniq，但不相邻的也会过滤-t ：分隔符号，预设是用[tab] 键来分隔-k ：以那个区间(field) 来进行排序的意思 计数：wc功能：word count 计数 123456789wc [OPTION]... [FILE]...[OPTION]-l ：仅打印行数 newline-w ：仅打印词数 word-m ：仅打印字符数 character-L ：仅打印最大行长度-c ：仅打印字节数 eg： 1234567wc file.txt # 依次打印file.txt文件的newline, word, character数目wc file1.txt file2.txt # 分别依次打印file1.txt和file2.txt文件和总计的newline, word, character数目wc -l file.txt # 打印file.txt的行数# 结合管道ls | wc -l # 打印当前目录文件和目录总数ls -l | grep '^d' | wc -l # 打印当前目录下的目录总数ls -l | grep '^-' | wc -l # 打印当前目录下的文件总数 过滤紧邻重复行：uniq记忆：unique 功能：过滤紧邻重复行，没有真的删除 12345uniq [OPTION]... [INPUT [OUTPUT]][OPTION]-i ：忽略大小写的不同-c ：进行计数 eg： 123uniq file.txt # 过滤 file.txt 中的紧邻重复行uniq -c file.txt # 过滤 file.txt 中的紧邻重复行并计数touch file2.txt &amp;&amp; uniq file.txt &gt; file2.txt # 保存 file.txt 中删除紧邻重复行后的结果到 file2.txt 双向重定向命令：tee 123tee [-a] file[参数]-a : 以累加的方式，将数据加入file中 字符转换命令tr1234tr [-ds] set[参数]-d : 删除信息当中的set1这个字符串-s : 替换掉重复的字符 col1234col [-xb][参数]-x ： 将tab键换成对等的空格键-b : 在文字内有反斜杠(/)时，仅保留反斜杠最后接的那个字符 join123456join [-ti12] file1 file2 [参数]` -t : join 默认以空格符分隔数据，并且对比第一个字段的数据 ,如果两个文件相同，则将两条数据连成一行 -i : 忽略大小写的差异 -1 : 说明第一个文件通过那个字段来进行分析 -2 : 说明第二个文件通过那个字段来分析 paste1234paste [-d] file1 file2[ 参数]-d : 后面可以接分隔字符，默认以[tab]来分隔的- : 如果file部分写成-，表示接受standard input数据的意思 expand123expand [-t] file[参数]-t : 后面接数字，一般，一个tab可以用8个空格代替，可以自行定义代表几个空格 切割命令split12345split [-bl] file prefix [参数] -b : 后面可接欲切割文件的大小，可加单位，例如b,k,m等 -l : 以行数来进行切割 PREFIX : 代表前导符，可作为切割文件的前导文字 Vim 相关命令 vim是vi的升级版 命令行输入 vimtutor 就可以看到教程 基本操作 vim的三种模式 命令模式 其他模式下按Esc键可进入命令模式 输入模式 命令模式下按i或a或o可进入 “i”命令可以在当前光标之前插入文本。“a”命令可以在当前光标之后插入文本。（实测也是光标之前）“o”命令可以在当前行的下面另起一行，并使当前模式转为Insert模式。“O”命令(注意是大写的字母O)将在当前行的上面另起一行。 输入模式下，按Insert键可以选择插入模式（INSERT）还是替换模式（REPLACE） 底线命令模式 命令模式下输入:可进入，按回车结束运行 命令模式命令选择与跳转 命令 作用 gg 跳到文首 V 选择（Visual Line模式） G 跳到文尾（Ground） ggVG 全选 Visual Line下选择文本后，可执行以下命令： 命令 作用 d 删除 y 复制到&quot;剪切板 p 粘贴&quot;剪切板中的内容 “+y 复制到系统剪贴板(也就是vim的+寄存器） “+p 从系统剪贴板粘贴 删除 命令 作用 x 删除一个字符 dd 删除光标当前行 撤销与重做 命令 作用 u 撤销上一步操作 U 一次撤消对最后一次编辑的一行的全部操作。第二次使用该命令则会撤消前一个”U”的操作。 ctrl+r 重做（撤销撤销操作） 底线命令模式命令常用12345:wq! # 强制保存并退出:/keyword # 从上往下查找，按“n”跳到下一个，“*”和“.”可以模糊匹配:?keyword # 从下往上查找，按“n”跳到下一个:set nu # 显示行数（nu=number）:23 # 跳到第23行 编码与格式1234:set ff # 查看文件格式（fileformat）:set ff=unix # 设置文件格式为unix。解决文件无法执行问题。:set fileencoding # 查看文件编码:set fileencoding=utf-8 # 设置文件编码为utf-8。解决文件乱码问题。 输入模式命令暂无。 网络相关命令123456789101112writewallpingifconfigmaillast # 查看用户登录信息lastlogtraceroutenetstat # 显示网络相关信息netstat -rn # 查看路由列表，可以看到网关service network restart # 重启网络mount # 挂载（一般挂载在/mnt的某个子目录下） 相关文件123456789/etc/resolv.conf # 临时修改DNS/etc/systemd/resolved.conf # 一般是一个指向上面的软连接。永久修改DNS/etc/network/interface # 网络配置文件/etc/hosts # hosts 列表/etc/netplan/*.yaml # ubuntu用netplan配置网络# netplan try # 应用前先验证# netplan apply # 应用配置 测试123ping &lt;$IP|$DOMAIN&gt; # 注意ping使用的协议是ICMP，不是TCP或UDPftp &lt;$IP|$DOMAIN&gt;wget &lt;$IP|$DOMAIN&gt; 重启1234service network-manager restart # Ubuntuservice networking restart # Debiansystemctl restart systemd-resolved.servicesystemctl restart NetworkManager.service 查看状态12systemd-resolve --status # 会报错systemctl status systemd-resolved.service 其他命令1ps -ef | grep process_name # 列出系统中当前运行的名字包含process_name的进程 12uname -a # unix name：显示电脑以及操作系统的相关信息，或者uname -r # 查看linux内核版本 1chmod -R 777 file_foder_name # 修改文件或文件夹的权限 1man command_name # 查看命令的帮助文件 12echo $PATH # 查看环境变量PATHenv # 查看环境变量 scp 命令功能：跨服务器加密传文件 1234567# 在windows系统的cmd中# win -&gt; linuxscp -r E:\\file_foder_name debian@192.168.137.2:/home/AA/BB # 跨服务器加密复制文件夹scp E:\\AA\\BB\\filename debian@192.168.137.2:/home/AA/BB # 跨服务器加密复制文件# (win请求)linux -&gt; winscp -r debian@192.168.137.2:/home/AA/BB E:\\file_foder_name # 跨服务器加密复制文件夹scp debian@192.168.137.2:/home/AA/BB E:\\AA\\BB\\filename # 跨服务器加密复制文件 ln 命令12ln filename filename_lnk # 建立硬链接（Hard Link）ln -s filename filename_lnk # 建立软连接（Symbolic Link，符号链接） 软硬链接的区别：https://blog.csdn.net/yagamil/article/details/40076509 find 命令看手册 1find &lt;路径&gt; -name &quot;filename*&quot; -size +100k -print 123-iname # 忽略大小写-mindepth-maxdepth xargs 命令和find命令配合使用，见find手册 tar 命令tar.gz压缩： 1tar -zcvf 压缩文件名.tar.gz 被压缩文件名 解压缩： 1tar -zxvf 压缩文件名.tar.gz -C 解压路径（不含文件名） 各参数含义： -z：有gzip属性的 -x：解压 -v：显示所有过程 -f：使用档案名字（放最后） 参考：https://www.cnblogs.com/manong--/p/8012324.html tar解压： 1tar -xvf file.tar systemctl1234567891011121314151617181920212223242526272829systemctl list-units ##列出当前系统服务的状态systemctl list-unit-files ##列出服务的开机状态systemctl status sshd ##查看指定服务的状态systemctl stop sshd ##关闭指定服务systemctl start sshd ##开启指定服务systemctl restart sshd ##从新启动服务systemctl enable sshd ##设定指定服务开机开启systemctl disable sshd ##设定指定服务开机关闭systemctl reload sshd ##使指定服务从新加载配置systemctl list-dependencies sshd ##查看指定服务的倚赖关系systemctl mask sshd ##冻结指定服务systemctl unmask sshd ##启用服务systemctl set-default multi-user.target ##开机不开启图形systemctl set-default graphical.target ##开机启动图形setterm ##文本界面设定color 常用软件包及命令tree1tree # 显示目录树 shawdowsocks123sslocal -c /home/burgess/shadowsocks.conf -d start # 开启梯子sslocal -c /home/burgess/shadowsocks.conf -d stop # 关闭梯子sslocal -s server.com -p 8388 -k password # 添加或修改参数 注意中间替换成配置文件的路径（burgess是用户名） 一次性配置命令1sudo cp .bashrc /root/.bashrc # 在普通用户模式下使用。会使root模式下也有配色。 1sudo passwd # 修改root密码，要先输入当前用户登录密码 Linux 常用快捷键1234567891011ctrl+a ： 光标移动到命令行开头ctrl+e ： 光标移动到命令行结尾ctrl+c ： 强制终止当前命令ctrl+l ： 剪切光标之前的内容ctrl+k ： 剪切光标之后的内容ctrl+y ： 粘贴ctrl+l或ctrl+k剪切的内容ctrl+r ： 搜索历史命令ctrl+d ： 关闭当前终端ctrl+z ： 暂停并放入后台ctrl+s ： 暂停屏幕输出ctrl+q ： 恢复屏幕输出 Linux 通配符和其他特殊符号通配符123456789？ ：匹配一个任意字符* ：匹配零个或多个任意字符[] ：匹配中括号内的任意一个字符[-] ：匹配范围内的任意一个字符[^] ：匹配后取反 特殊符号1234567'' ：原封不动输出&quot;&quot; ：$、`和\\有特殊含义`` ：``中是系统命令。bash会先执行其中的命令$() ：与``一样，不容易看错# ：注释$ ：调用变量的值。或${}\\ ：转义符。取消特殊符号的特殊含义 Linux 正则表达式 正则表达式 不等于 通配符（wildcard） 正则表达式分基础的正则表达式（BRE，Basic Regexp）和扩展的正则表达式（ERE，Extended Regexp） 转义符\\能将正则表达式字符变成普通字符 12345678910* 前一个字符匹配0次或任意多次.. 匹配除了换行符外任意一个字符.^ 匹配行首. 例如：^hello 会匹配以 hello 开头的行.$ 匹配行尾. 例如：hello$ 会匹配以 hello 结尾的行.[] 匹配中括号中指定的任意一个字符，制匹配一个字符. 例如：[aoeiu] 匹配任意一个元音字母，[0-9] 匹配任意一位数字，[a-z][0-9]匹配小写字和一位数字构成的两位字符.[^] 匹配除中括号的字符以外的任意一个字符. 例如：[^0-9] 匹配任意一位非数字字符，[^a-z] 表示任意一位非小写字母.\\ 转义符. 用于取消特殊符号的含义.\\{n\\} 表示其前面的字符恰好出现 n 次. 例如：[0-9]\\{4\\} 匹配 4 位数字，[1][3-8][0-9]\\{9\\} 匹配手机号码.\\{n,\\} 表示其前面的字符出现不小于 n 次. 例如：[0-9]\\{2,\\}表示两位及以上的数字.\\{n,m\\} 表示其前面的字符至少出现 n 次，最多出现 m 次. 例如：[a-z]\\{6,8\\} 匹配6到8位的小写字母. Linux 输入输出重定向 设备 设备文件名 文件描述符 类型 键盘 /dev/stdin 0 标准输入 显示器 /dev/stdout 1 标准输出 显示器 /dev/stderr 2 标准错误输出 输出重定向标准输出重定向 命令 &gt; 文件 ：以覆盖的方式写入命令的正确输出 命令 &gt;&gt; 文件 ：以追加的方式写入命令的正确输出 标准错误输出重定向 错误命令 2&gt; 文件 ：以覆盖的方式写入命令的错误输出 错误命令 2&gt;&gt; 文件 ：以追加的方式写入命令的错误输出 将正确输出和错误输出都保存在同一个文件中 1234命令 &gt; 文件 2&gt;&amp;1命令 &gt;&gt; 文件 2&gt;&amp;1命令 &amp;&gt; 文件命令 &amp;&gt;&gt; 文件 将正确输出和错误输出分开保存 12命令 &gt; 文件1 2&gt; 文件2命令 &gt;&gt; 文件1 2&gt;&gt; 文件2 不输出 1命令 &amp;&gt; /dev/null 输入重定向eg： 123wc # 键盘输入，统计行数等。按 ctrl+d 结束输入wc -l &lt; hello.txt # 统计 hello.txt 文件的行数wc &lt;&lt; hello # 用得很少，将键盘输入给wc命令，以hello为输入结束符 多命令顺序执行与管道符; &amp;&amp; || dd 命令 1dd if=infile of=outfile bs=bytes count=bytesnum 1命令 &amp;&amp; echo yes || echo no shell 变量变量不能以数字开头 bash中变量类型默认为字符串 变量的值有空格，需要用单引号或双引号括起来 变量分类 用户自定义变量 环境变量 位置参数变量：向脚本当中传递参数或数据的，变量名不能自定义，变量的作用固定 预定义变量：Bash中定义好的变量，变量名不能自定义，变量的作用固定 123echo $varname # 变量调用set # 查看所有变量unset varname # 删除变量 Linux Shell 脚本简介硬件-内核-shell-应用程序 分类： Bourne shell 系列：sh、ksh、bash、psh、zsh C shell 系列：csh、tcsh 1cat /etc/shells # 查看支持的shell shell 脚本文件头： 1#！/bin/bash 执行方法： 1234chmod 755 hello.sh./hello.sh# 或者bash hello.sh # 不需要执行权限就能执行 echo命令 123echo -e &quot;\\e[1;31mabcd\\e[0m&quot; # 红色输出abcd# 30m=黑色，31m=红色，32m=绿色，33m=黄色# 34m=蓝色，35m=洋红，36m=青色，37m=白色 注意 Linux 中的 shell 脚本回车符默认为 $，而 Windows 中默认为 ^M$ 1cat -A hello.sh # 打印文件内容，包括隐藏符号 转换文件可用 dos2unix 或 unix2dos 软件 12dos2unix hello.shunix2dos hello.sh 更多内容见 shell 脚本命令学习 Linux 相关问题git clone 下载的文件夹无法移动git clone之前忘记cd到合适的位置了，于是clone完之后想通过mv命令将文件夹移到它的上一级目录，但提示Permission denied，于是root模式下加了777权限，也不行，不知道为什么，最后删了重新下载。 更换软件源12sudo cp /etc/apt/sources.list /etc/apt/sources.list.backupvim /etc/apt/sources.list 然后将原有内容注释掉或删掉，再粘贴新的源即可。清华的debian镜像源如下 123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free# deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free 手机 USB 共享网络手机网络设置通过USB共享网络。 12ifconfig # 或 ip a 查看手机usb网卡名称，假设为usb0sudo dhclient usb0 git clone 速度太慢方法有以下几种： 若是 https，则在 github.com 后面加 .cnpmjs.org。 把 https 换成 git 永久配置 DNS永久停止Ubuntu默认dns本地服务 12sudo systemctl disable --now systemd-resolvedvim /etc/NetworkManager/NetworkManager.conf 修改NetworkManager：在[main]节点下增加如下配置： 1dns=none # none 不会生成dns配置到/etc/resolve.conf，default 则会生成 设置default，否则每次重启会被系统自动重置/etc/resolve.conf为nameserver 127.0.0.53 重启NetworkManager： 1sudo systemctl restart NetworkManager 如果不行，删除 /etc/resolv.conf 文件（红色，符号链接到的源文件不存在），然后再重启网络，resolv.conf 文件会自动生成 Ubuntu20.04 中文输入法目标：想在不改变系统语言（英文）的情况下安装系统自带的中文输入法。 安装语言支持 Settings &gt; Region &amp; Language &gt; Manage Installed Languages &gt; Install / Remove Languages &gt; Chinese (Simplified) &gt; Apply ，将 Chinese (Simplified) 拖到 English 上方使其不变灰。然后Keyboard input method system &gt; IBus &gt; Close。 注意：添加完简体中文后，键盘布局中才能找到 Chinese (Intelligent Pinyin)。 添加键盘布局（输入方法） Settings &gt; Region &amp; Language &gt; Input Sources &gt; + &gt; Chinese &gt; Chinese (Intelligent Pinyin) &gt; Add。 设置系统语言（即终端、桌面和其他软件的语言） Settings &gt; Region &amp; Language &gt; Language &gt; English（随便哪一个都可以）。 重启。 平时切换输入法快捷方式为 Win + 空格。","link":"/2021/02/27/2346.html"},{"title":"Python学习笔记","text":"vscode Python环境配置 参考：你学Python 虚拟环境 看这一篇就够了 - 知乎 (zhihu.com) 安装Python 下载网址：Download Python | Python.org 注意：不要更改默认的安装路径（C:\\Users\\wbx\\AppData\\Local\\Programs\\Python）！！！否则环境配置很麻烦！！！因为在 Program Files 目录程序没有权限，所以要安装第三方库的时候因为没有权限而会自动安装到默认路径下，导致包在两个文件夹。 安装Python扩展插件 在vscode扩展中搜索python进行安装 创建虚拟环境 在 python3.3 之前，只能通过 virtualenv 创建虚拟环境，首先需要安装 virtualenv 123pip install virtualenv# 或python -m pip install virtualenv 安装完后，在当前目录下创建一个名为 myvenv 的虚拟环境: 1virtualenv --no-site-packages myvenv 参数 --no-site-packages 的意思是创建虚拟环境时，不复制主环境中安装的第三方包，也就是创建一个 “干净的” 虚拟环境 virtualenv 还有很多参数，用于不同的使用场景，例如: -p: 用于指定 Python 解析器，就是安装好的 Python 应用程序，默认为当前环境中的 Python –no-pip：不需要安装 pip，默认为安装 –clear：如果创建虚拟环境的目录已经有了其他虚拟环境，清楚重建 Python3.3 之后，可以用模块 venv 代替 virtualenv 工具，好处是不用单独安装，3.3 及之后的版本，都可以通过安装好的 Python 来创建虚拟环境: 1python -m venv myvenv 可以在当前目录创建一个名为 myvenv 的虚拟环境 venv 有些参数，不过相比 virtualenv 少了些，这里简单介绍几个： –without-pip: 不需要安装 pip，默认为安装 –clear：如果创建虚拟环境的目录已经有了其他虚拟环境，清楚重建 因为 venv 是依附于一个 Python 解析器创建的（见 myvenv/pyvenv.cfg 文件），所以安装时不需要用 -p 指定 Python 解释器版本 注意：使用之前创建好的虚拟环境前，要查看 myvenv/pyvenv.cfg 文件，看解释器的版本是否一致，路径是否一致。若解释器版本不一致或者路径发生变化，则建议重装虚拟环境。 激活虚拟环境 在 Windows 下，用 PowerShell 运行 myenv\\Scripts 下的 Activate.ps1 即可（或者直接运行 activate 文件）： 1.\\myenv\\Scripts\\Activate.ps1 若出现“无法加载文件 ..\\myvenv\\Scripts\\Activate.ps1，因为在此系统上禁止运行脚本”的错误，则需要先在PowerShell中运行Set-ExecutionPolicy RemoteSigned。 一些 Pythonic 技巧lambda 函数123456func = lambda a,b:1/(1+25*a*b)nodes_x = [-1+2*i/n for i in range(n)] # 节点，不含最后一个点1nodes_y = list(map(func,nodes_x,nodes_x)) # 节点处的函数值# 或直接像函数一样用（匿名函数）result = func(nodes_x, nodes_x) https://www.geeksforgeeks.org/python-lambda/ 123456789101112131415161718# Python program to demonstrate# lambda functions inside map()# and filter() a = [100, 2, 8, 60, 5, 4, 3, 31, 10, 11] # in filter either we use assignment or # conditional operator, the pass actual # parameter will get returnfiltered = filter (lambda x: x % 2 == 0, a) print(list(filtered)) # in map either we use assignment or# conditional operator, the result of # the value will get returnedmaped = map (lambda x: x % 2 == 0, a) print(list(maped)) 字符串的 format 方法12345678910111213141516# 传入多个变量a = 1print(&quot;{0}abc{1}{2}&quot;.format('string', a, a+1))# 传入变量名print(f&quot;a={a}&quot;)# 传入listlist1 = ['jack', 'pig']string1 = &quot;\\'s nick name is &quot;print(&quot;name：{0[0]}, nick: {0[1]}&quot;.format(list1))print(&quot;name：{0}, nick: {1}&quot;.format(*list1))print('{1}{0}{2}.'.format(string1, *list1))# 传入dictdict1 = {'name': 'jack', 'nick': 'pig'}print(&quot;{name}\\'s nick name is {nick}.&quot;.format(**dict1)) 《Python编程：从入门到实践》笔记数据类型字符串12345678910111213string = &quot; my name &quot;string.title() # 每个单词的首字母大写（临时）string.upper() # 全部大写（临时）string.lower() # 全部小写（临时）string.rstrip() # 删除右侧的空格（临时）string.lstrip() # 删除左侧的空格（临时）string.strip() # 删除两侧的空格（临时）string.split(' ') # 用空格分割成列表string.replace('my', 'your') # 字符串替换str(123) # 数字转字符串 列表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 构造list1 = ['a', 'b', 'c', 123]list2 = list(range(0,10,2)) # Python2中不需要加list# 如果想得到小数数列的话可以用numpy中的arange函数，自带的range函数只能得到整数类型的序列（注意当需要小数序列时用该函数会报错）。list1.append('e') # 增加一个元素（永久）list1.extend([3,4]) # 列表拼接（注意：会改变list1，返回值为None）list1.insert(0, 'v') # 在索引0处插入元素（其他元素右移）（永久）popped = list1.pop() # 弹出列表的最后一个元素（原列表中的元素会被删除）（永久）popped = list1.pop(1) # 弹出列表的第二个元素list1.remove('b') # 删除指定元素（只删除出现的第一个）（永久）list1.sort() # 按字母顺序排序（永久。仅支持字符串！）list1.sort(reverse=True) # 按字母逆序排序（永久）list1.sorted() # 按字母顺序排序（临时）list1.sorted(reverse=True) # 按字母逆序排序（临时）list1.reverse() # 反转列表排列顺序（永久）# 列表操作list1 = ['a', 'b', 'c', 123]print(list1[0]) # 返回第一个元素print(list1[-1]) # 返回最后一个元素print(list1[:3]) # 返回前四个元素所构成的列表print(list1[1:]) # 返回第二个到最后一个元素所构成的列表print(list1[-3:]) # 返回最后三个元素所构成的列表print(list1[:]) # 返回原列表副本list2 = list1 # list2和list1指向同一个列表list1 = list1 + list2 # 列表拼接list1[0] = 'A' # 将第一个元素修改为Adel list1[3] # 删除元素len(list1) # 列表长度min(numbers)max(numbers)sum(numbers)# 遍历列表：for语句for list1_ in list1: # 执行完后list_的值为list1[-1] passfor value in range(1,5): print(value) # 打印数字1~4numbers = [value**2 for value in range(1,5)] # 用“列表解析”法生成数字列表[1,4,9,16]numbers = list(range(1,5)) # 生成数字列表[1,2,3,4]numbers = list(range(1,5,2)) # 生成数字列表[1,3]，2为步长if 'a' in list1: # 判断元素'a'是否在列表中 passif list1: # 检查列表是否为空 print(&quot;list1 is not None.&quot;)# 与字符串相关的操作&quot;,&quot;.join(list1) # 连接列表 元组123# 元组# 元组和列表的操作类似# 元组元素不可修改，但元组变量可以重新赋值 字典12345678910111213141516171819202122232425rec1 = {'x': 20, 'y': 10}print(rec1.items()) # dict_items([('x', 20), ('y', 10)])print(rec1.keys()) # dict_keys(['x', 'y'])print(rec1.values()) # dict_values([20, 10])# 字典# 特点：动态、无顺序alien_0 = {'color': 'green', 'points': 5}print(alien_0['color'])alien_0['color'] = 'blue' # 修改字典中的值alien_0['x'] = 0 # 添加键值对del alien_0['points'] # 删除键值对（永久）# 遍历字典for key, value in alien_0.items(): # 遍历字典的键值对 print(&quot;key: &quot; + key) print(&quot;value: &quot; + value)for key in alien_0.keys(): # 遍历字典的键名 print(key)for key in sorted(alien_0.keys()): # 用sorted函数对键进行临时排序 print(key)for value in alien_0.values(): # 遍历字典的键值 print(value)for value in set(alien_0.values()): # 转换为集合（集合没有重复） print(value) 逻辑结构if 语句123456789101112131415# if语句# 多条件——且：用`and`连接；或：用`or`连接；可用小括号定义执行顺序# 真：True；假：Falseage = '23'if age == '23': print(&quot;age == '23'&quot;)if '3' in age: print(&quot;'3' in age&quot;)if '3' not in age: print(&quot;'3' not in age&quot;)elif '2' not in age: print(&quot;'2' not in age&quot;)else: pass while 语句函数12345def greet_user(username): &quot;&quot;&quot;显示简单的问候语（docstring）&quot;&quot;&quot; print(&quot;Hello, &quot; + username.title() + &quot;!&quot;) greet_user('jesse') 使用任意数量的实参123456789def make_pizza(size, *toppings): &quot;&quot;&quot;概述要制作的比萨&quot;&quot;&quot; print(&quot;\\nMaking a &quot; + str(size) + &quot;-inch pizza with the following toppings:&quot;) for topping in toppings: print(&quot;- &quot; + topping) make_pizza(16, 'pepperoni') make_pizza(12, 'mushrooms', 'green peppers', 'extra cheese') 使用任意数量的关键字实参12345678910111213def build_profile(first, last, **user_info): &quot;&quot;&quot;创建一个字典，其中包含我们知道的有关用户的一切&quot;&quot;&quot; profile = {} profile['first_name'] = first profile['last_name'] = last for key, value in user_info.items(): profile[key] = value return profile user_profile = build_profile('albert', 'einstein', location='princeton', field='physics') print(user_profile) 异常处理12345678910try: print(5/0) except ZeroDivisionError: print(&quot;You can't divide by zero!&quot;)except Exception as e: print('Unexpected Exception')else: # 依赖于try代码块成功执行的代码finally: # 最后执行 技巧（来源：Python中的异常处理 - 知乎 (zhihu.com)）： 一个 except 子句可以同时处理多个异常，多个异常名称放在一个元组中 通常会在 except 子句的最后加上一个不带异常名称的 except 子句或异常名称为 Exception 的 except 子句，此时可捕获所有的异常，避免程序意外终止 通常会将捕获到的异常赋值给某个变量，然后通过该变量获取异常的信息，例如 except 异常名称 as 变量 自定义异常（来源：菜鸟教程） 12345678class Networkerror(RuntimeError): def __init__(self, arg): self.args = argtry: raise Networkerror(&quot;Bad hostname&quot;)except Networkerror,e: print e.args 抛出异常1raise ValueError('值错误') Python 之禅12# 体会一下Python之禅&gt;&gt;&gt; import this 代码格式Python改进提案（Python Enhancement Proposal， PEP） 每级缩进都使用四个空格（可将输入的制表符转换为指定数量的空格） 每行不超过80字符，注释的行长都不超过72字符（可添加字符提示线） 要将程序的不同部分分开，可使用空行 12if _name__ == &quot;__main__&quot;: pass W3C School: Python 基础语法 笔记 参考：https://www.w3cschool.cn/python3/python3-tutorial.html 编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 当然你也可以为源码文件指定不同的编码： 1# -*- coding: cp-1252 -*- 标识符 第一个字符必须是字母表中字母或下划线’_’。 标识符的其他的部分有字母、数字和下划线组成。 标识符对大小写敏感。 在 Python 3中，非 -ASCII 编码的标识符也是允许的了。 Python 保留字保留字即关键字，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword module，可以输出当前版本的所有保留字： 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释Python 中单行注释以 # 开头，多行注释采用三对单引号（’’’）或者三对双引号（”””）将注释括起来。 缩进Python 最具特色的就是使用缩进来表示代码块。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。 标准数据类型Python 中有六个标准的数据类型： Number（数字） String（字符串） List（列表） Tuple（元组） Set（集合） Dictionary（字典） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 字符串 Python 中单引号和双引号使用完全相同。 使用三对引号(‘’’或”””)可以囊括一个多行字符串。 转义符 ‘' 自然字符串， 通过在字符串前加 r 或 R。 如 r”this is a line with \\n” 则\\n会显示，并不是换行。 Python 允许处理 unicode 字符串，加前缀 u 或 U， 如 u”this is an unicode string”。 字符串是不可变的。 按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量 [头下标: 尾下标: 步长] 1234word = '字符串'sentence = &quot;这是一个句子。&quot;paragraph = &quot;&quot;&quot;这是一个段落，可以由多行组成&quot;&quot;&quot; 实例： 1234567891011121314151617#!/usr/bin/python3 str='Runoob' print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始后的所有字符print(str[1:5:2]) # 输出从第二个开始到第五个且每隔两个的字符print(str * 2) # 输出字符串两次print(str + '你好') # 连接字符串 print('------------------------------') print('hello\\nrunoob') # 使用反斜杠(\\)+n转义特殊字符print(r'hello\\nrunoob') # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 这里的 r 指 raw，即 raw string，会自动将反斜杠转义，例如： 1234&gt;&gt;&gt; print('\\n') # 输出空行&gt;&gt;&gt; print(r'\\n') # 输出 \\n&gt;&gt;&gt;\\n 以上实例输出结果： 123456789101112RunoobRunooRnoonoobuoRunoobRunoobRunoob你好------------------------------hellorunoobhello\\nrunoob 空行函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。 空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。 记住：空行也是程序代码的一部分。 等待用户输入执行下面的程序在按回车键后就会等待用户输入： 实例: 123#!/usr/bin/python3 input(&quot;\\n\\n按下 enter 键后退出。&quot;) 以上代码中 ，”\\n\\n”在结果输出前会输出两个新的空行。一旦用户按下 enter 键时，程序将退出。 同一行显示多条语句Python 可以在同一行中使用多条语句，语句之间使用分号 (;) 分割，以下是一个简单的实例： 实例: 123#!/usr/bin/python3 import sys; x = 'runoob'; sys.stdout.write(x + '\\n') 使用脚本执行以上代码，输出结果为： 1runoob 使用交互式命令行执行，输出结果为： 123&gt;&gt;&gt; import sys; x = 'runoob'; sys.stdout.write(x + '\\n')runoob7 此处的 7 表示字符数。 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之代码组。 像 if、while、def 和 class 这样的复合语句，首行以关键字开始，以冒号 ( : ) 结束，该行之后的一行或多行代码构成代码组。 我们将首行及后面的代码组称为一个子句 (clause)。 如下实例： 123456if expression : suiteelif expression : suite else : suite print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=””： 实例: 12345678910111213#!/usr/bin/python3 x=&quot;a&quot;y=&quot;b&quot;# 换行输出print( x )print( y ) print('---------')# 不换行输出print( x, end=&quot; &quot; )print( y, end=&quot; &quot; )print() 以上实例执行结果为： 1234ab---------a b import 与 from…import在 Python 用 import 或者 from…import 来导入相应的模块。 将整个模块 (somemodule) 导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 导入 sys 模块123456import sysprint('================Python import mode==========================')print ('命令行参数为:')for i in sys.argv: print (i)print ('\\n python 路径为',sys.path) 导入 sys 模块的 argv, path 成员argv 是传入的参数，path 是程序运行的路径 1234from sys import argv,path # 导入特定的成员 print('================python from import===================================')print('path:', path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 命令行参数很多程序可以执行一些操作来查看一些基本信息，Python 可以使用 -h 参数查看各参数帮助信息： 123456789$ python -husage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...Options and arguments (and corresponding environment variables):-c cmd : program passed in as string (terminates option list)-d : debug output from parser (also PYTHONDEBUG=x)-E : ignore environment variables (such as PYTHONPATH)-h : print this help message and exit[ etc. ] 文件/文件夹操作读取文件有以下三种方式 Note：VScode 最好在 powershell 终端中运行 python 程序，不要在 cmd 中运行，否则不能输入且中文会乱码 1234567891011121314151617filename = 'testfile.txt'# 打印整个文件with open(filename, encoding='utf-8') as file_obj: print(file_obj.read())# 逐行读取文件并打印with open(filename, encoding='utf-8') as file_obj: for line in file_obj: print(line.rstrip())# 按行创建列表，然后打印with open(filename, encoding='utf-8') as file_obj: lines = file_obj.readlines()for line in lines: print(line.rstrip()) 其中，rstrip()函数是删除字符串右边的字符，默认为空格（实测发现会将换行符也删掉）。类似的函数还有lstrip()和strip()，分别是删除左侧的字符和两侧的字符。 写入文件12345678910111213filename = 'programming.txt'with open(filename, 'w') as file_obj: file_obj.write( &quot;I love programming,\\n&quot; &quot;and I love python,\\n&quot; &quot;which is great.&quot; )# 或者with open(filename, 'w') as file_obj: file_obj.write(&quot;I love programming,\\n&quot;) file_obj.write(&quot;and I love python,\\n&quot;) file_obj.write(&quot;which is great.&quot;) 打开文件的模式（默认只读）： 读取模式：r 写入模式：w（文件已存在时会在返回文件对象前清空文件） 附加模式：a 读取和写入模式：r+ 注意：在 r+ 模式下，若打算先写入文件，再读取文件，则在读取文件之前，要先用 file_obj.seek(0) 将指针回复到文件开头。 以二进制方式写入文件： rb：以字节(二进制)方式读取文件中的数据 wb: 以字节(二进制)方式往文件中写入数据 ab: 以字节(二进制)方式往文件末尾追加写入数据 文件操作12os.remove() # 删除文件os.rename(src, dst) # 重命名文件 递归遍历文件夹下的所有文件123456import osdst = './path' # 或绝对路径for dirpath, dirnames, filenames in os.walk(dst): for filename in filenames: filepath = os.path.join(dirpath, filename) print(filepath) 文件复制 注意：路径中有空格时需要加引号 1234567import os# Windowsos.system('copy &quot;src.txt&quot; &quot;dst.txt&quot;')# 或os.system('copy &quot;src.txt&quot; &quot;e://&quot;') # 不重命名# Linuxos.system('cp &quot;src.txt&quot; &quot;dst.txt&quot;') 文件夹操作123456import osdef createDirectory(directory): if not os.path.exists(directory): os.makedirs(directory) return 123456789101112131415161718192021# 对路径的操作都在 path 子模块下os.path.isabs(path) # 判断是否绝对路径os.path.exists(path) # 判断是否真实存在os.path.isdir(path) # 判断是否是个真实存在的目录os.path.isfile(path) # 判断是否是个真实存在的文件os.path.dirname(path) # 返回路径的目录部分os.path.basename(path) # 返回路径的基路径名（最后一个分隔符右边的部分）os.path.split(path) # 把路径分割成 dirname 和 basename，返回一个元组os.path.splitdrive(path) # 分隔盘符(windows系统)os.path.splitext(path) # 分隔文件名和扩展名（含点）os.path.abspath(path) # 返回绝对路径（在相对路径 path 前加上当前目录）os.path.normcase(path) # 转换path的大小写和斜杠os.path.join(path1[, path2[, ...]]) # 把目录和文件名合成一个路径# 系统级别的操作os.getcwd() # 获取当前工作目录（get current work directory）os.chdir(path) # 改变工作目录os.listdir(path) # 列出目录（默认为当前目录）下的文件，返回一个文件名列表（含扩展名）os.mkdir(path) # 创建单个目录os.makedirs(path) # 创建多级目录 其他方法： 方法 说明 os.path.commonprefix(list) 返回list(多个路径)中，所有path共有的最长的路径 os.path.lexists 路径存在则返回True,路径损坏也返回True os.path.expanduser(path) 把path中包含的”“和”user”转换成用户目录 os.path.expandvars(path) 根据环境变量的值替换path中包含的”$name”和”$​{name}” os.path.getatime(path) 返回最近访问时间（浮点型秒数） os.path.getmtime(path) 返回最近文件修改时间 os.path.getctime(path) 返回文件 path 创建时间 os.path.getsize(path) 返回文件大小，如果文件不存在就返回错误 os.path.isabs(path) 判断是否为绝对路径 os.path.islink(path) 判断路径是否为链接 os.path.ismount(path) 判断路径是否为挂载点 os.path.normpath(path) 规范path字符串形式 os.path.realpath(path) 返回path的真实路径 os.path.relpath(path[, start]) 从start开始计算相对路径 os.path.samefile(path1, path2) 判断目录或文件是否相同 os.path.sameopenfile(fp1, fp2) 判断fp1和fp2是否指向同一文件 os.path.samestat(stat1, stat2) 判断stat tuple stat1和stat2是否指向同一个文件 os.path.splitdrive(path) 一般用在 windows 下，返回驱动器名和路径组成的元组 os.path.splitext(path) 分割路径，返回路径名和文件扩展名的元组 os.path.splitunc(path) 把路径分割为加载点与文件 os.path.walk(path, visit, arg) 遍历path，进入每个目录都调用visit函数，visit函数必须有3个参数(arg, dirname, names)，dirname表示当前目录的目录名，names代表当前目录下的所有文件名，args则为walk的第三个参数 os.path.supports_unicode_filenames 设置是否支持unicode路径名 示例重命名文件1234import ossrc = os.path.join(os.getcwd(), 'run.py')dst = os.path.join(os.getcwd(), 'newrun.txt')os.rename(src, dst) 文件解压zip文件123456789101112src = os.path.abspath(&quot;./src&quot;)dst = os.path.abspath(&quot;./dst&quot;)filenames = os.listdir(src)for filename in filenames: src_file = os.path.join(src, filename) dst_file = os.path.join(dst, filename.strip('.zip')) # 文件夹名 try: zip_file = zipfile.ZipFile(src_file) zip_file.extractall(dst_file) zip_file.close() # 关闭文件，释放内存 except zipfile.BadZipFile as e: # 后缀是zip但不是压缩文件 print('Zip error.') 若出现文件/文件夹乱码，则需要修改 zipfile.py 源码。建议将 cp437 改成 ansi。 12345678910if flags &amp; 0x800: # 这个判断好像也有问题 # UTF-8 file names extension filename = filename.decode('utf-8')else: # Historical ZIP filename encoding # filename = filename.decode('cp437') try: filename = filename.decode('ansi') except UnicodeDecodeError: filename = filename.decode('utf-8') JSON 文件操作12345678910111213import jsonjson_string = '{&quot;name&quot;: &quot;wbx&quot;, &quot;age&quot;:&quot;23&quot;}'# 将字符串或json文件解析成python字典,loads的s是string的意思dic = json.loads(json_string)# 或with open(&quot;json_file&quot;, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: dic2 = json.load(f)# 将python字典编码成json格式文本text = json.dump(dic)text2 = json.dump(dic2) CSV 文件操作12345678import csv# 写入csv文件with open(&quot;temp.csv&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;) as f: csvwriter = csv.writer(f) csvwriter.writerow(['周杰伦', '30', '170cm']) csvwriter.writerow(['林俊杰', '20', '180cm']) csvwriter.writerow(['蔡依林', '30', '160cm']) Pandas 第三方库Series 数据结构1series['column'] DataFrame 数据结构索引 操作 句法 结果 选择列 df[col] Series 用标签选择行 df.loc[label] Series 用整数位置选择行 df.iloc[loc] Series 行切片 df[5:10] DataFrame 用布尔向量选择行 df[bool_vec] DataFrame 1# 例 删除数据 1df_new = df.drop('label') Excel12345678# pip install openpyxl# pip install xlrd # .xls文件需要此包import pandasif __name__ == &quot;__main__&quot;: filename = 'data.xlsx' df = pandas.read_excel(filename, sheet_name=&quot;第一批推免面试&quot;) print(df) Time 模块12345678import timetime_str = &quot;Fri, 29 Oct 2021 20:32:29 +0800&quot;time_obj = time.strptime(time_str, '%a, %d %b %Y %H:%M:%S %z') # p: parser 解析time_obj = time.strftime('%a, %d %b %Y %H:%M:%S %z', time_obj) # f: format 格式化输出time_stamp = time.mktime(time_obj) # 返回 floatprint(time_stamp) 时间的格式化字符规则见 time — Time access and conversions — Python 3.10.0 documentation Email 模块问题python -m pip 和 pip 的区别以及在虚拟环境中的情况在能执行成功的情况下一般没有区别。实际有没有区别应该看Windows的环境变量PATH包含了哪些路径以及路径的顺序如何。在PowerShell中可通过命令 1$env:path 查看PATH变量。 如果在Windows的环境变量PATH中添加有python.exe所在的目录C:\\Users\\wbx\\AppData\\Local\\Programs\\Python\\Python37，则在PowerShell中能使用python开头的命令；同样，如果在Windows的环境变量PATH中添加有pip.exe所在的目录C:\\Users\\wbx\\AppData\\Local\\Programs\\Python\\Python37\\Scripts，则在PowerShell下能使用pip开头的命令。 安装Python的时候勾选「将Python添加到路径」，则以上两个路径会添加到PATH变量中，若没有勾选则需要手动添加。 在Python的虚拟环境下，python.exe和pip.exe都放在venv/Script目录下，虚拟环境激活后该路径会被临时添加到环境变量PATH的开头，因此这时候执行python或pip开头的命令的实质都是调用venv/Script目录下的可执行程序。 注意： venv/Script目录下的python.exe的作用应该是调用系统环境中的python.exe，但pip.exe应该是独立的。 若venv/Script目录下的pip.exe被删除，则激活虚拟环境并执行pip命令后，系统会在PATH变量中搜寻有pip.exe的目录并执行，因此虽然此时虚拟环境已经激活（表现为命令行当前路径前面有类似(venv)的标志），但实际执行的pip.exe却不是虚拟环境下的。 参考：理解Python虚拟环境 - 知乎 (zhihu.com) 虚拟环境的升级与迁移迁移方法见升级python版本和搭建环境 - 云+社区 - 腾讯云 (tencent.com)。 注意：虚拟环境是与解释器的版本关联的，因此假设Python从3.7.3升级到3.7.4，那么虚拟环境也应该重新搭建，否则会出现一些奇奇怪怪的问题。 第三方库的安装路径实测，用 pip 命令安装 Python 第三方库的时候，库的安装路径在 myvenv/pyvenv.cfg 的 home 中进行设置，初始化虚拟环境的时候默认的 myvenv/pyvenv.cfg 文件为： 123home = C:\\Users\\username\\AppData\\Local\\Programs\\Python\\Python37include-system-site-packages = falseversion = 3.7.9 因此，若想让后续安装的包放在虚拟环境下，则需要修改 home 值为 C:\\Users\\username\\AppData\\Local\\Programs\\Python\\Python37。 ImportError: attempted relative import with no known parent package（相对路径 import 问题）1234import sys, osBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))sys.path.append(BASE_DIR)import somepkg UnicodeEncodeError / UnicodeDecodeError（编码与解码问题） 见知乎回答：Python 编码为什么那么蛋疼？ - 知乎 (zhihu.com)，写得特别好。 我的理解： 在 Python 中，为了避免出现不必要的问题，字符默认的编码格式都为 Unicode，占 32 位，即 8 字节。然后其中很多字符的高位都为 0，为了减小数据存储时的空间占用和传输的带宽占用，在存储和传输时一般会转化成 UTF-8 格式（UTF 的全称是 Universal Transformation Format）。为什么转化成 UTF-8 格式会减小空间或带宽占用呢？这是因为 UTF-8 是一种变存储长度的编码方法，不同字符用 UTF-8 格式表示，其占用的空间是不同的，比如在全英文环境，用 1 个字节即可表示（这时候等同于 ASCII 码）。实际上在特定的字符集环境下，可以采用特定的字符集来减小空间占用，比如在中英文环境可用 GBK （英文占 1 个字节，中文占 2 个字节）等。 因此，解码都是指解码成 Unicode，编码都是指将 Unicode 编码成其他编码格式。 ANSI：所有各个国家和地区所独立制定的既兼容 ASCII 又互相不兼容的字符编码，微软统称为 ANSI 编码。严格来说，ANSI 的字面意思并非字符编码，而是美国的一个非营利组织——美国国家标准学会（American National Standards Institute）的缩写。 ANSI 这个组织做了很多标准制定工作，包括 C 语言规范 ANSI C，还有各国字符编码对应的“代码页（code page）”标准。（具体什么是代码页，详见后文解释） ANSI 规定简体中文 GB 编码的代码页是 936，所以 GB 编码又叫做 ANSI code page 936 （ANSI标准的代码页936），各国编码之所以被微软统称为ANSI编码的原因即在这里。 后来，或许是出于沿用统一的称呼之目的，有些在当时还并未被 ANSI 定为标准的代码页，也被微软称之为 ANSI代码页，比如 CP943 代码页。 在 Windows 系统的编码处理中，ANSI 编码一般代表系统默认编码方式，而且并不是确定的某一种编码方式——在简体中文操作系统中 ANSI 编码默认指的是 GB 系列编码（GB2312、GBK、GB18030）；在繁体中文操作系统中 ANSI 编码默认指的是 BIG5；在日文操作系统中 ANSI 编码默认指的是 Shift JIS，等等。可在系统区域设置的系统 Locale 中更改。 来源：刨根究底字符编码之七——ANSI编码与代码页(Code Page) - 笨笨阿林 - 博客园 (cnblogs.com) ANSI 并不是某一种特定的字符编码，而是在不同的系统中，ANSI 表示不同的编码。你的美国同事Bob的系统中ANSI编码其实是ASCII编码（ASCII编码不能表示汉字，所以汉字为乱码），而你的系统中（“汉字”正常显示）ANSI编码其实是GBK编码，而韩文系统中（“한국어”正常显示）ANSI编码其实是EUC-KR编码。 来源：ANSI是什么编码？ - malecrab - 博客园 (cnblogs.com) GBK 兼容 GB2312。所以文件名和文件夹名用 GBK 编码也是不会出现乱码的。 CP437：Code Page 437，Windows 7 使用的？ 在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言。 123456789101112import os# 假设工作目录的文件夹名是用cp437编码的（其实是gb2312），在windows中文环境下就会乱码str1 = os.getcwd() # 这里是unicode格式的strbytes1 = str1.encode('gb2312') # 将unicode以gb2312格式编码成用gb2312规则读取不会乱码的字节str2 = bytes1.decode('gbk') # 这里还是unicode格式的str。gbk兼容gb2312print(str1, type(str1))print(bytes1, type(bytes1))print(str2, type(str2))# 从这个例子可以看出，解码成unicode格式并为变量赋值，Python会将该变量自动声明为str数据格式。# bytes1 = str1.encode('gb2312') 应该解释成用gb2312去编码# str2 = bytes1.decode('gbk') 用gbk解码字节 Windows 系统下运行 cmd，菜单栏 - 右键 - 属性，可以查看到 cmd 的默认字符集（编码格式）。Windows 10 下为 936（ANSI，中文环境下即 GBK）。 PowerShell 输入 [System.Text.Encoding]::Default 可以查看系统各种场景下的默认字符集。 引申：一图弄懂ASCII、GB2312、GBK、GB18030编码 - 云+社区 - 腾讯云 (tencent.com) Mac 默认为 UTF-8 参考 https://www.w3cschool.cn/python3/python3-tutorial.html 《Python编程：从入门到实践》","link":"/2021/08/06/1100.html"}],"tags":[{"name":"TODO","slug":"TODO","link":"/tags/TODO/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Vim","slug":"Vim","link":"/tags/Vim/"},{"name":"Hexo - GitHub","slug":"Hexo-GitHub","link":"/tags/Hexo-GitHub/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"LaTeX","slug":"LaTeX","link":"/tags/LaTeX/"}],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"LaTeX","slug":"LaTeX","link":"/categories/LaTeX/"}]}